<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-curriculum-resource/cs61c/projects/proj3" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">Project3 | CS自学社区</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://www.learncs.site/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://www.learncs.site/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://www.learncs.site/docs/curriculum-resource/cs61c/projects/proj3"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Project3 | CS自学社区"><meta data-rh="true" name="description" content="Overview"><meta data-rh="true" property="og:description" content="Overview"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://www.learncs.site/docs/curriculum-resource/cs61c/projects/proj3"><link data-rh="true" rel="alternate" href="https://www.learncs.site/docs/curriculum-resource/cs61c/projects/proj3" hreflang="en"><link data-rh="true" rel="alternate" href="https://www.learncs.site/docs/curriculum-resource/cs61c/projects/proj3" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="CS自学社区 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="CS自学社区 Atom Feed">



<link rel="preconnect" href="https://hm.baidu.com">
<script async src="https://hm.baidu.com/hm.js?c106b2729592653e5e0c26db5e5d3142"></script>
<script src="https://sf-cdn.coze.com/obj/unpkg-va/flow-platform/chat-app-sdk/0.1.0-beta.4/libs/oversea/index.js"></script>
<script>document.addEventListener("DOMContentLoaded",(function(){console.log("DOMContentLoaded coze"),new CozeWebSDK.WebChatClient({config:{bot_id:"7380921096788590598"},componentProps:{title:"AI 助教"}})}))</script><link rel="stylesheet" href="/assets/css/styles.0cbaf963.css">
<link rel="preload" href="/assets/js/runtime~main.b896b442.js" as="script">
<link rel="preload" href="/assets/js/main.cf349332.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="TeachYourselfCS" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="TeachYourselfCS" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">TeachYourselfCS</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">自学路线</a><a class="navbar__item navbar__link" href="/blog">博客</a><a class="navbar__item navbar__link" href="/community">社区</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">前言</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/roadmap">路线图</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/category/课程资源">课程资源</a><button aria-label="Toggle the collapsible sidebar category &#x27;课程资源&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs50x">cs50x</a><button aria-label="Toggle the collapsible sidebar category &#x27;cs50x&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs61a">cs61a</a><button aria-label="Toggle the collapsible sidebar category &#x27;cs61a&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs61b">cs61b</a><button aria-label="Toggle the collapsible sidebar category &#x27;cs61b&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" tabindex="0" href="/docs/curriculum-resource/cs61c">cs61c</a><button aria-label="Toggle the collapsible sidebar category &#x27;cs61c&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/curriculum-resource/cs61c/syllabus">syllabus-课程大纲</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs61c/labs/lab00">labs</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/docs/curriculum-resource/cs61c/projects/proj1">projects</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/curriculum-resource/cs61c/projects/proj1">Project1</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/curriculum-resource/cs61c/projects/proj2">Project2</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/curriculum-resource/cs61c/projects/proj3">Project3</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/curriculum-resource/cs61c/projects/proj4">Project4</a></li></ul></li></ul></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/课程资源"><span itemprop="name">课程资源</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/curriculum-resource/cs61c"><span itemprop="name">cs61c</span></a><meta itemprop="position" content="2"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">projects</span><meta itemprop="position" content="3"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Project3</span><meta itemprop="position" content="4"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Project 3: CS61CPU</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="overview">Overview<a href="#overview" class="hash-link" aria-label="Direct link to Overview" title="Direct link to Overview">​</a></h2><p><strong>Part A Deadline: Friday, October 16, 2020</strong></p><p><strong>Part B Deadline: Sunday, November 1, 2020</strong></p><p>So you’ve (hopefully) dealt with CS61Classify. But, you might be wondering, how exactly do all those <code>sw ra, 40(sp)</code> instructions get executed? What’s inside that mystery chip in your computer called the “CPU”? Welcome to Project 3!</p><p>In Part A (Tasks 1-3), you’ll be wiring up the ALU and RegFile for a basic RISC-V CPU, as well as implementing the CPU datapath for executing <code>addi</code> instructions. In Part B (Tasks 4-5), you’ll use these components (and others) to wire up a working CPU that runs actual RISC-V instructions!</p><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="tips-and-guidelines">Tips and Guidelines<a href="#tips-and-guidelines" class="hash-link" aria-label="Direct link to Tips and Guidelines" title="Direct link to Tips and Guidelines">​</a></h2><ul><li>Do not use the version of Logisim preinstalled on the Soda lab computers, as this will mess up your circuits! Use the <code>logisim-evolution.jar</code> provided in your project repository.</li><li>You are only allowed to use Logisim’s built-in blocks from the following libraries for all parts of this project: Wiring (<strong>except Transistor, Transmission Gate, POR, Pull Resistor, Power, Ground, POR, Do not connect</strong>), Gates, Plexers, Arithmetic (<strong>except Divider</strong>), Memory (<strong>except RAM, Random Generator</strong>) Note that the use of <strong>ROM</strong> is allowed.</li><li>Save frequently and commit frequently! Try to save your code in Logisim every 5 minutes or so, and commit every time you produce a new feature, even if it is small.</li><li>Sanity tests for most project tasks are included with the project starter code. More information is available under the Testing section of each task.</li><li>See <a href="https://web.archive.org/web/20220121165045/https://inst.eecs.berkeley.edu/~cs61c/fa20/lectures/videos?ytvid=qFIPWt9Pu7I" target="_blank" rel="noopener noreferrer">this video</a> for a custom tests and debugging walkthrough video</li><li>Do not move the input and output pins in your circuit, since this could knock the pins out of alignment (in other words, autograder tests will fail)! Check the harness circuits, as well as <code>cpu.circ</code>, to make sure your circuits fit in the testing harnesses.</li><li>You may make new subcircuits, but they must be located in the files given in the starter code. You may not make new <code>.circ</code> files; the autograder will fail you if you do this!</li><li>You must use unique names for each subcircuit across all <code>.circ</code> files. Failing to do this will result in reduced autograder points. You may not change the names of any circuits provided in the starter files.</li><li><code>.circ</code> files use the XML format, which makes it hard for Git to automerge. We recommend working on a single computer at a time; if you use multiple computers, make sure that you have pushed and pulled your code before switching devices.</li><li>Your submission must be reasonably efficient: It should not take a very long time to run a single test.</li><li>We recommend completing Lab 05 before starting on Part A of the project and Lab 06 before starting on Part B of this project. Both labs cover many Logisim basics that will be useful for the respective parts of the project.</li><li>A Logisim library reference can be found by going to <code>Help-&gt;Library Reference</code> within Logisim.</li><li>Some common sources of Logisim errors, for your debugging convenience:</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="alt-text"><img loading="lazy" alt="alt-text" src="/assets/images/error_wire_2-b88a64387701d712f3add5f29b8c32f8.png" class="img_ev3q"><a href="#alt-text" class="hash-link" aria-label="Direct link to alt-text" title="Direct link to alt-text">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="part-a-getting-started">Part A: Getting Started<a href="#part-a-getting-started" class="hash-link" aria-label="Direct link to Part A: Getting Started" title="Direct link to Part A: Getting Started">​</a></h2><p>For this project, the computer you’re working on needs be able to run Java and Python 3, which you should have set up in Project 2. This project specification will use <code>python3</code> for sample commands; depending on your system, you may need to use <code>python</code> or <code>py</code> instead. We will be using Logisim Evolution, a Java-based GUI program, so we strongly recommend working on a laptop or desktop with Java installed and <strong>a monitor directly attached</strong>. Using window forwarding over a Hive SSH session is discouraged, and may lead to instability and general headaches.</p><p>Please follow the directions in this Google Form to get a repository: <a href="https://web.archive.org/web/20220121165045/https://docs.google.com/forms/d/e/1FAIpQLSf6m3CjVF1IxwM6l1dTRjeAtTqwk_5974pOFvhdwCr0ZYrqDQ/viewform?usp=sf_link" target="_blank" rel="noopener noreferrer">https://docs.google.com/forms/d/e/1FAIpQLSf6m3CjVF1IxwM6l1dTRjeAtTqwk<!-- -->_<!-- -->5974pOFvhdwCr0ZYrqDQ/viewform?usp=sf<!-- -->_<!-- -->link</a>. After completing the form, clone your GitHub Classroom repository and add the starter code repository as a remote:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ git clone YOUR_REPO_URL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ cd YOUR_REPO_NAME</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ git remote add starter https://github.com/61c-teach/fa20-proj3-starter.git</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ git pull starter master</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>If we make changes to the starter code, you can update your repository with <code>git pull starter master</code>.</p><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="task-1-arithmetic-logic-unit-alu">Task 1: Arithmetic Logic Unit (ALU)<a href="#task-1-arithmetic-logic-unit-alu" class="hash-link" aria-label="Direct link to Task 1: Arithmetic Logic Unit (ALU)" title="Direct link to Task 1: Arithmetic Logic Unit (ALU)">​</a></h2><p>Your first task is to create an ALU that supports all the operations needed by the instructions in our ISA (which is described in further detail in the next section). Please note that we treat overflow as RISC-V does with unsigned instructions, meaning that we ignore overflow.</p><p>We have provided a skeleton of an ALU for you in <code>alu.circ</code>. It has three inputs:</p><table><thead><tr><th>Input Name</th><th>Bit Width</th><th>Description</th></tr></thead><tbody><tr><td>A</td><td>32</td><td>Data to use for Input A in the ALU operation</td></tr><tr><td>B</td><td>32</td><td>Data to use for Input B in the ALU operation</td></tr><tr><td>ALUSel</td><td>4</td><td>Selects which operation the ALU should perform (see the list of operations with corresponding switch values below)</td></tr></tbody></table><p>… and one output:</p><table><thead><tr><th>Output Name</th><th>Bit Width</th><th>Description</th></tr></thead><tbody><tr><td>Result</td><td>32</td><td>Result of the ALU operation</td></tr></tbody></table><p>Below is the list of ALU operations for you to implement, along with their associated ALUSel values. All of them are required. You are allowed and encouraged to use built-in Logisim blocks to implement the arithmetic operations. <strong>Please note that mulh is no longer extra credit due to the addition of a signed multiplier in Logisim which makes implementation as simple as mulhu.</strong></p><table><thead><tr><th>Switch Value</th><th>Instruction</th></tr></thead><tbody><tr><td>0</td><td>add: <code>Result = A + B</code></td></tr><tr><td>1</td><td>and: <code>Result = A &amp; B</code></td></tr><tr><td>2</td><td>or: `Result = A</td></tr><tr><td>3</td><td>xor: <code>Result = A ^ B</code></td></tr><tr><td>4</td><td>srl: <code>Result = (unsigned) A &gt;&gt; B</code></td></tr><tr><td>5</td><td>sra: <code>Result = (signed) A &gt;&gt; B</code></td></tr><tr><td>6</td><td>sll: <code>Result = A &lt;&lt; B</code></td></tr><tr><td>7</td><td>slt: <code>Result = (A &lt; B (signed)) ? 1 : 0</code></td></tr><tr><td>8</td><td>Unused</td></tr><tr><td>9</td><td>Unused</td></tr><tr><td>10</td><td>mul: <code>Result = (signed) (A * B)[31:0]</code></td></tr><tr><td>11</td><td>mulhu: <code>Result = (A * B)[63:32]</code></td></tr><tr><td>12</td><td>sub: <code>Result = A - B</code></td></tr><tr><td>13</td><td>bsel: <code>Result = B</code></td></tr><tr><td>14</td><td>mulh: <code>Result = (signed) (A * B)[63:32]</code></td></tr></tbody></table><p>When implementing <code>mul</code> and <code>mulh</code>, notice that the multiply block has a “Carry Out” output (the adder block also has this, but you will not need this).</p><p>You can make any modifications to <code>alu.circ</code> you want, but the outputs <strong>must</strong> obey the behavior specified above. If you create additional subcircuits, they must also be in <code>alu.circ</code> (you may not make new <code>.circ</code> files). Additionally, your ALU <strong>must</strong> be able to fit in the provided harness <code>alu_harness.circ</code>. This means that you should take care not to move inputs or outputs. To verify that changes you made didn’t break anything, you can open <code>alu_harness.circ</code> and ensure there are no errors and that the circuit functions well.</p><p><strong>Hints:</strong></p><ul><li><code>add</code> is already made for you; feel free to use a similar structure when implementing your other blocks.</li><li>You can hover your cursor over an input/output on a block to get more detailed information about that input/output.</li><li>If you want to know more details about each block, go to Help-&gt;Library Reference for more information on the block and its inputs and outputs.</li><li>You might find bit splitters or extenders useful when implementing <code>sra</code> and <code>srl</code>.</li><li>Use tunnels! They will make your wiring cleaner and easier to follow, and will reduce your chances of encountering crossed wires or unexpected errors.</li><li>A multiplexer (MUX) might be useful when deciding which block output you want to output. In other words, consider simply processing the input in all blocks, and then outputing the one of your choice.</li></ul><hr><h3 class="anchor anchorWithStickyNavbar_LWe7" id="alu-testing">ALU Testing<a href="#alu-testing" class="hash-link" aria-label="Direct link to ALU Testing" title="Direct link to ALU Testing">​</a></h3><p>We’ve provided a group of ALU sanity tests in the <code>tests/part_a/alu</code> directory. Running the test runner for this group will run the ALU tests and produce output in the <code>tests/part_a/alu/student_output</code> directory. As a reminder you can find a debugging walkthrough at <a href="https://web.archive.org/web/20220121165045/https://inst.eecs.berkeley.edu/~cs61c/fa20/lectures/videos?ytvid=qFIPWt9Pu7I" target="_blank" rel="noopener noreferrer">this video</a>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ python3 test_runner.py part_a alu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We’ve also provided <code>binary_to_hex_alu.py</code>, which can interpret this output in a readable format for you. To use it, do the following:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ cd tests/part_a/alu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ python3 binary_to_hex_alu.py PATH_TO_OUTPUT_FILE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>For example, to see <code>reference_output/alu-add-ref.out</code> in readable format, you would do this:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ cd tests/part_a/alu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ python3 binary_to_hex_alu.py reference_output/alu-add-ref.out</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>If you want to see the difference between your output and the reference solution, put the readable outputs into new <code>.out</code> files and <code>diff</code> them. For example, for the <code>alu-add</code> test, you would do:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ cd tests/part_a/alu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ python3 binary_to_hex_alu.py reference_output/alu-add-ref.out &gt; reference.out</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ python3 binary_to_hex_alu.py student_output/alu-add-student.out &gt; student.out</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ diff reference.out student.out</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="task-2-register-file-regfile">Task 2: Register File (RegFile)<a href="#task-2-register-file-regfile" class="hash-link" aria-label="Direct link to Task 2: Register File (RegFile)" title="Direct link to Task 2: Register File (RegFile)">​</a></h2><p>As you learned in class, RISC-V architecture has 32 registers. For this project <strong>we will implement all of them</strong>. To aid in debugging <strong>we have written the regfile to expose the 9 ports specified below</strong>. Please make sure that the values of these register are attached to the proper outputs.</p><p>Your RegFile should be able to write to or read from these registers specified in a given RISC-V instruction without affecting any other registers. There is one notable exception: your RegFile should NOT write to x0, even if an instruction tries. Remember that the zero register should ALWAYS have the value 0x0. You should NOT gate the clock at any point in your RegFile: the clock signal should ALWAYS connect directly to the clock input of the registers without passing through ANY combinational logic.</p><p>The exposed registers and their corresponding numbers are listed below.</p><table><thead><tr><th>Register Number</th><th>Register Name</th></tr></thead><tbody><tr><td>x0</td><td>x0</td></tr><tr><td>x1</td><td>ra</td></tr><tr><td>x2</td><td>sp</td></tr><tr><td>x5</td><td>t0</td></tr><tr><td>x6</td><td>t1</td></tr><tr><td>x7</td><td>t2</td></tr><tr><td>x8</td><td>s0</td></tr><tr><td>x9</td><td>s1</td></tr><tr><td>x10</td><td>a0</td></tr></tbody></table><p>You are provided with the skeleton of a register file in <code>regfile.circ</code>. The register file circuit has six inputs:</p><table><thead><tr><th>Input Name</th><th>Bit Width</th><th>Description</th></tr></thead><tbody><tr><td>Clock</td><td>1</td><td>Input providing the clock. This signal can be sent into subcircuits or attached directly to the clock inputs of memory units in Logisim, but should not otherwise be gated (i.e., do not invert it, do not “and” it with anything, etc.).</td></tr><tr><td>RegWEn</td><td>1</td><td>Determines whether data is written to the register file on the next rising edge of the clock.</td></tr><tr><td>Read Register 1 (rs1)</td><td>5</td><td>Determines which register’s value is sent to the Read Data 1 output, see below.</td></tr><tr><td>Read Register 2 (rs2)</td><td>5</td><td>Determines which register’s value is sent to the Read Data 2 output, see below.</td></tr><tr><td>Write Register (rd)</td><td>5</td><td>Determines which register to set to the value of Write Data on the next rising edge of the clock, assuming that RegWEn is a 1.</td></tr><tr><td>Write Data (wb)</td><td>32</td><td>Determines what data to write to the register identified by the Write Register input on the next rising edge of the clock, assuming that RegWEn is 1.</td></tr></tbody></table><p>The register file also has the following outputs:</p><table><thead><tr><th>Output Name</th><th>Bit Width</th><th>Description</th></tr></thead><tbody><tr><td>rs1</td><td>32</td><td>Driven with the value of the register identified by the Read Register 1 input.</td></tr><tr><td>rs2</td><td>32</td><td>Driven with the value of the register identified by the Read Register 2 input.</td></tr><tr><td><code>ra</code> Value</td><td>32</td><td>Always driven with the value of <code>ra</code> (This is a DEBUG/TEST output.)</td></tr><tr><td><code>sp</code> Value</td><td>32</td><td>Always driven with the value of <code>sp</code> (This is a DEBUG/TEST output.)</td></tr><tr><td><code>t0</code> Value</td><td>32</td><td>Always driven with the value of <code>t0</code> (This is a DEBUG/TEST output.)</td></tr><tr><td><code>t1</code> Value</td><td>32</td><td>Always driven with the value of <code>t1</code> (This is a DEBUG/TEST output.)</td></tr><tr><td><code>t2</code> Value</td><td>32</td><td>Always driven with the value of <code>t2</code> (This is a DEBUG/TEST output.)</td></tr><tr><td><code>s0</code> Value</td><td>32</td><td>Always driven with the value of <code>s0</code> (This is a DEBUG/TEST output.)</td></tr><tr><td><code>s1</code> Value</td><td>32</td><td>Always driven with the value of <code>s1</code> (This is a DEBUG/TEST output.)</td></tr><tr><td><code>a0</code> Value</td><td>32</td><td>Always driven with the value of <code>a0</code> (This is a DEBUG/TEST output.)</td></tr></tbody></table><p>The test outputs at the top of your <code>regfile.circ</code> file are present for testing and debugging purposes. If you were implementing a real register file, you would omit those outputs. In our case, be sure they are included correctly–if they are not, you will not pass.</p><p>You can make any modifications to <code>regfile.circ</code> you want, but the outputs must obey the behavior specified above. If you create additional subcircuits, they must also be in <code>regfile.circ</code> (you may not make new <code>.circ</code> files). In addition, your <code>regfile.circ</code> that you submit <strong>must</strong> fit into the <code>regfile_harness.circ</code> file we have provided for you. This means that you should take care not to move inputs or outputs. To verify changes you have made didn’t break anything, you can open <code>regfile_harness.circ</code> and ensure there are no errors and that the circuit functions well.</p><p><strong>Hints:</strong></p><ul><li>Take advantage of copy-paste! It might be a good idea to make one register completely and use it as a template for the others to avoid repetitive work.</li><li>I would advise you not to use the enable input on your MUXes. In fact, you can turn that feature off. I would also advise you to also turn “three-state?” to off. Take a look at all the inputs to a Logisim register and see what they all do.</li><li>Again, MUXes are your friend, but also DeMUXes.</li><li>Think about what happens in the register file after a single instruction is executed. Which values change? Which values stay the same? Registers are clock-triggered–what does that mean?</li><li>Keep in mind registers have an “enable” input available, as well as a clock input.</li><li>What is the value of <code>x0</code>?</li></ul><hr><h3 class="anchor anchorWithStickyNavbar_LWe7" id="regfile-testing">RegFile Testing<a href="#regfile-testing" class="hash-link" aria-label="Direct link to RegFile Testing" title="Direct link to RegFile Testing">​</a></h3><p>We’ve provided a group of RegFile sanity tests in the <code>tests/part_a/regfile</code> directory. Running the test runner for this group will run the ALU tests and produce output in the <code>tests/part_a/regfile/student_output</code> directory.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ python3 test_runner.py part_a regfile</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We’ve also provided <code>binary_to_hex_regfile.py</code>, which works like <code>binary_to_hex_alu.py</code> from Task 1.</p><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="task-3-the-addi-instruction">Task 3: The <code>addi</code> Instruction<a href="#task-3-the-addi-instruction" class="hash-link" aria-label="Direct link to task-3-the-addi-instruction" title="Direct link to task-3-the-addi-instruction">​</a></h2><p>As your final task for Part A, you’re going to implement a CPU that’s capable of executing one instruction: <code>addi</code>! You’re welcome to implement other instructions at this time, but you’ll only be graded on whether or not <code>addi</code> executes correctly for Part A. In Part B, there will be more detailed instructions on how to implement the other instructions.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="info-memory">Info: Memory<a href="#info-memory" class="hash-link" aria-label="Direct link to Info: Memory" title="Direct link to Info: Memory">​</a></h3><p>The Memory unit (located in <code>mem.circ</code>) is already fully implemented for you and attached to the outputs of your CPU in <code>test_harness.circ</code>! The <code>addi</code> instruction does NOT use the Memory unit, so you leave those ouputs undriven for Part A. Note that the supplied memory is word-addressable but <strong>byte</strong> level write enabled. This means that the Write<!-- -->_<!-- -->En signal is 4 bits wide and acts as a write mask for the input data. For example, if Write<!-- -->_<!-- -->En is <code>1&#x27;b1000</code>, only the most significant byte of the addressed word in memory will be overwritten. The ReadData port will always return the value in memory at the supplied address, regardless of Write<!-- -->_<!-- -->En.</p><p>Here’s a quick summary of its inputs and outputs:</p><table><thead><tr><th>Signal Name</th><th>Direction</th><th>Bit Width</th><th>Description</th></tr></thead><tbody><tr><td>WriteAddr</td><td>Input</td><td>32</td><td>Address to read/write to in Memory</td></tr><tr><td>WriteData</td><td>Input</td><td>32</td><td>Value to be written to Memory</td></tr><tr><td>Write<!-- -->_<!-- -->En</td><td>Input</td><td>4</td><td>The write mask for instructions that write to Memory and zero otherwise</td></tr><tr><td>CLK</td><td>Input</td><td>1</td><td>Driven by the clock input to the CPU</td></tr><tr><td>ReadData</td><td>Output</td><td>32</td><td>Value of the data stored at the specified address</td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_LWe7" id="info-branch-comparator">Info: Branch Comparator<a href="#info-branch-comparator" class="hash-link" aria-label="Direct link to Info: Branch Comparator" title="Direct link to Info: Branch Comparator">​</a></h3><p>The Branch Comparator unit (located in <code>branch_comp.circ</code>) provided in the skeleton is unimplemented, but the <code>addi</code> instruction does NOT use the Branch Comparator unit, so you don’t have to worry about it for Part A.</p><p>If you are interested, here’s a quick summary of its inputs and outputs:</p><table><thead><tr><th>Signal Name</th><th>Direction</th><th>Bit Width</th><th>Description</th></tr></thead><tbody><tr><td>rs1</td><td>Input</td><td>32</td><td>Value in the first register to be compared</td></tr><tr><td>rs2</td><td>Input</td><td>32</td><td>Value in the second register to be compared</td></tr><tr><td>BrUn</td><td>Input</td><td>1</td><td>Equal to one when an unsigned comparison is wanted, or zero when a signed comparison is wanted</td></tr><tr><td>BrEq</td><td>Output</td><td>1</td><td>Equal to one if the two values are equal</td></tr><tr><td>BrLt</td><td>Output</td><td>1</td><td>Equal to one if the value in rs1 is less than the value in rs2</td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_LWe7" id="info-immediate-generator">Info: Immediate Generator<a href="#info-immediate-generator" class="hash-link" aria-label="Direct link to Info: Immediate Generator" title="Direct link to Info: Immediate Generator">​</a></h3><p>The Immediate Generator (“Imm Gen”) unit (located in <code>imm_gen.circ</code>) provided in the skeleton is unimplemented. The <code>addi</code> instruction requires an immediate generator, but for now you can hard-wire it to construct the immediate for the <code>addi</code> instruction, without worrying about other immediate types.</p><p>To edit this subcircuit, edit the <code>imm_gen.circ</code> file and not the <code>imm_gen</code> in <code>cpu.circ</code>. Note that if you modify this circuit, you will need to close and open <code>cpu.circ</code> to load the changes in your CPU.</p><p>Here’s a quick summary of its inputs and outputs:</p><table><thead><tr><th>Signal Name</th><th>Direction</th><th>Bit Width</th><th>Description</th></tr></thead><tbody><tr><td>inst</td><td>Input</td><td>32</td><td>The instruction being executed</td></tr><tr><td>ImmSel</td><td>Input</td><td>3</td><td>Value determining how to reconstruct the immediate</td></tr><tr><td>imm</td><td>Output</td><td>32</td><td>Value of the immediate in the instruction</td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_LWe7" id="info-processor">Info: Processor<a href="#info-processor" class="hash-link" aria-label="Direct link to Info: Processor" title="Direct link to Info: Processor">​</a></h3><p>We have provided a skeleton for your processor in <code>cpu.circ</code>. You will be using your own implementations of the ALU and RegFile as you construct your datapath. You are responsible for constructing the entire datapath from scratch. For Part A, your completed processor should support the <code>addi</code> instruction using a two-stage pipeline, with IF in the first stage and ID, EX, MEM, and WB in the second stage. To start, however, we recommend you create a single-stage processor with no pipelining. Once that is working, you can modify your processor so that it has a 2-stage pipeline.</p><p>Your processor will sit in a processor harness <code>test_harness.circ</code> that contains the Memory unit. That processor harness then sits in a testing harness <code>run.circ</code> that provides the instructions to the processor. Your process will output the address of an instruction, and accept the instruction at that address as an input. It will also output the data memory address, data memory write enable, and accept the data at that address as an input. Essentially, these two test harnesses are your data memory and instruction respectively. We recommend that you take some time to inspect <code>test_harness.circ</code> and <code>run.circ</code> to see exactly what’s going on. <code>test_harness.circ</code> will be used in the tests provided to you for sanity checking, so make sure your CPU fits in the harness before testing and submitting your work! Your processor has 3 inputs that come from the harness:</p><table><thead><tr><th>Input Name</th><th>Bit Width</th><th>Description</th></tr></thead><tbody><tr><td>READ<!-- -->_<!-- -->DATA</td><td>32</td><td>Driven with the data at the data memory address identified by the WRITE<!-- -->_<!-- -->ADDRESS (see below).</td></tr><tr><td>INSTRUCTION</td><td>32</td><td>Driven with the instruction at the instruction memory address identified by the FETCH<!-- -->_<!-- -->ADDRESS (see below).</td></tr><tr><td>CLOCK</td><td>1</td><td>The input for the clock. As with the register file, this can be sent into subcircuits (e.g. the CLK input for your register file) or attached directly to the clock inputs of memory units in Logisim, but should not otherwise be gated (i.e., do not invert it, do not <code>AND</code> it with anything, etc.).</td></tr></tbody></table><p>Your processor must provide the following outputs to the first level harness:</p><table><thead><tr><th>Output Name</th><th>Bit Width</th><th>Description</th></tr></thead><tbody><tr><td>ra</td><td>32</td><td>Driven with the contents of <code>ra</code> (FOR TESTING)</td></tr><tr><td>sp</td><td>32</td><td>Driven with the contents of <code>sp</code> (FOR TESTING)</td></tr><tr><td>t0</td><td>32</td><td>Driven with the contents of <code>t0</code> (FOR TESTING)</td></tr><tr><td>t1</td><td>32</td><td>Driven with the contents of <code>t1</code> (FOR TESTING)</td></tr><tr><td>t2</td><td>32</td><td>Driven with the contents of <code>t2</code> (FOR TESTING)</td></tr><tr><td>s0</td><td>32</td><td>Driven with the contents of <code>s0</code> (FOR TESTING)</td></tr><tr><td>s1</td><td>32</td><td>Driven with the contents of <code>s1</code> (FOR TESTING)</td></tr><tr><td>a0</td><td>32</td><td>Driven with the contents of <code>a0</code> (FOR TESTING)</td></tr><tr><td>tohost</td><td>32</td><td>Driven with the contents of CSR <code>0x51E</code> (FOR TESTING)</td></tr><tr><td>WRITE<!-- -->_<!-- -->ADDRESS</td><td>32</td><td>This output is used to select which address to read/write data from in data memory.</td></tr><tr><td>WRITE<!-- -->_<!-- -->DATA</td><td>32</td><td>This output is used to provide write data to data memory.</td></tr><tr><td>WRITE<!-- -->_<!-- -->ENABLE</td><td>4</td><td>This output is used to provide the write enable mask to data memory.</td></tr><tr><td>fetch<!-- -->_<!-- -->addr</td><td>32</td><td>This output is used to select which instruction is presented to the processor on the INSTRUCTION input.</td></tr></tbody></table><p>Just like with the ALU and RegFile, be careful <strong>NOT</strong> to move the input or output pins! See the “Testing” section for more information on the harness and tests.</p><hr><h3 class="anchor anchorWithStickyNavbar_LWe7" id="info-control-logic">Info: Control Logic<a href="#info-control-logic" class="hash-link" aria-label="Direct link to Info: Control Logic" title="Direct link to Info: Control Logic">​</a></h3><p>The Control Logic unit (<code>control_logic.circ</code>) provided in the skeleton is unimplemented. Designing your control logic unit will probably be your biggest challenge in Part B. For Part A, you can put a constant for each control signal, because <code>addi</code> is the only instruction you’ll be implementing. As you implement <code>addi</code>, think about where you’ll need to make additions in order to support other instructions.</p><p>To edit this subcircuit, edit the <code>control_logic.circ</code> file and not the <code>control_logic</code> in <code>cpu.circ</code>. Note that if you modify this circuit, you will need to close and open <code>cpu.circ</code> to load the changes in your CPU.</p><p>You are welcome to add more inputs or outputs to the existing starter circuit as your control logic demands. You may also use as many or as few of the supplied ports as needed. That being said, please do not change or remove any of the existing ports during this process.</p><hr><h3 class="anchor anchorWithStickyNavbar_LWe7" id="single-stage-cpu-a-guide">Single Stage CPU: A Guide<a href="#single-stage-cpu-a-guide" class="hash-link" aria-label="Direct link to Single Stage CPU: A Guide" title="Direct link to Single Stage CPU: A Guide">​</a></h3><p>We know that trying to build a CPU with a blank slate might be intimidating, so we wrote the following guide to help you.</p><p>Recall the five stages of the CPU pipeline:</p><ol><li>Instruction Fetch (IF)</li><li>Instruction Decode (ID)</li><li>Execute (EX)</li><li>Memory (MEM)</li><li>Write Back (WB)</li></ol><p>This guide will help you work through each of these stages for the <code>addi</code> instruction. Each section will contain questions for you to think through and pointers to important details, but it won’t tell you exactly how to implement the instruction.</p><p>You may need to read and understand each question before going to the next one, and you can see the answers by <em>clicking on the question</em>. During your implementation, feel free to place things in subcircuits as you see fit.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="stage-1-instruction-fetch">Stage 1: Instruction Fetch<a href="#stage-1-instruction-fetch" class="hash-link" aria-label="Direct link to Stage 1: Instruction Fetch" title="Direct link to Stage 1: Instruction Fetch">​</a></h4><p>The main thing we are concerned about in this stage is: how do we get the current instruction? From lecture, we know that instructions are stored in the instruction memory, and each of these instructions can be accessed through an address.</p><p>1<!-- -->.<!-- --> Which file in the project holds your instruction memory? How does it connect to your <!-- -->`<!-- -->cpu.circ<!-- -->`<!-- --> file? The instruction memory is the ROM module in <!-- -->`<!-- -->run.circ<!-- -->`<!-- -->. It provides an input into your CPU named <!-- -->`<!-- -->INSTRUCTION<!-- -->`<!-- --> and takes an output from your CPU. In your <!-- -->`<!-- -->cpu.circ<!-- -->`<!-- --> file, that output is called <!-- -->`<!-- -->PROGRAM<!-- -->_<!-- -->COUNTER<!-- -->`<!-- -->. In <!-- -->`<!-- -->run.circ<!-- -->`<!-- -->, it is called <!-- -->`<!-- -->fetch<!-- -->_<!-- -->addr<!-- -->`<!-- -->. 2<!-- -->.<!-- --> In your CPU, how would changing the address you output as <!-- -->`<!-- -->PROGRAM<!-- -->_<!-- -->COUNTER<!-- -->`<!-- --> affect the instruction input? The instruction that <!-- -->`<!-- -->run.circ<!-- -->`<!-- --> outputs to your CPU should be the instruction at address <!-- -->`<!-- -->PROGRAM<!-- -->_<!-- -->COUNTER<!-- -->`<!-- --> (or <!-- -->`<!-- -->fetch<!-- -->_<!-- -->addr<!-- -->`<!-- -->) in instruction memory. 3<!-- -->.<!-- --> How do you know what <!-- -->`<!-- -->PROGRAM<!-- -->_<!-- -->COUNTER<!-- -->`<!-- --> should be? <!-- -->`<!-- -->PROGRAM<!-- -->_<!-- -->COUNTER<!-- -->`<!-- --> is the address of the current instruction being executed, so it is saved in the PC register. For this project, your PC will start at 0, as that is the default value for a register. 4<!-- -->.<!-- --> For basic programs without any jumps or branches, how will the PC change from line to line? The PC must increment by 1 instruction in order to go to the next instruction, as the address held by the PC register represents what instruction to execute. This means that your PC will typically increase by 4 (assuming no branch or jump) line to line.</p><p>In <code>cpu.circ</code>, we have provided a simple PC register implementation - ignoring jumps and branches. You will implement branches and jumps in Part B of the project, but for now we are only concerned with being able to run <code>addi</code> instructions.</p><p>Remember that we will eventually implement a 2-stage pipelined processor, so the IF stage is separate from the remaining stages. What circuitry separates the different stages of a pipeline? Specifically, what circuitry separates IF from the next stage? Will you need to add anything?</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="stage-2-instruction-decode">Stage 2: Instruction Decode<a href="#stage-2-instruction-decode" class="hash-link" aria-label="Direct link to Stage 2: Instruction Decode" title="Direct link to Stage 2: Instruction Decode">​</a></h4><p>Now that we have our instruction coming from the <code>instruction</code> input, we break it down in the Instruction Decode step according to the RISC-V instruction formats you have learned.</p><p>1<!-- -->.<!-- --> What type of instruction is addi? What are the different bit fields and which bits are needed for each? I type. The fields are: - <!-- -->`<!-- -->imm <!-- -->[<!-- -->31-20<!-- -->]<!-- -->`<!-- --> - <!-- -->`<!-- -->rs1 <!-- -->[<!-- -->19-15<!-- -->]<!-- -->`<!-- --> - <!-- -->`<!-- -->funct3 <!-- -->[<!-- -->14-12<!-- -->]<!-- -->`<!-- --> - <!-- -->`<!-- -->rd <!-- -->[<!-- -->11-7<!-- -->]<!-- -->`<!-- --> - <!-- -->`<!-- -->opcode <!-- -->[<!-- -->6-0<!-- -->]<!-- -->`<!-- --> 2<!-- -->.<!-- --> In Logisim, what tool would you use to <strong>split</strong> out different groups of bits? The Splitter!</p><p>3<!-- -->.<!-- --> Implement the instruction field decode stage using the instruction input. You should use tunnels to label and group the bits.</p><p>4<!-- -->.<!-- --> Now we need to get the data from the corresponding registers, using the register file. Which instruction fields should be connected to the register file? Which inputs of the register file should it connect to? Instruction field <!-- -->`<!-- -->rs1<!-- -->`<!-- --> will need to connect to read register 1.</p><p>5<!-- -->.<!-- --> Implement reading from the register file. You will have to bring in your RegFile from Part A. Remember to connect the clock!</p><p>6<!-- -->.<!-- --> What does the Immediate Generator need to do? For addi, the immediate generator takes in 12 bits from the instruction and produces a signed 32-bit immediate. You will need to implement this logic in the Immediate Generator subcircuit!</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="stage-3-execute">Stage 3: Execute<a href="#stage-3-execute" class="hash-link" aria-label="Direct link to Stage 3: Execute" title="Direct link to Stage 3: Execute">​</a></h4><p>The Execute stage is where the computation of most instructions is performed. This is also where we will introduce the idea of using a Control Module.</p><p>1<!-- -->.<!-- --> For the add instruction, what should be your inputs to the ALU? Read Data 1 (rs1) and the immediate produced by the Immediate Generator. 2<!-- -->.<!-- --> In the ALU, what is the purpose of ALU<!-- -->_<!-- -->Sel? It determines which operation the ALU will perform. 3<!-- -->.<!-- --> Although it is possible for now to just put a constant as the ALUSel, why would this be infeasible as you implement more instructions? With more instructions, the input to the ALU might need to change, so you will need to have some sort of circuit that changes ALUSel depending on the instruction being executed.</p><p>4<!-- -->.<!-- --> Bring in your ALU and connect the ALU inputs correctly. Do you need to connect the clock? Why or why not?</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="stage-4-memory">Stage 4: Memory<a href="#stage-4-memory" class="hash-link" aria-label="Direct link to Stage 4: Memory" title="Direct link to Stage 4: Memory">​</a></h4><p>The memory stage is where the memory can be written to using store instructions and read from using load instructions. Because the <code>addi</code> instruction does not use memory, we will not spend too much time here.</p><p>At this point, we cannot connect most of the inputs, as we don’t know where they should come from.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="stage-5-write-back">Stage 5: Write Back<a href="#stage-5-write-back" class="hash-link" aria-label="Direct link to Stage 5: Write Back" title="Direct link to Stage 5: Write Back">​</a></h4><p>The write back stage is where the results of the operation is saved back to the registers.</p><p>1<!-- -->.<!-- --> Do <!-- -->`<!-- -->addi<!-- -->`<!-- --> instructions need to write back to a register? Yes. <!-- -->`<!-- -->addi<!-- -->`<!-- --> takes the output of a an addition computation in the ALU and writes it back to the register file.</p><p>2<!-- -->.<!-- --> Let&#x27;s create the write back phase so that it is able to write both ALU and MEM outputs to the Register File. Later, when you implement branching/jumping, you may need to add more to this mux. However, at the moment, we need to choose between the ALU and MEM outputs, as only one wire can end up being an input to the register file. Bring a wire from both the ALU and <!-- -->`<!-- -->READ<!-- -->_<!-- -->DATA<!-- -->`<!-- -->, and connect it to a MUX.</p><p>3<!-- -->.<!-- --> What should you use as the Select input to the MUX? What does the input depend on? This input should be able to choose between three MUX inputs: (1) ALU, (2) MEM <!-- -->[<!-- -->`<!-- -->READ<!-- -->_<!-- -->DATA<!-- -->`<!-- -->]<!-- -->, and (3) PC + 4 (when will you use this?) The control signal that determines which of these inputs is written back is called WBSel. For now, there should only be one value that WBSel can take on -- whatever it should be for <!-- -->`<!-- -->addi<!-- -->`<!-- -->. 4<!-- -->.<!-- --> Now that we have the inputs to the MUX sorted out, we need to wire the output. Where should the output connect to? Because the output is the data that you want to write into the Register File, it should connect to the Write Data input on the Register File.</p><p>5<!-- -->.<!-- --> There are two more inputs on the Register File which are important for writing data: RegWEn and rd. One of these will come from the Instruction Decode stage and the other one will be a new control signal that you need to design for Part B. Please finish off the Writeback stage by these inputs on the RegFile correctly.</p><p>If you have done all of the steps correctly, you should have a single-cycle processor that works for <code>addi</code> instructions.</p><p>Run <code>python3 test_runner.py part_a addi_single</code> and see if it’s working correctly!</p><hr><h3 class="anchor anchorWithStickyNavbar_LWe7" id="pipelining-your-cpu">Pipelining Your CPU<a href="#pipelining-your-cpu" class="hash-link" aria-label="Direct link to Pipelining Your CPU" title="Direct link to Pipelining Your CPU">​</a></h3><p>Now it’s time to implement pipelining in your CPU! For this project, you’ll need to implement a 2-stage pipeline, which is still conceptually similar to the 5-stage pipeline covered in lecture and discussion (review those if you haven’t already). The two stages you’ll implement are:</p><p><strong>1<!-- -->.<!-- --> Instruction Fetch:</strong> An instruction is fetched from the instruction memory.</p><p><strong>2<!-- -->.<!-- --> Execute:</strong> The instruction is decoded, executed, and committed (written back). This is a combination of the remaining four stages of a normal five-stage RISC-V pipeline (ID, EX, MEM and WB).</p><p>Because all of the control and execution is handled in the Execute stage, <strong>your processor should be more or less indistinguishable from a single-cycle implementation, barring the one-cycle startup latency.</strong> However, we will be enforcing the two-stage pipeline design. Some things to consider:</p><ul><li>Will the IF and EX stages have the same or different <code>PC</code> values?</li><li>Do you need to store the <code>PC</code> between the pipelining stages?</li></ul><p>You might also notice a bootstrapping problem here: during the first cycle, the instruction register sitting between the pipeline stages won’t contain an instruction loaded from memory. How do we deal with this? It happens that Logisim automatically sets registers to zero on reset; the instruction register will then contain a <code>nop</code>. We will allow you to depend on this behavior of Logisim. Remember to go to Simulate <code>--&gt;</code> Reset Simulation (Cmd + R or Ctrl + R on Windows) to reset your processor.</p><p>After pipelining your processor, you should be able to pass <code>python3 test_runner.py part_a addi_pipelined</code> test. Note that the single-stage test will now fail, which is expected behavior (why? look back at the reference outputs for each test, and think about the effects of pipelining on different stages).</p><hr><h3 class="anchor anchorWithStickyNavbar_LWe7" id="testing">Testing<a href="#testing" class="hash-link" aria-label="Direct link to Testing" title="Direct link to Testing">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="understanding-the-tests">Understanding the Tests<a href="#understanding-the-tests" class="hash-link" aria-label="Direct link to Understanding the Tests" title="Direct link to Understanding the Tests">​</a></h4><p>Each test is a copy of the <code>run.circ</code> file included with the starter code that has instructions loaded into its IMEM. When you run logisim-evolution from the command line, the clock ticks, the program counter is incremented, and the values in each of the outputs is printed to stdout.</p><p>Let’s take as the one stage addi test as an example. It has 3 addi instructions (<code>addi t0, x0, 5</code>, <code>addi t1, t0, 7</code>, <code>addi s0, t0, 9</code>). Open <code>tests/part_a/addi_pipelined/cpu-addi-pipelined.circ</code> in Logisim Evolution, and take a closer look at the various parts of the test file. At the top, you’ll see the place where your CPU is connected to the test outputs. With the starter code, you’ll see all xxxx’s, as you do below; when your CPU is working, this should not be the case. Your CPU takes in one input (instruction), and along with the values in each of the registers, it has one additional output: <code>fetch_addr</code>, or the address of the instruction to be fetched from IMEM to be executed the next clock cycle.</p><p>Be careful that you don’t move any of the inputs/outputs of your CPU around, or add any additional inputs/outputs. This will change the shape of the CPU subcircuit, and as a result the connections in the test files may no longer work properly.</p><p>Below the CPU, you’ll see instruction memory. The hex for the 3 addi instructions (0x00500293, 0x00728313, 0x00928413) has been loaded into instruction memory. Instruction memory takes in one input (called <code>fetch_addr</code>) and outputs the instruction at that address. <code>fetch_addr</code> is a 32-bit value, but because Logisim Evolution caps the size of ROM units at 2^16B, we have to use a splitter to get only 14 bits from <code>fetch_addr</code> (ignoring the bottommost two bits). Notice that <code>fetch_addr</code> is a <strong>byte address</strong>, not a word address.</p><p>So what happens when the clock ticks? Each tick of the clock increments an input in the test file called <code>Time_Step</code>. The clock will continue to tick until <code>Time_Step</code> is equal to the halting constant for that test file (for this particular test file, the halting constant is 5). At that point, the Logisim Evolution command line will print the values in each of your outputs to stdout. Our tests will compare this output to the expected; if your output is different, you will fail the test.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="addi-tests"><code>addi</code> Tests<a href="#addi-tests" class="hash-link" aria-label="Direct link to addi-tests" title="Direct link to addi-tests">​</a></h4><p>We’ve included 2 tests for the <code>addi</code> instruction with the starter code: one for a single-cycle CPU and one for a pipelined CPU. You can run the pipelined tests with the following commands (replace <code>pipelined</code> with <code>single</code> for single-cycle tests):</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ python3 test_runner.py part_a addi_pipelined # For a pipelined CPU</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>You can see the <code>.s</code> (RISC-V) and <code>.hex</code> (machine code) files for the test in <code>tests/part_a/addi_pipelined/inputs</code>.</p><p>We’ve included a Python script to interpret your output: <code>binary_to_hex_cpu.py</code>, which works like <code>binary_to_hex_alu.py</code> and <code>binary_to_hex_regfile.py</code> from the previous tasks. To use the script to see your CPU’s output, run:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ cd tests/part_a/addi_pipelined</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ python3 binary_to_hex_cpu.py student_output/CPU-addi-pipelined-student.out</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>or, to see the reference output, run:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ cd tests/part_a/addi_pipelined</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ python3 binary_to_hex_cpu.py reference_output/CPU-addi-pipelined-ref.out</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>As a reminder you can find a debugging walkthrough at <a href="https://web.archive.org/web/20220121165045/https://inst.eecs.berkeley.edu/~cs61c/fa20/lectures/videos?ytvid=qFIPWt9Pu7I" target="_blank" rel="noopener noreferrer">this video</a>.</p><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="part-a-submission">Part A: Submission<a href="#part-a-submission" class="hash-link" aria-label="Direct link to Part A: Submission" title="Direct link to Part A: Submission">​</a></h2><p>At this point, if you’ve completed tasks 1-3, you’ve finished Part A of the project!</p><p>Double-check that you have not moved your input/output pins, and that your circuits fit in the provided testing harnesses. Make sure that you did not create any additional <code>.circ</code> files; the autograder will only be testing the circuit files you needed to edit in the starter code (<code>alu.circ</code>, <code>branch_comp.circ</code>, <code>control_logic.circ</code>, <code>cpu.circ</code>, <code>imm_gen.circ</code>, and <code>regfile.circ</code>).</p><p><strong>Your last bit of work before you submit is to write down how you implemented components for this part of the project readme.md. There is already a template for you to use and don’t worry about going into too much detail, we just want you to reflect on what you did in this part and explain the reasoning behind the design choices you made! You must also document the breakdown of labor between you and your partner! Tell us who did what in both implementation and design.</strong></p><p>Submit your repo to the <code>Project 3A</code> assignment on Gradescope.</p><p>The autograder for Part A uses the same tests as the test files provided in the starter code.</p><p>The rest of this spec describes the tasks for Part B.</p><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="part-b">Part B<a href="#part-b" class="hash-link" aria-label="Direct link to Part B" title="Direct link to Part B">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="task-4-more-instructions">Task 4: More Instructions<a href="#task-4-more-instructions" class="hash-link" aria-label="Direct link to Task 4: More Instructions" title="Direct link to Task 4: More Instructions">​</a></h2><p>In Task 3, you wired up a basic pipelined CPU capable of executing <code>addi</code> instructions. Now, you’ll implement support for more instructions!</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-instruction-set-architecture-isa">The Instruction Set Architecture (ISA)<a href="#the-instruction-set-architecture-isa" class="hash-link" aria-label="Direct link to The Instruction Set Architecture (ISA)" title="Direct link to The Instruction Set Architecture (ISA)">​</a></h3><p>We will be grading your CPU implementation on <strong>only</strong> the instructions listed below. Your CPU must support these instructions, but feel free to implement any additional instructions you want as long as they don’t affect your implementation of the required instructions. Implementing additional instructions will not affect your score.</p><table><tbody><tr><td><b>Instruction</b></td><td><b>Type</b></td><td><b>Opcode</b></td><td><b>Funct3</b></td><td><b>Funct7/Immediate</b></td><td><b>Operation</b></td></tr><tr><td>add rd, rs1, rs2</td><td rowspan="12">R</td><td rowspan="12">0x33</td><td>0x0</td><td>0x00</td><td>R[rd] ← R[rs1] + R[rs2]</td></tr><tr><td>mul rd, rs1, rs2</td><td>0x0</td><td>0x01</td><td>R[rd] ← (R[rs1] * R[rs2])[31:0]</td></tr><tr><td>sub rd, rs1, rs2</td><td>0x0</td><td>0x20</td><td>R[rd] ← R[rs1] - R[rs2]</td></tr><tr><td>sll rd, rs1, rs2</td><td>0x1</td><td>0x00</td><td>R[rd] ← R[rs1] &lt;&lt; R[rs2]</td></tr><tr><td>mulh rd, rs1, rs2</td><td>0x1</td><td>0x01</td><td>R[rd] ← (R[rs1] * R [rs2])[63:32]</td></tr><tr><td>mulhu rd, rs1, rs2</td><td>0x3</td><td>0x01</td><td>(unsigned) R[rd] ← (R[rs1] * R[rs2])[63:32]</td></tr><tr><td>slt rd, rs1, rs2</td><td>0x2</td><td>0x00</td><td>R[rd] ← (R[rs1] &lt; R[rs2]) ? 1 : 0 (signed)</td></tr><tr><td>xor rd, rs1, rs2</td><td>0x4</td><td>0x00</td><td>R[rd] ← R[rs1] ^ R[rs2]</td></tr><tr><td>srl rd, rs1, rs2</td><td>0x5</td><td>0x00</td><td>(unsigned) R[rd] ← R[rs1] &gt;&gt; R[rs2]</td></tr><tr><td>sra rd, rs1, rs2</td><td>0x5</td><td>0x20</td><td>(signed) R[rd] ← R[rs1] &gt;&gt; R[rs2]</td></tr><tr><td>or rd, rs1, rs2</td><td>0x6</td><td>0x00</td><td>R[rd] ← R[rs1] | R[rs2]</td></tr><tr><td>and rd, rs1, rs2</td><td>0x7</td><td>0x00</td><td>R[rd] ← R[rs1] &amp; R[rs2]</td></tr><tr><td>lb rd, offset(rs1)</td><td rowspan="11">I</td><td rowspan="3">0x03</td><td>0x0</td><td></td><td>R[rd] ← SignExt(Mem(R[rs1] + offset, byte))</td></tr><tr><td>lh rd, offset(rs1)</td><td>0x1</td><td></td><td>R[rd] ← SignExt(Mem(R[rs1] + offset, half))</td></tr><tr><td>lw rd, offset(rs1)</td><td>0x2</td><td></td><td>R[rd] ← Mem(R[rs1] + offset, word)</td></tr><tr><td>addi rd, rs1, imm</td><td rowspan="8">0x13</td><td>0x0</td><td></td><td>R[rd] ← R[rs1] + imm</td></tr><tr><td>slli rd, rs1, imm</td><td>0x1</td><td>0x00</td><td>R[rd] ← R[rs1] &lt;&lt; imm</td></tr><tr><td>slti rd, rs1, imm</td><td>0x2</td><td></td><td>R[rd] ← (R[rs1] &lt; imm) ? 1 : 0</td></tr><tr><td>xori rd, rs1, imm</td><td>0x4</td><td></td><td>R[rd] ← R[rs1] ^ imm</td></tr><tr><td>srli rd, rs1, imm</td><td>0x5</td><td>0x00</td><td>R[rd] ← R[rs1] &gt;&gt; imm</td></tr><tr><td>srai rd, rs1, imm</td><td>0x5</td><td>0x20</td><td>R[rd] ← R[rs1] &gt;&gt; imm</td></tr><tr><td>ori rd, rs1, imm</td><td>0x6</td><td></td><td>R[rd] ← R[rs1] | imm</td></tr><tr><td>andi rd, rs1, imm</td><td>0x7</td><td></td><td>R[rd] ← R[rs1] &amp; imm</td></tr><tr><td>sb rs2, offset(rs1)</td><td rowspan="3">S</td><td rowspan="3">0x23</td><td>0x0</td><td></td><td>Mem(R[rs1] + offset) ← R[rs2][7:0]</td></tr><tr><td>sh rs2, offset(rs1)</td><td>0x1</td><td></td><td>Mem(R[rs1] + offset) ← R[rs2][15:0]</td></tr><tr><td>sw rs2, offset(rs1)</td><td>0x2</td><td></td><td>Mem(R[rs1] + offset) ← R[rs2]</td></tr><tr><td>beq rs1, rs2, offset</td><td rowspan="6">SB</td><td rowspan="6">0x63</td><td>0x0</td><td></td><td>if(R[rs1] == R[rs2])<br> PC ← PC + <!-- -->{<!-- -->offset, 1b0<!-- -->}</td></tr><tr><td>bne rs1, rs2, offset</td><td>0x1</td><td></td><td>if(R[rs1] != R[rs2])<br> PC ← PC + <!-- -->{<!-- -->offset, 1b0<!-- -->}</td></tr><tr><td>blt rs1, rs2, offset</td><td>0x4</td><td></td><td>if(R[rs1] &lt; R[rs2] (signed))<br> PC ← PC + <!-- -->{<!-- -->offset, 1b0<!-- -->}</td></tr><tr><td>bge rs1, rs2, offset</td><td>0x5</td><td></td><td>if(R[rs1] &gt;= R[rs2] (signed))<br> PC ← PC + <!-- -->{<!-- -->offset, 1b0<!-- -->}</td></tr><tr><td>bltu rs1, rs2, offset</td><td>0x6</td><td></td><td>if(R[rs1] &lt; R[rs2] (unsigned))<br> PC ← PC + <!-- -->{<!-- -->offset, 1b0<!-- -->}</td></tr><tr><td>bgeu rs1, rs2, offset</td><td>0x7</td><td></td><td>if(R[rs1] &gt;= R[rs2] (unsigned))<br> PC ← PC + <!-- -->{<!-- -->offset, 1b0<!-- -->}</td></tr><tr><td>auipc rd, offset</td><td rowspan="2">U</td><td>0x17</td><td></td><td></td><td>R[rd] ← PC + <!-- -->{<!-- -->offset, 12b0<!-- -->}</td></tr><tr><td>lui rd, offset</td><td>0x37</td><td></td><td></td><td>R[rd] ← <!-- -->{<!-- -->offset, 12b0<!-- -->}</td></tr><tr><td>jal rd, imm</td><td>UJ</td><td>0x6f</td><td></td><td></td><td>R[rd] ← PC + 4<br> PC ← PC + <!-- -->{<!-- -->imm, 1b0<!-- -->}</td></tr><tr><td>jalr rd, rs1, imm</td><td>I</td><td>0x67</td><td>0x0</td><td></td><td>R[rd] ← PC + 4<br> PC ← R[rs1] + <!-- -->{<!-- -->imm<!-- -->}</td></tr><tr><td>csrw rd, csr, rs1</td><td>I</td><td>0x73</td><td>0x1</td><td></td><td>CSR[csr] ← R[rs1]</td></tr><tr><td>csrwi rd, csr, uimm</td><td>I</td><td>0x73</td><td>0x5</td><td></td><td>CSR[csr] ← <!-- -->{<!-- -->uimm<!-- -->}</td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_LWe7" id="info-memory-1">Info: Memory<a href="#info-memory-1" class="hash-link" aria-label="Direct link to Info: Memory" title="Direct link to Info: Memory">​</a></h3><p>The Memory unit (located in <code>mem.circ</code>) is already fully implemented for you and attached to the outputs of your CPU in <code>test_harness.circ</code>! You <strong>must not</strong> add <code>mem.circ</code> into your CPU, doing so will cause the autograder to fail and you will not receive a score.</p><p>Note that the address you give to memory is a byte address, but memory returns an entire word of memory. The memory unit ignores the bottom two bits of the address you provide to it, and treats its input as a <strong>word address</strong> rather than a <strong>byte address</strong>. For example, if you input the 32-bit address 0x0000<!-- -->_<!-- -->1007, it wil be treated as the word address 0x0000<!-- -->_<!-- -->1004, and you will get as output the 4 bytes at addresses 0x0000<!-- -->_<!-- -->1004, 0x0000<!-- -->_<!-- -->1005, 0x0000<!-- -->_<!-- -->1006, and 0x0000<!-- -->_<!-- -->1007.</p><p>Note that for the <code>lw</code>, <code>lh</code>, <code>sh</code>, <code>sw</code> instructions, the RISC-V ISA supports unaligned accesses, but implementing them is complicated. We’ll only be implementing <em>aligned</em> memory accesses in this project. This means that operations will only be defined when they do not exceed the boundaries of a contiguous word in memory. An example of such an operation is any <code>lw</code> or <code>sw</code> that operates on an address that is a multiple of 4. Since the address is a multiple of 4 and we load 4 bytes in a word, the total memory fetched does not exceed the boundaries of a contiguous word in memory. You <strong>must not</strong> implement unaligned accesses; you would likely need to use stalling, which would result in your output not matching our expected output (bad for your score).</p><p>Remember that the memory is also <strong>byte</strong> level write enabled. This means that the Write<!-- -->_<!-- -->En signal is 4 bits wide and acts as a write mask for the input data. For example, if Write<!-- -->_<!-- -->En is <code>1&#x27;b1000</code>, only the most significant byte of the addressed word in memory will be overwritten. The ReadData port will always return the value in memory at the supplied address, regardless of Write<!-- -->_<!-- -->En.</p><p>Again, here’s a quick summary of its inputs and outputs:</p><table><thead><tr><th>Signal Name</th><th>Direction</th><th>Bit Width</th><th>Description</th></tr></thead><tbody><tr><td>WriteAddr</td><td>Input</td><td>32</td><td>Address to read/write to in Memory</td></tr><tr><td>WriteData</td><td>Input</td><td>32</td><td>Value to be written to Memory</td></tr><tr><td>Write<!-- -->_<!-- -->En</td><td>Input</td><td>4</td><td>The write mask for instructions that write to Memory and zero otherwise</td></tr><tr><td>CLK</td><td>Input</td><td>1</td><td>Driven by the clock input to the CPU</td></tr><tr><td>ReadData</td><td>Output</td><td>32</td><td>Value of the data stored at the specified address</td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_LWe7" id="info-branch-comparator-1">Info: Branch Comparator<a href="#info-branch-comparator-1" class="hash-link" aria-label="Direct link to Info: Branch Comparator" title="Direct link to Info: Branch Comparator">​</a></h3><p>The Branch Comparator unit (located in <code>branch_comp.circ</code>) compares two values and outputs control signals that will be used to make branching decisions. You will need to implement logic for this circuit.</p><p>To edit this subcircuit, edit the <code>branch_comp.circ</code> file and not the <code>branch_comp</code> in <code>cpu.circ</code>. Note that if you modify this circuit, you will need to close and open <code>cpu.circ</code> to load the changes in your CPU.</p><p>Again, here’s a quick summary of its inputs and outputs:</p><table><thead><tr><th>Signal Name</th><th>Direction</th><th>Bit Width</th><th>Description</th></tr></thead><tbody><tr><td>rs1</td><td>Input</td><td>32</td><td>Value in the first register to be compared</td></tr><tr><td>rs2</td><td>Input</td><td>32</td><td>Value in the second register to be compared</td></tr><tr><td>BrUn</td><td>Input</td><td>1</td><td>Equal to one when an unsigned comparison is wanted, or zero when a signed comparison is wanted</td></tr><tr><td>BrEq</td><td>Output</td><td>1</td><td>Equal to one if the two values are equal</td></tr><tr><td>BrLt</td><td>Output</td><td>1</td><td>Equal to one if the value in rs1 is less than the value in rs2</td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_LWe7" id="info-immediate-generator-1">Info: Immediate Generator<a href="#info-immediate-generator-1" class="hash-link" aria-label="Direct link to Info: Immediate Generator" title="Direct link to Info: Immediate Generator">​</a></h3><p>The Immediate Generator (“Imm Gen”) unit (located in <code>imm_gen.circ</code>) extracts the appropriate immediate from <code>I</code>, <code>S</code>, <code>B</code>, <code>U</code>, and <code>J</code> type instructions. Remember that in RISC-V, all immediates that leave the immediate generator are 32-bits and sign-extended! See the table below for how each immediate should be formatted:</p><p><img loading="lazy" alt="alt-text" src="/assets/images/immediates-b3a4600a503bc68d57e999e48d2c8309.png" class="img_ev3q"></p><p>To edit this subcircuit, edit the <code>imm_gen.circ</code> file and not the <code>imm_gen</code> in <code>cpu.circ</code>. Note that if you modify this circuit, you will need to close and open <code>cpu.circ</code> to load the changes in your CPU.</p><p>Again, here’s a quick summary of its inputs and outputs:</p><table><thead><tr><th>Signal Name</th><th>Direction</th><th>Bit Width</th><th>Description</th></tr></thead><tbody><tr><td>inst</td><td>Input</td><td>32</td><td>The instruction being executed</td></tr><tr><td>ImmSel</td><td>Input</td><td>3</td><td>Value determining how to reconstruct the immediate</td></tr><tr><td>imm</td><td>Output</td><td>32</td><td>Value of the immediate in the instruction</td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_LWe7" id="info-control-logic-1">Info: Control Logic<a href="#info-control-logic-1" class="hash-link" aria-label="Direct link to Info: Control Logic" title="Direct link to Info: Control Logic">​</a></h3><p>The Control Logic unit (<code>control_logic.circ</code>) provided in the skeleton is based on the control logic unit in the 5-stage CPU used in lecture and discussion. In order to correctly identify each instruction, control signals play a very important part in this project. However, figuring out all of the control signals may seem intimidating. We suggest taking a look at the lecture slides and discussion worksheets to get started. Try walking through the datapath with different types of instructions; when you see a MUX or other component, think about what selector/enable value you will need for that instruction.</p><p>You are welcome to add more inputs or outputs to the existing starter circuit as your control logic demands. You may also use as many or as few of the supplied ports as needed. That being said, please do not change or remove any of the existing ports during this process.</p><p>There are a two major approaches to implementing the control logic so that it can extract the <code>opcode</code>/<code>funct3</code>/<code>funct7</code> from an instruction and set the control signals appropriately.</p><p>The recommended method is <strong>hard-wired control</strong>, as discussed in lecture, which is usually the preferred approach for RISC architectures like MIPS and RISC-V. Hard-wired control uses “AND”, “OR”, and “NOT” gates (along with the various components we’ve learned can be built from these gates, like MUXes and DEMUXes) to produce the appropriate control signals. An <strong>instruction decoder</strong> takes in an instruction and outputs all of the control signals for that instruction.</p><p>The other way to do it is to use <strong>ROM control</strong>. Every instruction implemented by a processor maps to an address in a Read-Only Memory (ROM) unit. At that address in the ROM is the control word for that instruction. An <strong>address decoder</strong> takes in an instruction and outputs the address of the control word for that instruction. This approach is common in CISC architectures like Intel’s x86-64, and, in real life, offers some flexibility because it can be re-programmed by changing the contents of the ROM.</p><p>To edit this subcircuit, edit the <code>control_logic.circ</code> file and not the <code>control_logic</code> in <code>cpu.circ</code>. Note that if you modify this circuit, you will need to close and open <code>cpu.circ</code> to load the changes in your CPU.</p><hr><h3 class="anchor anchorWithStickyNavbar_LWe7" id="info-control-status-register-csr">Info: Control Status Register (CSR)<a href="#info-control-status-register-csr" class="hash-link" aria-label="Direct link to Info: Control Status Register (CSR)" title="Direct link to Info: Control Status Register (CSR)">​</a></h3><p>In order to run the testbenches that determine your project grades as well as the winners for the <strong>Design Contest</strong>, there are a few more instructions that need to be added. A Control Status Register (CSR) holds additional information about the results of machine instructions, and it usually is stored independently of the register file and the memory. In your processor, you will be writing outputs to one of the CSRs that will be monitored by more complex testbenches. <strong>Note that Venus does not support CSRs, so you will not be able to generate custom tests for these instructions. We will provide a robust sanity check for your CSR in the Part B autograder that will test all functionality of CSR needed.</strong></p><p>Below are the <strong>2 CSR instructions</strong> that you will need to implement. Note that while there are 212 possible CSR addresses, we will only use one of them (<code>tohost = 0x51E</code>). Note that the immediate forms use a 5-bit zero-extended immediate (uimm) encoded in the <code>rs1</code> field.</p><ol><li><code>csrw tohost, t2</code> (short for <code>csrrw x0,csr,rs1</code> where <code>csr=0x51E</code>)</li><li><code>csrwi tohost, 1</code> (short for <code>csrrwi x0,csr,uimm</code> where <code>csr=0x51E</code>)</li></ol><p><img loading="lazy" alt="alt-text" src="/assets/images/csr-9ed7d4308cdacc599fe8b4e890b87557.png" class="img_ev3q"></p><p>The Control Status Register unit skeleton (<code>csr.circ</code>) is provided with the starter code. In this unit, you will need to implement the <code>tohost</code> CSR register along with the write logic. <strong>Please do not change the given connections as it will interfere with the testbench results!</strong></p><p>If you want to learn more about CSR, you can refer to Chapter 9 of the <a href="https://web.archive.org/web/20220121165045/https://github.com/riscv/riscv-isa-manual/releases/tag/draft-20201002-db3eeaf" target="_blank" rel="noopener noreferrer">RISC-V specification</a>.</p><p>Here’s a quick summary of its inputs and outputs:</p><table><thead><tr><th>Signal Name</th><th>Direction</th><th>Bit Width</th><th>Description</th></tr></thead><tbody><tr><td>CSR<!-- -->_<!-- -->address</td><td>Input</td><td>12</td><td>Input CSR register address</td></tr><tr><td>CSR<!-- -->_<!-- -->din</td><td>Input</td><td>32</td><td>Value to write into specified CSR register</td></tr><tr><td>CSR<!-- -->_<!-- -->WE</td><td>Input</td><td>1</td><td>Write enable</td></tr><tr><td>clk</td><td>Input</td><td>1</td><td>Clock input</td></tr><tr><td>tohost</td><td>Output</td><td>32</td><td>Output of the <code>tohost</code> register</td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_LWe7" id="info-processor-1">Info: Processor<a href="#info-processor-1" class="hash-link" aria-label="Direct link to Info: Processor" title="Direct link to Info: Processor">​</a></h3><p>The main CPU circuit (located in <code>cpu.circ</code>) implements the main datapath and connects all the subcircuits (ALU, Branch Comparator, Control Logic, Immediate Generator, Memory, and RegFile) together. In Part A, you implemented a simple two-stage pipeline in your CPU. Since Part B requires support for branch and jump instructions, you’ll need to handle control hazards that occur when branching.</p><p>The instruction immediately after a branch or jump is not executed if a branch is taken. This makes your task a bit more complex. By the time you have figured out that a branch or jump is in the execute stage, you have already accessed the instruction memory and pulled out (possibly) the wrong instruction. You will therefore need to “kill” instruction that is being fetched if the instruction under execution is a jump or a taken branch.</p><p>Instruction kills for this project MUST be accomplished by MUXing a <code>nop</code> into the instruction stream and sending the <code>nop</code> into the Execute stage instead of using the fetched instruction. Notice that 0x00000013, or <code>addi x0, x0, 0</code> is a <code>nop</code> instruction; other <code>nop</code> instructions will work too. You should kill if a branch is taken (do not kill otherwise). Do kill on every type of jump.</p><p>Do not solve this issue by calculating branch offsets in the IF stage. If we test your output against the reference every cycle, and the reference returns a <code>nop</code>, while it may be a conceptually correct solution, this will cause you to fail our tests.</p><p>Because all of the control and execution is handled in the Execute stage, <strong>your processor should be more or less indistinguishable from a single-cycle implementation, barring the one-cycle startup latency and the branch/jump delays.</strong> However, we will be enforcing the two-stage pipeline design. Some things to consider:</p><ul><li>Will the IF and EX stages have the same or different <code>PC</code> values?</li><li>Do you need to store the <code>PC</code> between the pipelining stages?</li><li>To MUX a <code>nop</code> into the instruction stream, do you place it <em>before</em> or <em>after</em> the instruction register?</li><li>What address should be requested next while the EX stage executes a <code>nop</code>? Is this different than normal?</li></ul><p>You might also notice a bootstrapping problem here: during the first cycle, the instruction register sitting between the pipeline stages won’t contain an instruction loaded from memory. How do we deal with this? It happens that Logisim automatically sets registers to zero on reset; the instruction register will then contain a <code>nop</code>. We will allow you to depend on this behavior of Logisim. Remember to go to Simulate <code>--&gt;</code> Reset Simulation (Ctrl+R) to reset your processor.</p><hr><h3 class="anchor anchorWithStickyNavbar_LWe7" id="cpu-testing-pipelined-sanity-tests">CPU Testing: Pipelined Sanity Tests<a href="#cpu-testing-pipelined-sanity-tests" class="hash-link" aria-label="Direct link to CPU Testing: Pipelined Sanity Tests" title="Direct link to CPU Testing: Pipelined Sanity Tests">​</a></h3><p>We’ve provided a group of basic sanity tests for your pipelined CPU in <code>tests/part_b/pipelined</code>.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ python3 test_runner.py part_b pipelined</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>You can see the <code>.s</code> (RISC-V) and <code>.hex</code> (machine code) files for the test in <code>tests/part_b/pipelined/inputs</code>.</p><p>We’ve also provided <code>binary_to_hex_cpu.py</code>, which works like <code>binary_to_hex_cpu.py</code> from Task 3.</p><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="task-5-custom-tests">Task 5: Custom Tests<a href="#task-5-custom-tests" class="hash-link" aria-label="Direct link to Task 5: Custom Tests" title="Direct link to Task 5: Custom Tests">​</a></h2><p>The autograder tests fall into 3 main categories: <strong>unit tests</strong>, <strong>integration tests</strong>, and <strong>edge case tests</strong>. For Part B, we won’t be revealing all the autograder tests, but you should be able to re-create a very close approximation of them on your own in order to test your CPU.</p><p><strong>Unit tests</strong>: a unit test exercises your datapath with a single instruction, to make sure that each individual instruction has been implemented and is working as expected. You should write a different unit test for every single instruction that you need to implement, and make sure that you test the spectrum of possibilities for that instruction thoroughly. For example, a unit test <code>slt</code> should contain cases where <code>rs1 &lt; rs2</code>, <code>rs1 &gt; rs2</code>, and where <code>rs1 == rs2</code>.</p><p><strong>Integration tests</strong>: After you’ve passed your unit tests, move onto tests that use multiple functions in combination. Try out various simple RISC-V programs that run a single function; your CPU should be able to handle them, if working properly. Feel free to try to use riscv-gcc to compile C programs to RISC-V, but be aware of the limited instruction set we’re working with (you don’t have any <code>ecall</code> instructions, for example). We’d recommend that you instead try to write simple functions on your own based on what you’ve seen in labs, discussions, projects, and exams.</p><p><strong>Edge case tests</strong>: edge case tests try inputs that you normally wouldn’t expect, which may trigger bugs in certain situations. What edge cases should you look for? A small hint from us: our 2 main classes of edge cases come from memory operations and branch/jump operations (some of the test names are “mem-full” and “br-jump-edge”). Think about all the different ways these operations could go wrong.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="creating-custom-tests">Creating Custom Tests<a href="#creating-custom-tests" class="hash-link" aria-label="Direct link to Creating Custom Tests" title="Direct link to Creating Custom Tests">​</a></h3><p>We’ve included a script (<code>create-test.py</code>) that uses Venus to help you generate test circuits from RISC-V assembly! As a reminder you can find a debugging walkthrough at <a href="https://web.archive.org/web/20220121165045/https://inst.eecs.berkeley.edu/~cs61c/fa20/lectures/videos?ytvid=qFIPWt9Pu7I" target="_blank" rel="noopener noreferrer">this video</a>. The process for generating a custom test is as follows:</p><ol><li><p>Come up the RISC-V assembly instructions for the test, and save them in a file ending in <code>.s</code> in the <code>tests/part_b/custom/inputs</code> folder. The name of this file will be the name of your test. Note that your test <strong>must</strong> end in <code>.s</code>, and it <strong>must</strong> be located in the <code>tests/part_b/custom/inputs</code> folder. Repeat if you have more tests.</p><ul><li>e.g. <code>tests/part_b/custom/inputs/sll-slli.s</code>, <code>tests/part_b/custom/inputs/slt.s</code></li></ul></li><li><p>Repeat step 1 if you have more tests.</p></li><li><p>To generate test circuits for your tests, run the <code>create-test.py</code> script:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ cd tests/part_b/custom</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ python3 create-test.py inputs/sll-slli.s inputs/slt.s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This should generate a couple new files:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">tests/part_b/custom:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  - &lt;TEST_NAME&gt;.circ # The new circuit for your test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  - inputs/&lt;TEST_NAME&gt;.s # The test file you wrote</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  - inputs/&lt;TEST_NAME&gt;.hex # The machine code of the test file you wrote</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  - reference_outputs/&lt;TEST_NAME&gt;-ref.out # The reference output for your test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li><p>Now you can run your tests!</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ python3 test_runner.py part_b custom</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li></ol><p>If you want to inspect the circuit running your test, you can simulate it by opening up the <code>CPU-&lt;test name here&gt;.circ</code> file, right-clicking on the CPU, selecting ‘view main’, and using Cmd + T (Ctrl + T on Windows) to manually tick the clock through each cycle. If you don’t remember how to simulate your circuit, please refer back to the Logisim lab. We highly encourage you to poke your circuit while simulating the test to observe how your circuit reacts to various inputs (perhaps this can give you ideas for new tests to write).</p><p>If you wish to simulate your code only for a certain number of cycles, you can do that by using the <code>-n</code> flag:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ python3 create_test.py -n &lt;NUMBER_OF_CYCLES&gt; &lt;TEST_NAME&gt;.s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>If you would like to decode your output, use the provided <code>binary_to_hex_cpu.py</code>. Note that because you’re implementing a 2-stage pipelined processor and the first instruction writes on the rising edge of the second clock cycle, the effects of your instructions will have a 2 instruction delay. For example, let’s say you wrote a test with one instruction: <code>addi t0, x0, 1</code>. If you inspect the reference output, you’ll see that <code>t0</code> isn’t changed until the third cycle.</p><hr><h3 class="anchor anchorWithStickyNavbar_LWe7" id="test-coverage">Test Coverage<a href="#test-coverage" class="hash-link" aria-label="Direct link to Test Coverage" title="Direct link to Test Coverage">​</a></h3><p><strong>Test coverage</strong>: a metric measuring how much of a given codebase is being tested by tests. For the purposes of this project, you will be graded on how much of the required ISA your tests cover.</p><p>The autograder for Part B will examine the coverage of tests located in the <code>tests/part_b/custom/inputs</code> folder. When you submit Part B to the autograder, the autograder will output a message about the percentage coverage of your tests against our staff suite of tests and notify you if any of your tests raised a syntax error.</p><p>Hints:</p><ul><li>If you make many short test files rather than one large one, it will be easier to figure out which test and which line causes your Syntax Error (and to figure out where your CPU is failing). We’d recommend that for unit testing, where you have one .s file testing each instruction.</li><li>Make sure you test every single instruction in the ISA, including the ones that are covered by the sanity tests; feel free to use the sanity tests as a model or even incorporate them as part of your test suite.</li><li>Make sure you check that all registers are working.</li><li>Make sure you don’t have any “dummy” tests; if a test doesn’t lead to a change in state or register value, it is not a meaningful test.</li><li>Make sure that you accumulate outputs into the special registers we output to the testharness, other registers will not be checked against. These registers are: <code>x0</code>, <code>ra</code>, <code>sp</code>, <code>t0</code>, <code>t1</code>, <code>t2</code>, <code>s0</code>, <code>s1</code>, and <code>a0</code>.</li></ul><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="part-b-submission">Part B: Submission<a href="#part-b-submission" class="hash-link" aria-label="Direct link to Part B: Submission" title="Direct link to Part B: Submission">​</a></h2><p>At this point, if you’ve completed tasks 4-5, you’ve finished Part B of the project. Congratulations on your shiny new CPU!</p><p><strong>Your last bit of work before you submit is to write down how you implemented your CPU inside the readme.md. There is already a template for you to use and don’t worry about going into too much detail, we just want you to reflect on what you did in this project and explain the reasoning behind the design choices you made (especially in your control logic)! You must also document the breakdown of labor between you and your partner! Tell us who did what in both implementation and design.</strong></p><p>Double-check that you have not moved your input/output pins, and that your circuits fit in the provided testing harnesses. Make sure that you did not create any additional <code>.circ</code> files; the autograder will only be testing the circuit files you needed to edit in the starter code (<code>branch_comp.circ</code>, <code>control_logic.circ</code>, <code>cpu.circ</code>, <code>imm_gen.circ</code>). Also make sure your custom <code>.s</code> tests are located in the right folder.</p><p>The autograder for Part B uses the sanity tests provided in the starter code, as well as hidden unit, integration, and edge case tests as specified in Task 5. Additionally, the autograder will be checking your custom tests for test coverage.</p><p>Note: If you fail on any of the provided autograder sanity tests, course staff will <strong>not</strong> help you debug your CPU <strong>unless</strong> you have recreated a similar test that also fails.</p><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="frequently-asked-questions">Frequently Asked Questions<a href="#frequently-asked-questions" class="hash-link" aria-label="Direct link to Frequently Asked Questions" title="Direct link to Frequently Asked Questions">​</a></h2><ul><li><strong>Q</strong>: I have pipelined my CPU, but the autograder said it detected a single-cycle one, what is the problem?<br><strong>A</strong>: If you’re certain that you correctly pipelined, then it means that Logisim crashed when attempting to open your circuit. Generally this is caused by import issues, meaning you used a circuit that isn’t in the correct place. Remember that you shouldn’t be creating any new circ files and your ALU and RegFile files will be replaced with the staff solution, so don’t use any subcircuits you created in those files in your CPU.</li><li><strong>Q</strong>: I want to add more inputs and outputs to one of my circuits. Is this allowed?<br><strong>A</strong>: This is allowed, however beware of messing up your circuit appearance. This can cause pins to move to the wrong place and make you fail all the sanity tests. You can check you circuit appearance by right-clicking on your circuit and selecting “Edit Circuit Appearance” to move the new pins around if necessary, though this is not recommended. <strong>WARNING: If you fail autograder tests because of added inputs/outputs we will not allow you to fix and resubmit after the deadline.</strong> If you want to add extra logic or controls to your CPU we recommend making a control subcircuit in cpu.circ.</li><li><strong>Q</strong>: Are we allowed to use all the Logisim main library blocks? Where can I find information on them?<br><strong>A</strong>: You are only allowed to use the following libraries: Wiring (<strong>except Transistor, Transmission Gate, POR, Pull Resistor, Power, Ground, POR, Do not connect</strong>), Gates, Plexers, Arithmetic (<strong>except Divider</strong>), Memory (<strong>except RAM, Random Generator</strong>) Note that the use of <strong>ROM</strong> is allowed. Help can be found in the Logisim menus</li><li><strong>Q</strong>: I failed a sanity check in the autograder, can I get help figuring out what’s wrong?<br><strong>A</strong> Course staff will be unable to help debug issues directly from the autograder. Instead, we encourage you to use the custom test generator to generate new test that replicates the operation described in the sanity test description and then bringing failed results from that test to OH.</li><li><strong>Q</strong>: My autograder failed to run, how do I fix this?<br><strong>A</strong> Please check that you have followed all the rules with regards to allowed blocks and circuit naming. Also please check that you do not have any splitters where an output of the splitter is mapped to by 0 pins (in this case you should be using a smaller splitter anyway). If you have made all these checks and fixes and are still having problems, please post on Piazza.</li></ul><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="grading">Grading<a href="#grading" class="hash-link" aria-label="Direct link to Grading" title="Direct link to Grading">​</a></h2><p>The grading breakdown for Project 3 is as follows:</p><ul><li>Part A (20%)<ul><li>ALU (8%)</li><li>RegFile (8%)</li><li>Pipelined <code>addi</code> (4%)</li></ul></li><li>Part B (80%)<ul><li>Sanity and Visible (Basic) Unit Tests (20%)</li><li>Test Coverage (10%)</li><li>Hidden Unit, Integration, and Edge Case Tests (50%)</li></ul></li></ul><p>For Part B we have provided a visible set of <strong>basic</strong> unit tests in the autograder. These tests are meant to help reduce your stress by providing some guidance in the early stages of testing. You should still rigorously test your designs, <strong>passing the visible tests does not guarantee that you will pass any of the hidden tests.</strong></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="design-contest">Design Contest<a href="#design-contest" class="hash-link" aria-label="Direct link to Design Contest" title="Direct link to Design Contest">​</a></h2><p>This year, thanks to support from an industry partner, Project 3 will be part of a course wide design contest! The method in which your Project 3 submission will be scored is based on the gate equivalence and longest path of your submitted circuit. In both contests, a lower score is better.</p><p><strong>Note that while all submitted designs will show a score, only designs that pass 100% of visible and hidden tests will be eligible for the contest.</strong> This means that it is in your best interest to test throughly!</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="gate-equivalence">Gate equivalence<a href="#gate-equivalence" class="hash-link" aria-label="Direct link to Gate equivalence" title="Direct link to Gate equivalence">​</a></h3><p>The first contest score you will receive is for gate equivalence. To calculate this, we will take your submitted circuit, and convert it to the number of NAND2 gates, NOT gates, and flip-flops required to implement your design. You will then be assigned a score based on the formula: <strong>score = 2 <!-- -->*<!-- --> (# of NOTs) + 2 <!-- -->*<!-- --> (# of NAND2s) + 8 <!-- -->*<!-- --> (# of FFs)</strong>. This score is a proxy for the power consumption and area utilization of your design. The weights in our formula are derived from the number of transistors needed to replicate each type of gate or flip-flop.</p><p>A table of some common logic elements and their corresponding gate equivalents are shown below. You can assume that the gate equivalents scale roughly linearly with the total input bitwidth (i.e. a 2-input 32-bit adder has roughly 32 times the number of gates of a 2-input 1-bit adder). An exception to this rule is the multiplier, which scales roughly linearly with the <strong>square</strong> of the total input bitwidth.</p><table><thead><tr><th>Gate Name</th><th>Number of NAND2 Gates</th><th>Number of NOT Gates</th><th>Number of FFs</th></tr></thead><tbody><tr><td>2-input AND</td><td>1</td><td>1</td><td>0</td></tr><tr><td>2-input OR</td><td>1</td><td>2</td><td>0</td></tr><tr><td>2-input NOR</td><td>1</td><td>3</td><td>0</td></tr><tr><td>32-bit ADDER</td><td>366</td><td>195</td><td>0</td></tr><tr><td>32-bit SUBTRACTOR</td><td>456</td><td>255</td><td>0</td></tr><tr><td>32-bit COMPARATOR</td><td>222</td><td>127</td><td>0</td></tr><tr><td>32-bit MULTIPLIER</td><td>10849</td><td>4467</td><td>0</td></tr><tr><td>32-bit NEGATOR</td><td>145</td><td>84</td><td>0</td></tr><tr><td>32-bit SHIFTER</td><td>418</td><td>36</td><td>0</td></tr><tr><td>2-input 32-bit MUX</td><td>128</td><td>33</td><td>0</td></tr><tr><td>ROM (per non-zero entry)</td><td>5.8 (average)</td><td>4.6 (average)</td><td>0</td></tr><tr><td>32-bit Register FF</td><td>97</td><td>1</td><td>32</td></tr></tbody></table><h3 class="anchor anchorWithStickyNavbar_LWe7" id="longest-path">Longest Path<a href="#longest-path" class="hash-link" aria-label="Direct link to Longest Path" title="Direct link to Longest Path">​</a></h3><p>The second contests score you will receive is for the longest path in your design. We will follow a similar process to gate equivalent but instead calculate the longest path between any two flop-flops in your design. This score is a proxy for the fastest clock frequency at which your design could run.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="tips">Tips<a href="#tips" class="hash-link" aria-label="Direct link to Tips" title="Direct link to Tips">​</a></h3><ul><li>Simplify when possible! For example, a shifter that shifts by a fixed amount can be replicated using a splitter, which costs 0 gates!</li><li>A majority of your savings will come from optimizing your control logic.</li><li>Reduce, reuse, recycle! Use the output of a computation as many times as possible rather than performing the computation each time the value is needed.</li><li>Break apart independent computations into their own paths. If you place all your logic between two flip-flops in a single path, this is very inefficient in terms of your longest path.</li></ul></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/curriculum-resource/cs61c/projects/proj2"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Project2</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/curriculum-resource/cs61c/projects/proj4"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Project4</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#overview" class="table-of-contents__link toc-highlight">Overview</a></li><li><a href="#tips-and-guidelines" class="table-of-contents__link toc-highlight">Tips and Guidelines</a></li><li><a href="#alt-text" class="table-of-contents__link toc-highlight">alt-text</a></li><li><a href="#part-a-getting-started" class="table-of-contents__link toc-highlight">Part A: Getting Started</a></li><li><a href="#task-1-arithmetic-logic-unit-alu" class="table-of-contents__link toc-highlight">Task 1: Arithmetic Logic Unit (ALU)</a><ul><li><a href="#alu-testing" class="table-of-contents__link toc-highlight">ALU Testing</a></li></ul></li><li><a href="#task-2-register-file-regfile" class="table-of-contents__link toc-highlight">Task 2: Register File (RegFile)</a><ul><li><a href="#regfile-testing" class="table-of-contents__link toc-highlight">RegFile Testing</a></li></ul></li><li><a href="#task-3-the-addi-instruction" class="table-of-contents__link toc-highlight">Task 3: The <code>addi</code> Instruction</a><ul><li><a href="#info-memory" class="table-of-contents__link toc-highlight">Info: Memory</a></li><li><a href="#info-branch-comparator" class="table-of-contents__link toc-highlight">Info: Branch Comparator</a></li><li><a href="#info-immediate-generator" class="table-of-contents__link toc-highlight">Info: Immediate Generator</a></li><li><a href="#info-processor" class="table-of-contents__link toc-highlight">Info: Processor</a></li><li><a href="#info-control-logic" class="table-of-contents__link toc-highlight">Info: Control Logic</a></li><li><a href="#single-stage-cpu-a-guide" class="table-of-contents__link toc-highlight">Single Stage CPU: A Guide</a></li><li><a href="#pipelining-your-cpu" class="table-of-contents__link toc-highlight">Pipelining Your CPU</a></li><li><a href="#testing" class="table-of-contents__link toc-highlight">Testing</a></li></ul></li><li><a href="#part-a-submission" class="table-of-contents__link toc-highlight">Part A: Submission</a></li><li><a href="#part-b" class="table-of-contents__link toc-highlight">Part B</a></li><li><a href="#task-4-more-instructions" class="table-of-contents__link toc-highlight">Task 4: More Instructions</a><ul><li><a href="#the-instruction-set-architecture-isa" class="table-of-contents__link toc-highlight">The Instruction Set Architecture (ISA)</a></li><li><a href="#info-memory-1" class="table-of-contents__link toc-highlight">Info: Memory</a></li><li><a href="#info-branch-comparator-1" class="table-of-contents__link toc-highlight">Info: Branch Comparator</a></li><li><a href="#info-immediate-generator-1" class="table-of-contents__link toc-highlight">Info: Immediate Generator</a></li><li><a href="#info-control-logic-1" class="table-of-contents__link toc-highlight">Info: Control Logic</a></li><li><a href="#info-control-status-register-csr" class="table-of-contents__link toc-highlight">Info: Control Status Register (CSR)</a></li><li><a href="#info-processor-1" class="table-of-contents__link toc-highlight">Info: Processor</a></li><li><a href="#cpu-testing-pipelined-sanity-tests" class="table-of-contents__link toc-highlight">CPU Testing: Pipelined Sanity Tests</a></li></ul></li><li><a href="#task-5-custom-tests" class="table-of-contents__link toc-highlight">Task 5: Custom Tests</a><ul><li><a href="#creating-custom-tests" class="table-of-contents__link toc-highlight">Creating Custom Tests</a></li><li><a href="#test-coverage" class="table-of-contents__link toc-highlight">Test Coverage</a></li></ul></li><li><a href="#part-b-submission" class="table-of-contents__link toc-highlight">Part B: Submission</a></li><li><a href="#frequently-asked-questions" class="table-of-contents__link toc-highlight">Frequently Asked Questions</a></li><li><a href="#grading" class="table-of-contents__link toc-highlight">Grading</a></li><li><a href="#design-contest" class="table-of-contents__link toc-highlight">Design Contest</a><ul><li><a href="#gate-equivalence" class="table-of-contents__link toc-highlight">Gate equivalence</a></li><li><a href="#longest-path" class="table-of-contents__link toc-highlight">Longest Path</a></li><li><a href="#tips" class="table-of-contents__link toc-highlight">Tips</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">CS学习社区</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">路线图</a></li></ul></div><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.b896b442.js"></script>
<script src="/assets/js/main.cf349332.js"></script>
</body>
</html>