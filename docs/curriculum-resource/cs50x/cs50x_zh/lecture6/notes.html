<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-curriculum-resource/cs50x/cs50x_zh/lecture6/notes" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">课程笔记 | CS自学社区</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://www.learncs.site/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://www.learncs.site/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://www.learncs.site/docs/curriculum-resource/cs50x/cs50x_zh/lecture6/notes"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="baidu-site-verification" content="codeva-hJyfN2UKgo"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="课程笔记 | CS自学社区"><meta data-rh="true" name="description" content="lecture5 Data Structures Notes | 课程笔记"><meta data-rh="true" property="og:description" content="lecture5 Data Structures Notes | 课程笔记"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://www.learncs.site/docs/curriculum-resource/cs50x/cs50x_zh/lecture6/notes"><link data-rh="true" rel="alternate" href="https://www.learncs.site/docs/curriculum-resource/cs50x/cs50x_zh/lecture6/notes" hreflang="en"><link data-rh="true" rel="alternate" href="https://www.learncs.site/docs/curriculum-resource/cs50x/cs50x_zh/lecture6/notes" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="CS自学社区 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="CS自学社区 Atom Feed">




<link rel="stylesheet" href="/katex/katex.min.css"><link rel="stylesheet" href="/assets/css/styles.c4382977.css">
<link rel="preload" href="/assets/js/runtime~main.778e0441.js" as="script">
<link rel="preload" href="/assets/js/main.3597ac80.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><div class="announcementBar_mb4j" style="background-color:#fafbfc;color:#091E42" role="banner"><div class="content_knG7 announcementBarContent_xLdY">🎉️🎉️🎉️课程文档汉化工作正在进行中 🎉️🎉️ 学习交流群请到 <a href="/community">社区页面</a> 查看入群方式 🎉️🎉️🎉️</div></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="TeachYourselfCS" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="TeachYourselfCS" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">TeachYourselfCS</b></a><a class="navbar__item navbar__link" href="/docs/roadmap">路线图</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">课程资源</a><a class="navbar__item navbar__link" href="/blog">博客</a><a class="navbar__item navbar__link" href="/community">社区</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG menuWithAnnouncementBar_GW3s"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">前言</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/roadmap">路线图</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/category/课程资源">课程资源</a><button aria-label="Toggle the collapsible sidebar category &#x27;课程资源&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" tabindex="0" href="/docs/curriculum-resource/cs50x">cs50x</a><button aria-label="Toggle the collapsible sidebar category &#x27;cs50x&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs50x/cs50x_en">cs50x</a><button aria-label="Toggle the collapsible sidebar category &#x27;cs50x&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" tabindex="0" href="/docs/curriculum-resource/cs50x/cs50x_zh">cs50x 中文版</a><button aria-label="Toggle the collapsible sidebar category &#x27;cs50x 中文版&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-4 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs50x/cs50x_zh/lecture1">Lecture0 Scratch</a><button aria-label="Toggle the collapsible sidebar category &#x27;Lecture0 Scratch&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-4 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs50x/cs50x_zh/lecture2">lecture1 C</a><button aria-label="Toggle the collapsible sidebar category &#x27;lecture1 C&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-4 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs50x/cs50x_zh/lecture3">lecture2 Arrays</a><button aria-label="Toggle the collapsible sidebar category &#x27;lecture2 Arrays&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-4 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs50x/cs50x_zh/lecture4">lecture3 Algorithms</a><button aria-label="Toggle the collapsible sidebar category &#x27;lecture3 Algorithms&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-4 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs50x/cs50x_zh/lecture5">lecture4 Memory</a><button aria-label="Toggle the collapsible sidebar category &#x27;lecture4 Memory&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-4 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" tabindex="0" href="/docs/curriculum-resource/cs50x/cs50x_zh/lecture6">lecture5 Data Structures</a><button aria-label="Toggle the collapsible sidebar category &#x27;lecture5 Data Structures&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-5 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/curriculum-resource/cs50x/cs50x_zh/lecture6/notes">课程笔记</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-5 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs50x/cs50x_zh/lecture6/problem set">Problem Set</a><button aria-label="Toggle the collapsible sidebar category &#x27;Problem Set&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-5 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs50x/cs50x_zh/lecture6/practice problems">Practice Problem</a><button aria-label="Toggle the collapsible sidebar category &#x27;Practice Problem&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-5 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/curriculum-resource/cs50x/cs50x_zh/lecture6/lab">实验</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-4 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs50x/cs50x_zh/lecture7">lecture6 python</a><button aria-label="Toggle the collapsible sidebar category &#x27;lecture6 python&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-4 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs50x/cs50x_zh/lecture8">lecture7 SQL</a><button aria-label="Toggle the collapsible sidebar category &#x27;lecture7 SQL&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-4 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs50x/cs50x_zh/lecture9">lecture8 HTML,CSS,JavaScript</a><button aria-label="Toggle the collapsible sidebar category &#x27;lecture8 HTML,CSS,JavaScript&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-4 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs50x/cs50x_zh/lecture10">lecture9 Flask</a><button aria-label="Toggle the collapsible sidebar category &#x27;lecture9 Flask&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-4 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs50x/cs50x_zh/lecture12">lecture11 Cybersecurity</a><button aria-label="Toggle the collapsible sidebar category &#x27;lecture11 Cybersecurity&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-4 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs50x/cs50x_zh/lecture11">lecture10 Emoji</a><button aria-label="Toggle the collapsible sidebar category &#x27;lecture10 Emoji&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs61a">cs61a</a><button aria-label="Toggle the collapsible sidebar category &#x27;cs61a&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs61b">cs61b</a><button aria-label="Toggle the collapsible sidebar category &#x27;cs61b&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs61c">cs61c</a><button aria-label="Toggle the collapsible sidebar category &#x27;cs61c&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/18-01">MIT 18.01</a><button aria-label="Toggle the collapsible sidebar category &#x27;MIT 18.01&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/18-02">MIT 18.02</a><button aria-label="Toggle the collapsible sidebar category &#x27;MIT 18.02&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/18-06">MIT 18.06</a><button aria-label="Toggle the collapsible sidebar category &#x27;MIT 18.06&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/6-04j">MIT 6.042J</a><button aria-label="Toggle the collapsible sidebar category &#x27;MIT 6.042J&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs162">cs162</a><button aria-label="Toggle the collapsible sidebar category &#x27;cs162&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/curriculum-resource/cs144">cs144</a><button aria-label="Toggle the collapsible sidebar category &#x27;cs144&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/课程资源"><span itemprop="name">课程资源</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/curriculum-resource/cs50x"><span itemprop="name">cs50x</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/curriculum-resource/cs50x/cs50x_zh"><span itemprop="name">cs50x 中文版</span></a><meta itemprop="position" content="3"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/curriculum-resource/cs50x/cs50x_zh/lecture6"><span itemprop="name">lecture5 Data Structures</span></a><meta itemprop="position" content="4"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">课程笔记</span><meta itemprop="position" content="5"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>第五讲 - CS50x 2023</h1><ul><li><a href="#welcome">欢迎!</a></li><li><a href="#data-structures">数据结构</a></li><li><a href="#stacks-and-queues">栈和队列</a></li><li><a href="#jack-learns-the_facts">观看 Jack 学习事实</a></li><li><a href="#resizing-arrays">调整数组尺寸</a></li><li><a href="#linked-lists">链表</a></li><li><a href="#trees">树</a></li><li><a href="#dictionaries">字典</a></li><li><a href="#hashing-and-hash-tables">哈希和哈希表</a></li><li><a href="#tries">Trie树</a></li><li><a href="#summing-up">总结</a></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="欢迎">欢迎!<a href="#欢迎" class="hash-link" aria-label="Direct link to 欢迎!" title="Direct link to 欢迎!">​</a></h2><ul><li>之前的几周我们已经介绍了编程的基本构建块。</li><li>你所学的 C 语言知识将帮助你在 Python 等更高级的编程语言中实现这些基本模块。</li><li>今天，我们将讨论如何在内存中组织数据。</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="数据结构">数据结构<a href="#数据结构" class="hash-link" aria-label="Direct link to 数据结构" title="Direct link to 数据结构">​</a></h2><ul><li><em>数据结构</em> 本质上是内存中的组织形式。</li><li>有很多方法可以在内存中组织数据。</li><li><em>抽象数据结构</em> 是指我们可以在概念层面进行想象的数据结构。 在学习计算机科学时，通常从这些概念性的数据结构入手会很有帮助。 学习这些概念将使你更容易理解如何实现更具体的数据结构。</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="栈和队列">栈和队列<a href="#栈和队列" class="hash-link" aria-label="Direct link to 栈和队列" title="Direct link to 栈和队列">​</a></h2><ul><li><p><em>队列</em> 是一种抽象数据结构之一。</p></li><li><p>队列具有特定的属性。 也就是说，它们是 <em>FIFO</em>，或“先进先出”。 你可以想象一下在游乐园排队等候游乐设施的场景。 排在队伍最前面的人先乘坐，最后面的人最后乘坐。</p></li><li><p>队列具有与其相关的特定操作。 例如，一个项目可以被 <em>入队</em>，即加入队列。 此外，一个项目可以被 <em>出队</em>，也就是从队伍最前面离开队列。</p></li><li><p>队列和<em>栈</em>是相对的。 本质上，栈的属性与队列不同。 具体来说，它是 <em>LIFO</em>，或“后进先出”。 就像在自助餐厅堆叠托盘，最后放上去的托盘总是最先被取走的。</p></li><li><p>栈具有与其相关的特定操作。 例如，<em>push</em> 操作将元素放置在栈顶，而 <em>pop</em> 操作则从栈顶移除元素。</p></li><li><p>在代码中，你可以想象一个栈如下所示：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const int CAPACITY = 50;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    person people[CAPACITY];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">stack;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>注意，名为 <code>people</code> 的数组，其元素类型为 <code>person</code>。 <code>CAPACITY</code> 定义了栈的最大容量。 整数 <code>size</code> 表示栈当前存储的元素数量，即使栈的容量更大。</p></li><li><p>你可能已经注意到上面的代码存在一个局限性。 因为数组的容量是在代码中预先定义的。 因此，栈可能会占用过多的内存空间。 你可能会遇到栈只使用了一个位置，但却预留了 5000 个位置的情况。</p></li><li><p>如果我们的栈能够动态调整大小，随着元素的添加自动增长，那就更好了。</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="jack-学习事实">Jack 学习事实<a href="#jack-学习事实" class="hash-link" aria-label="Direct link to Jack 学习事实" title="Direct link to Jack 学习事实">​</a></h2><ul><li>我们观看了一段由埃隆大学 Shannon Duvall 教授制作的视频，名为 <a href="https://www.youtube.com/watch?v=ItAG3s6KIEI" target="_blank" rel="noopener noreferrer">Jack Learns the Facts</a>。</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="调整数组尺寸">调整数组尺寸<a href="#调整数组尺寸" class="hash-link" aria-label="Direct link to 调整数组尺寸" title="Direct link to 调整数组尺寸">​</a></h2><ul><li><p>回顾第二周的内容，我们介绍了你接触的第一个数据结构。</p></li><li><p>数组是一段连续的内存块。</p></li><li><p>你可以将数组想象成如下形式：</p><p><img loading="lazy" alt="三个带有 1 2 3 的框" src="data:image/png;base64,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SyL/9ttv6aVM1UdnAOigHA7CFStWJNvDRx99VP2aDxbos6hHjx41vc7DJ598ksRvbm5OL2Unt51r1f6lUXL10oF10xkAOiKHg7CyK/+zNGzbtm3s2LHJBQt0hubMmZPEf+2119JL2ambzmvWrEk6X3755eml7NRNZwDoiHwOwpaWlh9++OHee+/91xcfsEBn6JZbbknir1u3Lr2UnbrpvGzZsqTzRRddlF7KTt10BoCOyOcgHDx4cPfu3dPf/ZsFOkNDhw5N4m/YsCG9lJ266fzOO+9URz58+PAp/ouIVzedAaAjijgILdAZGj58eBJ/9erV6aXs1E3nr7/+ujry5s2b0xuZqpvOANARRRyEFugMjR07Nom/ZMmS9FJ26qPzlVdemUSeO3dueilT9dEZADqoiIPQAp2h5ubmJP4DDzyQXspOfXRev359deF9+/b16dMnvZSp+ugMAB1UxEFogc7Qhg0bkvhXXHFFeik7Re/c0NDwwgsvJIUnTpyY3sta0TsDwBkp4iC0QGdlwIABhw4dqi7/xRdfpJcyVejON9xww8cff1ydt+Lpp59O7+VAoTsDwJkq4iC0QGelffkZM2aklzKV/87XXntt44mam5uXLl2a/F+Dx/565Y2ZM2em758P+e8MAJ2oiIOw/RpngQ4wcuTII0eOVGf/8ccfzz333PRepvLfed68edUNT+bTTz+trNrpO+dG/jsDQCcq4iC0QMfr2bPn999/n2SfMGFCei9r+e98Ogt05TuTyqf0oEGD0nfOjfx3BoBOVMRBaIEO1rVr1/fffz9pnqu/gPAf+e98Ogv0cW1tbR988MHVV1+dPkQO5L8zAHSiIg5CC3Swl19+OQm+Z8+evn37pvdyIP+dT3+BPq61tbXyLumjZC3/nQGgExVxEFqgIz3xxBNJ7YMHD44YMSK9lw/579yrV69BJxo2bNiYMWNmzpy5fPny3bt3J7WPW7ZsWfpAmcp/ZwDoREUchBboMA8//HBbW1t16qNHj959993pvdwoaOdqt91222effVbd/LhcfZLXQWcA6LgiDkILdIwpU6ZU1uVipS5i5/a6du363HPPJeV///33AQMGpFczUh+dAaCDijgILdAB/nV7XrBgQXovZwrX+RSWL1+e9H/llVfSSxmpp84AULMiDkILdGebOnVq++35+eefT+/lT7E6n1rv3r0P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" title="数组" width="960" height="540" class="img_ev3q"></p></li><li><p>在内存中，还存储着其他程序、函数和变量的数据。 其中很多可能是之前使用过但现在已经废弃的垃圾数据。</p><p><img loading="lazy" alt="三个带有 1 2 3 的框，其中包含许多其他内存元素" src="/assets/images/cs50Week5Slide022-acaa2aa79a04382b68801ec715402077.png" title="内存中的数组" width="960" height="540" class="img_ev3q"></p></li><li><p>假设你想在数组中存储第四个值 <code>4</code>，该怎么办？ 这时，我们需要分配一块新的内存区域，并将旧数组的数据复制到新的区域。</p><p><img loading="lazy" alt="上面是三个框，分别标有 1 2 3，下面是四个框，分别标有 1 2 和两个垃圾值" src="/assets/images/cs50Week5Slide025-22c963b51f1f2d729377f69d4c5eea85.png" title="包含垃圾值的两个数组" width="960" height="540" class="img_ev3q"></p></li><li><p>旧的垃圾数据会被新数据覆盖。</p><p><img loading="lazy" alt="上面是三个框，分别标有 1 2 3，下面是四个框，分别标有 1 2 3 和一个垃圾值" src="/assets/images/cs50Week5Slide026-000585cb3f86e4a7a6d1f787cb933094.png" title="包含垃圾值的两个数组" width="960" height="540" class="img_ev3q"></p></li><li><p>这种方法的一个缺点是效率低：每次添加数字，都需要逐个复制数组元素。</p></li><li><p>如果能把 <code>4</code> 放在内存中的其他地方，岂不是更好？ 但这样一来，根据数组的定义，<code>4</code> 就不再和之前的元素连续存储，也就不再是数组了。</p></li><li><p>在您的终端中，键入 <code>code list.c</code> 并编写如下代码：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 使用固定大小的数组实现数字列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 大小为 3 的列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int list[3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 使用数字初始化列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list[0] = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list[1] = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list[2] = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 打印列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; 3; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%i\n&quot;, list[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>请注意，以上代码和我们之前学过的很相似，都是预先分配了三个元素的内存空间。</p></li><li><p>基于我们最近学到的知识，可以利用指针来优化代码设计。 请按照如下方式修改代码：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 使用动态大小的数组实现数字列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;stdlib.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 大小为 3 的列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int *list = malloc(3 * sizeof(int));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (list == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 使用数字初始化大小为 3 的列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list[0] = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list[1] = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list[2] = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 大小为 4 的列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int *tmp = malloc(4 * sizeof(int));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (tmp == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        free(list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将大小为 3 的列表复制到大小为 4 的列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; 3; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        tmp[i] = list[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将数字添加到大小为 4 的列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    tmp[3] = 4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 释放大小为 3 的列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    free(list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 记住大小为 4 的列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list = tmp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 打印列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; 4; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%i\n&quot;, list[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 释放列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    free(list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>请注意，代码首先创建了一个可以容纳3个整数的列表。 接着，将内存地址中的值依次赋值为 <code>1</code>、<code>2</code> 和 <code>3</code>。 然后，创建一个可以容纳4个整数的列表。 接下来，将原列表的内容复制到新列表中，并将值 <code>4</code> 添加到新列表 <code>tmp</code> 的末尾。 由于 <code>list</code> 原先指向的内存块不再使用，因此使用 <code>free(list)</code> 命令释放该内存。 最后，将 <code>list</code> 指针指向 <code>tmp</code> 所指向的新的内存块。 打印 <code>list</code> 的内容，并释放内存。</p></li><li><p>可以将 <code>list</code> 和 <code>tmp</code> 看作是指向内存块的标签。 如上例所示，<code>list</code> 最初指向一个大小为3的数组。 最后，<code>list</code> 指向一个大小为4的内存块。 实际上，在代码执行完毕后，<code>tmp</code> 和 <code>list</code> 指向的是同一块内存。</p></li><li><p>C语言提供了一个非常有用的函数 <code>realloc</code>，它能帮你重新分配内存。<code>realloc</code> 接受两个参数。首先，它会让你指定想要复制的数组。其次，它会让你指定最终数组的期望大小。请按照如下方式修改你的代码：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 使用 realloc 实现动态大小的数字列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;stdlib.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 大小为 3 的列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int *list = malloc(3 * sizeof(int));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (list == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 使用数字初始化大小为 3 的列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list[0] = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list[1] = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list[2] = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将列表大小调整为 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int *tmp = realloc(list, 4 * sizeof(int));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (tmp == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        free(list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list = tmp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 向列表添加数字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list[3] = 4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 打印列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; 4; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%i\n&quot;, list[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 释放列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    free(list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>请注意，<code>int *tmp = realloc(list, 4 * sizeof(int))</code> 尝试将列表的大小调整为 4 个整数的大小。然后，它会将 <code>list</code> 中的值复制到这个新数组中。最后，指针 <code>tmp</code> 指向这个新数组的内存地址。<code>realloc</code> 函数负责处理复制操作。如果 <code>realloc</code> 分配了新的内存块，那么 <code>list</code> 原先指向的内存会被释放。然后，指针 <code>list</code> 指向 <code>tmp</code> 指向的内存地址，也就是新数组的地址。</p></li><li><p>可以想象一下，将 <code>realloc</code> 应用于队列或堆栈会非常有用。随着数据量的增长，可以使用 <code>realloc</code> 来增大或缩小堆栈或队列。</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="链表">链表<a href="#链表" class="hash-link" aria-label="Direct link to 链表" title="Direct link to 链表">​</a></h2><ul><li><p>最近几周，你学习了三个很有用的基本概念。<code>struct</code> 是一种可以自定义的数据类型。<code>.</code> (点运算符) 允许你访问结构体内部的变量。<code>*</code> 运算符用于声明指针或者解引用。</p></li><li><p>今天，我们将介绍 <code>-&gt;</code> 运算符。这个运算符可以访问指针指向的结构体内部成员。</p></li><li><p>链表是 C 语言中最强大的数据结构之一。链表允许你存储位于不同内存地址的数据。此外，链表还能根据需要动态地扩展或缩小。</p></li><li><p>可以想象有三个值存储在不同的内存区域，如下图所示：</p><p><img loading="lazy" alt="包含 1 2 3 的三个框位于不同的内存区域" src="/assets/images/cs50Week5Slide036-0511725b57ab1c9bb7612b2ecc68971a.png" title="内存中的三个值" width="960" height="540" class="img_ev3q"></p></li><li><p>如何将这些值串联成一个列表呢？</p></li><li><p>我们可以想象上面这张图中的数据如下所示：</p><p><img loading="lazy" alt="包含 1 2 3 的三个框位于不同的内存区域，并附加了较小的框" src="/assets/images/cs50Week5Slide037-80882c5e917181dc84e252af738271c9.png" title="内存中的三个值" width="960" height="540" class="img_ev3q"></p></li><li><p>我们需要额外的内存来记录下一个元素的位置。</p><p><img loading="lazy" alt="包含 1 2 3 的三个框位于不同的内存区域，并附加了较小的框，其中内存地址位于这些附加的框中" src="/assets/images/cs50Week5Slide041-481047e2a7d89d4ea316f1359aa89ca5.png" title="内存中的三个值" width="960" height="540" class="img_ev3q"></p><p>注意，<code>NULL</code> 用于表示这是列表的末尾，没有下一个元素了。</p></li><li><p>按照惯例，我们会在内存中保留一个额外的元素，一个指针，用于跟踪列表中的第一个项目。</p><p><img loading="lazy" alt="包含 1 2 3 的三个框位于不同的内存区域，并附加了较小的框，其中内存地址位于这些附加的框中，现在还有一个包含第一个框的内存地址的最终框" src="/assets/images/cs50Week5Slide042-cc56910f78dbf6cef6f0cadde7ec7f45.png" title="带有指针的内存中的三个值" width="960" height="540" class="img_ev3q"></p></li><li><p>抽象掉内存地址，列表将如下所示：</p><p><img loading="lazy" alt="包含三个框，分别位于不同的内存区域，并带有较小的框，最后一个框指向另一个框，另一个框指向另一个框，直到框的末尾" src="/assets/images/cs50Week5Slide043-1db2ca533b2e88ab8d579194455026d3.png" title="带有指针的内存中的三个值" width="960" height="540" class="img_ev3q"></p></li><li><p>这些方框被称为<em>节点</em> (nodes)。一个<em>节点</em>包含一个<em>数据项</em> (item) 和一个名为 <em>next</em> 的指针。在代码中，你可以这样想象一个节点：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int number;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct node *next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>请注意，此节点中包含的数据是一个名为 <code>number</code> 的整数。其次，包含一个名为 <code>next</code> 的指针，它指向内存中的另一个节点。</p></li><li><p>链表不存储在连续的内存块中。只要有足够的系统资源，它们就可以按需增长。然而，与数组相比，链表需要更多的内存来维护其结构，这是它的一个缺点。这是因为除了元素本身的值，还需要额外存储指向下一个节点的指针。此外，链表不像数组那样支持随机访问（索引），因为要访问第 <!-- -->\<!-- -->(n<!-- -->\<!-- -->) 个元素，需要从头开始遍历前 <!-- -->\<!-- -->(n - 1<!-- -->\<!-- -->) 个元素。因此，上述链表只能进行线性搜索。因此，对于以上述方式构建的链表，无法使用二分查找。</p></li><li><p>从概念上讲，我们可以这样理解链表的创建过程。首先，声明 <code>node *list</code>，此时它的值是未定义的。</p><p><img loading="lazy" alt="一个垃圾值" src="/assets/images/cs50Week5Slide055-84496cd26f603f42614582549e474fa0.png" title="linked list" width="960" height="540" class="img_ev3q"></p></li><li><p>接下来，在内存中分配一个节点，并将其命名为 <code>n</code>。</p><p><img loading="lazy" alt="一个名为 n 的垃圾值，以及另一个名为 list 的指针" src="/assets/images/cs50Week5Slide059-b8d5b1b893ea7b8f4a0f1f200f394de6.png" title="linked list" width="960" height="540" class="img_ev3q"></p></li><li><p>接下来，将节点 <code>n</code> 的 <code>number</code> 字段赋值为 <code>1</code>。</p><p><img loading="lazy" alt="n 指向一个节点，其中 1 作为数字，垃圾值作为下一个" src="/assets/images/cs50Week5Slide064-fdbe346e6b361a188bed7e589ade63f0.png" title="linked list" width="2192" height="1232" class="img_ev3q"></p></li><li><p>接下来，将节点 <code>n</code> 的 <code>next</code> 字段赋值为 <code>NULL</code>。</p><p><img loading="lazy" alt="n 指向一个节点，其中 1 作为数字，null 作为下一个的值" src="/assets/images/cs50Week5Slide066-09aed921c5c6e89a330e30221f1117ad.png" title="linked list" width="2206" height="1232" class="img_ev3q"></p></li><li><p>接下来，<code>list</code> 指向 <code>n</code> 指向的内存位置。<code>n</code> 和 <code>list</code> 现在指向同一块内存地址。</p><p><img loading="lazy" alt="n 和 list 都指向一个节点，其中 1 作为数字，null 作为下一个的值" src="/assets/images/cs50Week5Slide068-6f2b8dc002e963e2e1b1372780be4f9d.png" title="linked list" width="960" height="540" class="img_ev3q"></p></li><li><p>然后创建一个新节点。此时，<code>number</code> 和 <code>next</code> 字段的值都是未定义的。</p><p><img loading="lazy" alt="list 指向一个节点，其中 1 作为数字，null 作为下一个的值，n 指向一个带有垃圾值的新节点" src="/assets/images/cs50Week5Slide073-56b65c25612bd8b012f8972efbe820b6.png" title="linked list" width="960" height="540" class="img_ev3q"></p></li><li><p>将新节点（<code>n</code>）的 <code>number</code> 字段更新为 <code>2</code>。</p><p><img loading="lazy" alt="list 指向一个节点，其中 1 作为数字，null 作为下一个的值，n 指向一个新节点，其中 2 作为数字，垃圾作为下一个" src="/assets/images/cs50Week5Slide075-2b4571fbb4406a2098be1bd8b23be5dc.png" title="linked list" width="960" height="540" class="img_ev3q"></p></li><li><p>同样，也需要更新 <code>next</code> 字段。</p><p><img loading="lazy" alt="list 指向一个节点，其中 1 作为数字，null 作为下一个的值，n 指向一个新节点，其中 2 作为数字，null 作为下一个" src="/assets/images/cs50Week5Slide077-98cd9c974b2f99817487ff3b10a64c46.png" title="linked list" width="960" height="540" class="img_ev3q"></p></li><li><p>最重要的是，我们不能丢失对任何节点的引用，否则它们将无法访问。因此，将 <code>n</code> 的 <code>next</code> 字段指向 <code>list</code> 当前指向的内存位置。</p><p><img loading="lazy" alt="list 指向一个节点，其中 1 作为数字，null 作为下一个的值，n 指向一个新节点，其中 2 作为数字，null 作为下一个" src="/assets/images/cs50Week5Slide084-4aa8f25103e05ac18994df9734f8d6a3.png" title="linked list" width="2200" height="1234" class="img_ev3q"></p></li><li><p>最后，更新 <code>list</code> 使其指向 <code>n</code>。我们现在有一个包含两个项目的链表。</p><p><img loading="lazy" alt="list 指向一个节点，其中 1 作为数字，下一个指向一个节点，其中 n 指向与节点 1 指向的同一个位置，该节点指向一个节点，其中 2 作为数字，null 作为下一个" src="/assets/images/cs50Week5Slide086-ff82ec018c63159710b74b9e9add04bf.png" title="linked list" width="960" height="540" class="img_ev3q"></p></li><li><p>为了在代码中实现上述逻辑，请按如下方式修改你的代码：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 使用while循环将数字前置到链表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;cs50.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;stdlib.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int number;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct node *next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 存储数字的内存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    node *list = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 对于每个命令行参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 1; i &lt; argc; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 把参数转换成整数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int number = atoi(argv[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 为数字分配一个节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        node *n = malloc(sizeof(node));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (n == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        n-&gt;number = number;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        n-&gt;next = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 将节点添加到链表头部</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        n-&gt;next = list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        list = n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 打印数字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    node *ptr = list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (ptr != NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%i\n&quot;, ptr-&gt;number);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ptr = ptr-&gt;next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 释放内存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ptr = list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (ptr != NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        node *next = ptr-&gt;next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        free(ptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ptr = next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>请注意，用户在命令行输入的数字会被存入名为<code>n</code>的节点的<code>number</code>字段，然后该节点会被添加到链表中。例如，<code>./list 1 2</code> 会将数字 <code>1</code> 放入名为 <code>n</code> 的节点的 <code>number</code> 字段中，然后将指向<code>list</code>的指针存入该节点的<code>next</code>字段，并将<code>list</code>更新为指向<code>n</code>。对于数字<code>2</code>，重复上述过程。接下来，<code>node *ptr = list</code> 创建了一个临时变量<code>ptr</code>，它指向<code>list</code>所指向的地址。<code>while</code>循环打印<code>ptr</code>所指向节点的内容，然后将<code>ptr</code>更新为指向链表中的下一个节点。最后，所有内存都会被释放。</p></li><li><p>其时间复杂度为<!-- -->\<!-- -->(O(n)<!-- -->\<!-- -->)，因为在最坏情况下，必须搜索整个链表才能找到目标元素。向链表添加新元素的时间复杂度取决于添加位置。以下示例说明了这一点。</p></li><li><p>例如，以下代码实现了一个将数字前置到链表的程序：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 使用 for 循环将数字前置到链表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;cs50.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;stdlib.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int number;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct node *next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 存储数字的内存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    node *list = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 对于每个命令行参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 1; i &lt; argc; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 把参数转换成整数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int number = atoi(argv[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 为数字分配一个节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        node *n = malloc(sizeof(node));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (n == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        n-&gt;number = number;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        n-&gt;next = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 将节点添加到链表头部</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        n-&gt;next = list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        list = n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 打印数字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (node *ptr = list; ptr != NULL; ptr = ptr-&gt;next)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%i\n&quot;, ptr-&gt;number);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 释放内存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    node *ptr = list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (ptr != NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        node *next = ptr-&gt;next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        free(ptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ptr = next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>请注意，数字是如何放置在列表的开头的。这种前置操作的时间复杂度为<!-- -->\<!-- -->(O(1)<!-- -->\<!-- -->)，因为所需步骤与链表大小无关。</p></li><li><p>此外，您也可以将数字添加到链表的末尾，如下面的代码所示：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 使用链表实现数字列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;cs50.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;stdlib.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int number;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct node *next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Memory for numbers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    node *list = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // For each command-line argument</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 1; i &lt; argc; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Convert argument to int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int number = atoi(argv[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Allocate node for number</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        node *n = malloc(sizeof(node));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (n == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        n-&gt;number = number;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        n-&gt;next = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // If list is empty</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (list == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // This node is the whole list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            list = n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // If list has numbers already</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Iterate over nodes in list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (node *ptr = list; ptr != NULL; ptr = ptr-&gt;next)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // If at end of list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ptr-&gt;next == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // Append node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ptr-&gt;next = n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Print numbers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (node *ptr = list; ptr != NULL; ptr = ptr-&gt;next)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%i\n&quot;, ptr-&gt;number);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Free memory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    node *ptr = list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (ptr != NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        node *next = ptr-&gt;next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        free(ptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ptr = next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>注意这段代码是如何“遍历”链表来找到尾部的。当在链表尾部添加一个元素时，我们的代码的时间复杂度是 <!-- -->\<!-- -->(O(n)<!-- -->\<!-- -->)，因为我们需要遍历整个链表才能找到尾部并添加新元素。</p></li><li><p>此外，你也可以在添加元素的同时对链表进行排序：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Implements a sorted list of numbers using a linked list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;cs50.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;stdlib.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int number;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct node *next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Memory for numbers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    node *list = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // For each command-line argument</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 1; i &lt; argc; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Convert argument to int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int number = atoi(argv[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Allocate node for number</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        node *n = malloc(sizeof(node));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (n == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        n-&gt;number = number;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        n-&gt;next = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // If list is empty</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (list == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            list = n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // If number belongs at beginning of list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if (n-&gt;number &lt; list-&gt;number)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            n-&gt;next = list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            list = n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // If number belongs later in list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Iterate over nodes in list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (node *ptr = list; ptr != NULL; ptr = ptr-&gt;next)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // If at end of list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ptr-&gt;next == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // Append node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ptr-&gt;next = n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // If in middle of list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (n-&gt;number &lt; ptr-&gt;next-&gt;number)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    n-&gt;next = ptr-&gt;next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ptr-&gt;next = n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Print numbers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (node *ptr = list; ptr != NULL; ptr = ptr-&gt;next)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%i\n&quot;, ptr-&gt;number);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Free memory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    node *ptr = list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (ptr != NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        node *next = ptr-&gt;next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        free(ptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ptr = next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>注意，这个链表在构建的过程中就已经完成了排序。要按照这种方式插入元素，在最坏的情况下，我们需要遍历当前链表中的所有元素来找到合适的位置，因此每次插入的时间复杂度仍然是 <!-- -->\<!-- -->(O(n)<!-- -->\<!-- -->)。</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="trees">Trees<a href="#trees" class="hash-link" aria-label="Direct link to Trees" title="Direct link to Trees">​</a></h2><ul><li><p><em>二叉搜索树</em> 是另一种数据结构，可用于更有效地存储数据，以便可以搜索和检索数据。</p></li><li><p>你可以想象一个已经排序好的数字序列。</p><p><img loading="lazy" alt="方框并排显示数字1 2 3 4 5 6 7" src="/assets/images/cs50Week5Slide086-ff82ec018c63159710b74b9e9add04bf.png" title="树" width="960" height="540" class="img_ev3q"></p></li><li><p>现在，假设中心值成为树的根节点。小于该值的放在左侧，大于该值的放在右侧。</p><p><img loading="lazy" alt="以层级结构排列的方框，包含数字1 2 3 4 5 6 7，其中4在顶部，3和5在其下方，1 2 6 7 在更下方" src="data:image/png;base64,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" title="树" width="960" height="540" class="img_ev3q"></p></li><li><p>然后，可以使用指针指向每个内存区域的正确位置，从而连接这些节点。</p><p><img loading="lazy" alt="以层级结构排列的方框，包含数字1 2 3 4 5 6 7，其中4在顶部，3和5在其下方，1 2 6 7 在更下方，箭头以树状结构连接它们" src="/assets/images/cs50Week5Slide120-d9bc45b87a6774598ec04b77bf3e118e.png" title="树" width="960" height="540" class="img_ev3q"></p></li><li><p>在代码中，这可以如下实现。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 将数字列表实现为二叉搜索树</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;stdlib.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 表示一个节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int number;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct node *left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct node *right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void free_tree(node *root);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void print_tree(node *root);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 空树</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    node *tree = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 添加数字到树中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    node *n = malloc(sizeof(node));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (n == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    n-&gt;number = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    n-&gt;left = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    n-&gt;right = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    tree = n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 加入数字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    n = malloc(sizeof(node));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (n == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        free_tree(tree);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    n-&gt;number = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    n-&gt;left = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    n-&gt;right = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    tree-&gt;left = n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 插入数字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    n = malloc(sizeof(node));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (n == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        free_tree(tree);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    n-&gt;number = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    n-&gt;left = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    n-&gt;right = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    tree-&gt;right = n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 打印树</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print_tree(tree);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 释放树</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    free_tree(tree);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void free_tree(node *root)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (root == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    free_tree(root-&gt;left);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    free_tree(root-&gt;right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    free(root);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void print_tree(node *root)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (root == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print_tree(root-&gt;left);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;%i\n&quot;, root-&gt;number);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print_tree(root-&gt;right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li><p>以下是如何实现树的搜索：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">bool search(node *tree, int number)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (tree == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else if (number &lt; tree-&gt;number)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return search(tree-&gt;left, number);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else if (number &gt; tree-&gt;number)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return search(tree-&gt;right, number);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else if (number == tree-&gt;number)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>注意，此搜索函数首先访问 <code>tree</code> 节点。然后，它使用递归来搜索 <code>number</code>。</p></li><li><p>与数组相比，上述树结构提供了更好的动态性，可以根据需要进行扩展或收缩。</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="字典">字典<a href="#字典" class="hash-link" aria-label="Direct link to 字典" title="Direct link to 字典">​</a></h2><ul><li><p><em>字典</em> 是另一种数据结构。</p></li><li><p>像实际的书本形式的字典一样，字典有一个 <em>键</em> 和一个 <em>值</em>。</p></li><li><p>时间复杂度中最理想的情况是 <!-- -->\<!-- -->(O(1)<!-- -->\<!-- -->)，即 <em>常数时间</em>。</p></li><li><p>这意味着访问速度几乎是瞬时的。</p><p><img loading="lazy" alt="各种时间复杂度的图表，其中 O of log n 是第二好的，O of 1 是最好的" src="/assets/images/cs50Week5Slide151-ab8f6a2a39136eeab95f96a435a57bda.png" title="时间复杂度" width="960" height="540" class="img_ev3q"></p></li><li><p>字典可以提供这种访问速度。</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="散列和散列表">散列和散列表<a href="#散列和散列表" class="hash-link" aria-label="Direct link to 散列和散列表" title="Direct link to 散列和散列表">​</a></h2><ul><li><p><em>散列</em>是一种将一个值转换成另一个值，后者可以作为前者的快捷访问方式的概念。</p></li><li><p>例如，<em>apple</em> 经过散列函数计算后可能得到值 <code>1</code>，而 <em>berry</em> 可能得到 <code>2</code>。因此，查找 <em>apple</em> 就像通过 <em>散列</em> 算法直接找到其存储位置一样简单。即使像将所有以 &#x27;a&#x27; 开头的词放在一个桶里，所有以 &#x27;b&#x27; 开头的词放在另一个桶里这种设计并不理想，但这种 <em>分桶</em> 的概念展示了如何利用散列值来快速定位数据。</p></li><li><p><em>散列函数</em>是一种将较大的输入值转换为较小且可预测的输出值的算法。</p></li><li><p>通常，该函数接收你想要添加到散列表中的数据项，并返回一个整数，该整数代表了该数据项应该被放置的数组索引。</p></li><li><p><em>散列表</em>是数组和链表的巧妙结合。</p></li><li><p>从代码实现的角度来看，散列表可以看作是一个由指向 <em>节点 (node)</em> 的 <em>指针</em> 构成的 <em>数组</em>。</p></li><li><p>哈希表可以想象成如下：</p><p><img loading="lazy" alt="一个垂直的列，有26个盒子，每个盒子代表字母表中的一个字母" src="data:image/png;base64,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qFISwckWAACqlERwsgUAgColEZxsAQCgSkkEJ1sAAKhSEsHJFgAAmuKuu+4a+a+8V65cWR73SiI42QIAQFP8x3/8x7XXXtv/it/8zd8sj3slEZxsAQCgKToBfe6555bv7kMSwckWAACaQkADAMAodAK6/aqBgYHyuFcSwckWAACawjfQAAAwCgIaAABGQUADAMAo3HXXXaeeemr57j4kEZxsAQCgSkkEJ1sAAKhSEsHJFgAAqpREcLIFAIAqtVqt9v7avn17+XEAAHBgawffIidbAACoUhLByRYAAKqURHCyBQCAKiURnGwBAKBKSQQnWwAAqFISwckWAACa4qCDDvrMZz7z9a9//dFHH7377runT59e3uiSRHCyBQCARhg7duyqVav+9V//9WMf+1h/f//ll19+yimnlJe6JBGcbAEAoBHOO++8zZs3H3744eXBPiQRnGwBAKARlixZ8ld/9Vflu/uWRHCyBQCARvjWt7515ZVXdh7mz5/ffsWnPvWp8lKXJIKTLQAANMKKFStuvPHGkZcDAwMCGgAA9umqq6568sknx4wZM/xSQAMAwGs54ogjnn/++TvuuOOd73zntGnTnnjiCQENAACvpdPNt99++w9/+MPBwcFVq1addNJJ5Y0uSQQnWwAAqFISwckWAACqlERwsgUAgColEZxsAQCgSq1Wq72/du7cWX4cAAAc2NrBt8jJFgAAqpREcLIFAIAqJRGcbAEAoEpJBCdbAACoUhLByRYAAKqURHCyBQCARpg1a9bChQtHXn7pS1/63d/93a7zUhLByRYAABph3rx5991338jLhx566LLLLus6LyURnGwBAKARBDQAAIxCJ6DXrFnT96r169cLaAAA2KdOQP/3f//34KtefvllAQ0AAPvkJxwAADAKAhoAAEZBQAMAwCj4O9AAAPALlERwsgUAgColEZxsAQCgSkkEJ1sAAKjSnj172vur1WqVHwcAAAe2dvAtcrIFAIAqJRGcbAEAoEpJBCdbAACoUhLByRYAAKqURHCyBQCAKiURnGwBAKARJk2aNNDr9a9/fXmpSxLByRYAABph3Lhx/f39M2fO7NTtmWee2XkeM2ZMealLEsHJFgAAGmTKlCmduj300EPLg70kEZxsAQCgQQQ0AACMgoAGAIBRENAAADAKAhoAAH4uY8eO7evre//739+p23e9612d5/JGrySCky0AADSCvwMNAAC/QEkEJ1sAAKhSEsHJFgAAqpREcLIFAIAqJRGcbAEAoEqtVqu9v3bs2FF+HAAAHNjawbfIyRYAAKqURHCyBQCAKiURnGwBAKBKSQQnWwAAqFISwckWAACa4mtf+9rI/+N90UUXlce9kghOtgAA0BQnn3xy/yu++c1vLly4sDzulURwsgUAgMZZunSpgAYAgJ+XgAYAgFEQ0AAAMAoCGgAARuH++++/4oorynd7JRGcbAEAoCmuueaad73rXWeeeea2bdve9773lce9kghOtgAA0BR33HHHv//7vz/11FMXXnhhebaXJIKTLQAAVCmJ4GQLAABVSiI42QIAQJWSCE62AABQpSSCky0AAFRpz5497f21e/fu8uMAAODA1g6+RU62AABQpSSCky0AAFQpieBkCwAAVUoiONkCAECVkghOtgAA0AjTpk1bu3bt8POv/uqvfuMb35g+fXrvlR5JBCdbAABohOOPP37Xrl2dhze+8Y2PP/74NddcU97olURwsgUAgEYYCeg777zzq1/9anm8lySCky0AADTCcEB/+tOf/s53vvOGN7yhPN5LEsHJFgAAGqET0Lt37/7pT3/68Y9/vDz7nyQRnGwBAKARhr+BnjVr1osvvjh16tTyeC9JBCdbAABohJHfQN9yyy0bN26cMGFCeaNXEsHJFgAAGmEkoDvp/N3vfvdv//Zvyxu9kghOtgAA0Ajdfwe6r6+v8/z+97+/90qPJIKTLQAAVCmJ4GQLAABVSiI42QIAQJWSCE62AABQpSSCky0AAFQpieBkCwAAVWq1Wu39tX379vLjAADgwNYOvkVOtgAAUKUkgpMtAABUKYngZAsAAFVKIjjZAgBAU1x33XVz5swp392HJIKTLQAANMWyZcu+8IUvlO/uQxLByRYAAJpCQAMAwCgIaAAAGAUBDQAAoyCgAQBgFAQ0AACMQiegb7755r5XTZgwobzRJYngZAsAAE1x3XXXDXSZPn16eaNLEsHJFgAAqpREcLIFAIAqJRGcbAEAoEpJBCdbAACoUhLByRYAAKqURHCyBQCAKrVarfb+2rVrV/lxAABwYGsH3yInWwAAqFISwckWAACqlERwsgUAgColEZxsAQCgEWbNmrV27dqDDz6483zkkUcODAycc8455aUuSQQnWwAAaIQFCxZs3bq1k9Gd5z/6oz/asmXLvHnzyktdkghOtgAA0Ag333zzsmXLVq1a1Xl+8sknb7vttoULF5aXuiQRnGwBAKAR/u7v/u6Tn/zks88+++EPf/ihhx6aP3/+l7/85fJSlySCky0AADTCP/zDP8yaNasTzT/+8Y8vuOCCz372s7fddlt5qUsSwckWAAAaYfXq1eecc8673/3u//qv/5o4ceJll1129913l5e6JBGcbAEAoBEefvjhM844Y+TlRRdd9MADD3Sdl5IITrYAANAIjz/++GmnnTby8hOf+MT69eu7zktJBCdbAABohCVLlhx//PEjL0855ZTFixd3nZeSCE62AABQpSSCky0AAFQpieBkCwAAVUoiONkCAECVkghOtgAAUKUkgpMtAABU6aWXXmrvr862/DgAADiwCWgAABiFdvAzjGQLAABVSiI42QIAQJWSCE62AADQCDNmzBgYGBj537xvuOGGj3zkI71XeiQRnGwBAKARPvWpT+3evfuuu+4afrly5co5c+b0XumRRHCyBQCARugE9Nq1a7ds2TJt2rTXCWgAAHhtnYBetmzZ4sWLb7nlltcJaAAAeG3DAf32t79927ZtRx55pIAGAIDXMhzQnYd77rnnT/7kTwQ0AAC8lpGAfu973/viiy+uXbtWQAMAwD6NBHTHt771rV27dgloAADYpxkzZlx33XXDz/39/QMDA/4ONAAA/K9JIjjZAgBAlZIITrYAAFClJIKTLQAAVCmJ4GQLAABVSiI42QIAQJWSCE62AABQpVar1d5fQ0ND5ccBAMCBrR18i5xsAQCgSkkEJ1sAAKhSEsHJFgAAmqKvr+/2229/9NFHly1bduKJJ5bHvZIITrYAANAIRxxxxHPPPffFL36xv7+/8++WLVumTp1aXuqSRHCyBQCARrj66qsfeeSRkZed5wULFnSdl5IITrYAANAIDz744LXXXjvy8vrrr1+9enXXeSmJ4GQLAACNsHHjxksuuWTk5dy5czds2NB1XkoiONkCAEAjrFu37rOf/ezIywULFqxcubLrvJREcLIFAIBG+MpXvnLfffeNvOz09Pz587vOS0kEJ1sAAGiEE044YWho6JJLLunr6+uk8+bNm3/5l3+5vNQlieBkCwAATfHRj3700UcfHRwcXL169fHHH18e90oiONkCAECVkghOtgAAUKUkgpMtAABUKYngZAsAAFVKIjjZAgBAlZIITrYAAFClJIKTLQAAVGnPnj3t/dVqtcqPAwCAA1s7+BY52QIAQJWSCE62AABQpSSCky0AADTC1KlTB17xta997YYbbui8LG/0SiI42QIAQCMce+yxna7t7+8/88wz77zzzhdeeGHy5MnlpS5JBCdbAABohOGAHn4eM2bM4ODgnDlzeq/0SCI42QIAQCMUAb1p06azzz6790qPJIKTLQAANELxE45nnnnmjW98Y3mpSxLByRYAABphOKAHBgYeeuih66677rDDDitv9EoiONkCAEAjdP+E4+cxqsuFZAsAAI0goAEAYBSG/w50+e6+JRGcbAEAoEpJBCdbAACoUhLByRYAAKqURHCyBQCAKiURnGwBAKBKSQQnWwAAqFISwckWAACqlERwsgUAgCq1Wq32/tqxY0f5cQAAcGBrB98iJ1sAAKhSEsHJFgAAmqKvr+/2229/9NFHly1bduKJJ5bHvZIITrYAANAIhx9++HPPPfelL32pv7//pptu2rJly9SpU8tLXZIITrYAANAIV1555cMPPzzycsOGDQsXLuw6LyURnGwBAKARHnjggWuvvXbk5fXXX995p+u8lERwsgUAgEb47ne/e8kll4y8nDt37oYNG7rOS0kEJ1sAAGiERx555I//+I9HXi5YsGDlypVd56UkgpMtAAA0wi233LJixYqRl+vWrbv66qu7zktJBCdbAABohBNPPHFoaOjSSy/t6+u75pprNm/ePHny5PJSlySCky0AADTFWWed9dhjj7VarVWrVh133HHlca8kgpMtAAA0yKRJk3bs2HHyySd3no8++ujyuEsSwckWAACa5Q//8A+3bt367LPPPvHEE+PGjSuPX5VEcLIFAIDGmTBhwlve8pby3V5JBCdbAACoUhLByRYAAKqURHCyBQCAKiURnGwBAKBKSQQnWwAAqNKePXva+2v37t3lxwEAwIGtHXyLnGwBAKBKSQQnWwAAaIQ3velNA6+45557Fi5cePjhh5c3eiURnGwBAKARJk+e3Onas88++3d+53c2bNiwbt268kavJIKTLQAANMJwQHf+7Tz39/fv3LmzvNErieBkCwAAjTAS0OPGjVu0aNH69evLG72SCE62AADQCMMB/eMf/3jnzp3f+MY33vKWt5Q3eiURnGwBAKARRr6BPv/881944YXh33K8hiSCky0AADRC92+g16xZc9NNN5U3eiURnGwBAKARugP6tNNO27Zt2xFHHFFe6pJEcLIFAIBGGP470J1/h18uWbLkvPPO673SI4ngZAsAAFVKIjjZAgBAlZIITrYAAFClJIKTLQAAVCmJ4GQLAABVSiI42QIAQJWSCE62AABQpSSCky0AAFQpieBkCwAAVWq1Wu39tX379vLjAADgwNYOvkVOtgAA0BQnnHDCkiVLNm7cODAw8PnPf7487pVEcLIFAIBGOOqoo7Zs2XLllVe+733v6+/vP+uss8obvZIITrYAANAI55xzzvPPP1++u29JBCdbAABohClTpvzsZz+78847jz766PLsf5JEcLIFAICmOPbYY1esWLFz58577733rW99a3ncK4ngZAsAAM0ybdq0pUuX/uQnPzniiCPKsy5JBCdbAABonLFjx27btu30008vD7okEZxsAQCgEX7t137tlFNO6XvFFVdcsXXr1iOPPLK81CWJ4GQLAACNcM455zz22GODr7j33nt//dd/vbzRK4ngZAsAAFVKIjjZAgBAlZIITrYAAFClJIKTLQAAVCmJ4GQLAABVSiI42QIAQJWSCE62AABQpSSCky0AAFQpieBkCwAAVWq1Wu39tXPnzvLjAADgwNYOvkVOtgAA0Ajz5s0b6PWZz3ymvNQlieBkCwAAjXDsscf29/fPnDmzU7dnnnlm5/ltb3tbealLEsHJFgAAGmTKlCmduj300EPLg70kEZxsAQCgQQQ0AACMgoAGAIBRENAAADAKAhoAAEZBQAMAwCi8+c1vHhgYmDRpUnmwlySCky0AAFQpieBkCwAAVUoiONkCAECVkghOtgAAUKUkgpMtAABUKYngZAsAAFVKIjjZAgBAlZIITrYAAFClJIKTLQAAVGnPnj3t/dXZlh8HAAAHtnbwLXKyBQCARpg9e/bChQtHXn7xi18899xzu85LSQQnWwAAaIT58+ffd999Iy8ffPDBuXPndp2XkghOtgAA0AgCGgAARkFAAwDAKAhoAAAYBQENAACjcPnllz/88MMjL7/3ve9deOGFXeelJIKTLQAANMKJJ544NDT00Y9+9Oijj549e/aWLVuOPPLI8lKXJIKTLQAANMX555//ve99b3BwcN26dSeffHJ53CuJ4GQLAABVSiI42QIAQJWSCE62AABQpSSCky0AAFQpieBkCwAAVUoiONkCAECVkghOtgAAUKUkgpMtAABUKYngZAsAAFVKIjjZAgBAlVqtVnt/DQ0NlR8HAAAVmThx4je/+c0TTjhh5J3jjjtuzZo148eP77rVox18i5xsAQCgER5++OEbbrhh5OWCBQtWrlzZdV5KIjjZAgBAI3z605/+t3/7t5GXTz/99OzZs7vOS0kEJ1sAAGiEo446qtVqHXfccZ3nY445Zvv27b/0S79UXuqSRHCyBQCApli/fv3nP//5zsNVV1117733lse9kghOtgAA0BRz58594oknOg8bN2782Mc+Vh73SiI42QIAQFNMmTKl1WqdeuqpW7dunThxYnncK4ngZAsAAA3yT//0T88888zdd99dHuwlieBkCwAADTJ79uyBgYEPf/jD5cFekghOtgAAUKUkgpMtAABUKYngZAsAAFVKIjjZAgBAlZIITrYAAFClJIKTLQAAVCmJ4GQLAABVSiI42QIAQJWSCE62AABQpSSCky0AAFRpz5497f21e/fu8uMAAKAuX/3qV6dPnz7y8phjjrntttu6zkvt4FvkZAsAAI3w+OOPn3766SMv+/v7169f33VeSiI42QIAQCOsXbt25syZIy/PPvvs+++/v+u8lERwsgUAgEZYtmzZRRdddNhhhz399NNveMMbLrjggjvuuKO81CWJ4GQLAACNsHjx4ssvv3zOnDm7d++eOXPmZZdd9uUvf7m81CWJ4GQLAACNcOONN37hC19YuXLlLbfccs8991x11VWdl+WlLkkEJ1sAAGiEefPmLV68eNOmTYcddtjPfvazTkbPnTu3vNQlieBkCwAAjfAHf/AHmzdv/spXvtJ5vvfee1944YULL7ywvNQlieBkCwAAjfChD31oYGDgve99b+f5jDPO6Dx/4AMfKC91SSI42QIAQJWSCE62AABQpSSCky0AAFQpieBkCwAAVUoiONkCAECVkghOtgAAUKUkgpMtAABUKYngZAsAAFVKIjjZAgBAlZIITrYAAFClJIKTLQAANMLVV1/953/+5yMv//Iv//Kyyy7rOi+1Wq32/tqxY0f5cQAAUJdp06Zt27bttNNO6zyfddZZL7744uTJk8tLXdrBt8jJFgAAmuJzn/vc97///UMPPXRwcPCCCy4oj3slEZxsAQCgKcaNG/fkk08+88wza9asKc/2kkRwsgUAgAb55Cc/2anbc889tzzYSxLByRYAAJpi4sSJmzZtWrdu3fe///0JEyaUx72SCE62AADQFIsWLXrkkUfGjx/fCegFCxaUx72SCE62AADQCB/4wAeGhobe+c53dp5/67d+q/N8/PHHl5e6JBGcbAEAoBFuvfXWq666auTlTTfddOONN3adl5IITrYAAFClJIKTLQAAVCmJ4GQLAABVSiI42QIAQJWSCE62AABQpSSCky0AAFQpieBkCwAAVUoiONkCAECVkghOtgAAUKUkgpMtAABUKYngZAsAAP/3Dj744NWrV5911lkj75x++ukrVqwYP358160erVarvb927dpVfhwAANTl+uuv/8EPfjBu3LjO89ixY5966qkrrriivNSlHXyLnGwBAKARJk6c+Oyzz1566aWd59mzZ2/atGnChAnlpS5JBCdbAABoijlz5vznf/7nm970pk49//7v/3553CuJ4GQLAABNMWbMmMcee+w73/nOhg0byrO9JBGcbAEAoEFOO+20Tt2efPLJ5cFekghOtgAA0CBTpkzp1O2hhx5aHuwlieBkCwAADSKgAQBgFN785jcPDAxMmjSpPNhLEsHJFgAAqpREcLIFAIAqJRGcbAEAoEpJBCdbAACoUhLByRYAAKqURHCyBQCAKiURnGwBAKBKSQQnWwAAqFISwckWAACqlERwsgUAgColEZxsAQCgET70oQ8N9Dr11FPLS12SCE62AADQCNOmTZvzqkWLFm3fvv3tb397ealLq9Vq76/Oh5cfBwAAlZowYcLTTz89b9688qBXO/gWOdkCAECz/Omf/uk///M/v/71ry8PeiURnGwBAKBB3vOe92zduvUd73hHebCXJIKTLQAANMX48eP/5V/+5f/7441hSQQnWwAAaIoFCxb8PD/eGJZEcLIFAIBGOOmkk3bu3HnppZf2v+qoo44qL3VJIjjZAgBAI8yaNav4O9AzZswoL3VJIjjZAgBAlZIITrYAAFClJIKTLQAAVCmJ4GQLAABVSiI42QIAQJWSCE62AABQpSSCky0AAFQpieBkCwAAVUoiONkCAECVkghOtgAAUKUkgpMtAABUKYngZAsAAFV66aWX2vursy0/DgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg5/L/AH35hqHmxZDjAAAAAElFTkSuQmCC" title="字母表" width="960" height="540" class="img_ev3q"></p><p>请注意，这是一个数组，每个元素对应字母表中的一个字母。</p></li><li><p>接着，数组的每个位置都使用链表来存储对应的数据：</p><p><img loading="lazy" alt="一个垂直的列，有26个盒子，每个盒子代表字母表中的一个字母，其中从右边出现各种哈利波特宇宙的名字，albus在a处，harry在h处" src="/assets/images/cs50Week5Slide169-7eceae73c23cae8c4e977d307d2d7369.png" title="字母表" width="960" height="540" class="img_ev3q"></p></li><li><p><em>冲突</em>指的是当尝试将一个值添加到散列表时，目标位置已经被占用。</p></li><li><p>在这种情况下，冲突的值会被简单地添加到链表的末尾。</p></li><li><p>通过优化散列表的设计和散列算法，可以减少冲突的发生。</p></li><li><p>一种改进的方案如下所示：</p><p><img loading="lazy" alt="一个垂直的列，其中各种盒子按H A G和H A R排列，hagrid从H A G中出现，harry从H A R中出现" src="/assets/images/cs50Week5Slide184-5b051490f8a2c1373afe988728dab2f9.png" title="字母表" width="960" height="540" class="img_ev3q"></p></li><li><p>作为程序员，你需要权衡：是使用更多的内存来创建一个更大的散列表，从而潜在地减少搜索时间；还是使用更少的内存，但可能导致更长的搜索时间。</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="前缀树-trie">前缀树 (Trie)<a href="#前缀树-trie" class="hash-link" aria-label="Direct link to 前缀树 (Trie)" title="Direct link to 前缀树 (Trie)">​</a></h2><ul><li><p><em>前缀树</em>是另一种数据结构。</p></li><li><p><em>前缀树</em>的搜索时间复杂度始终为常数级别。</p></li><li><p><em>前缀树</em>的一个缺点是它通常会占用大量的内存空间。</p></li><li><p>注意，仅仅为了存储 <em>Hagrid</em> 这个词，我们就需要 <!-- -->\<!-- -->(26 <!-- -->\<!-- -->times 5 = 130<!-- -->\<!-- -->) 个 <code>节点 (node)</code>！</p></li><li><p>存储 <em>Hagrid</em> 的方式如下：</p><p><img loading="lazy" alt="hagrid一次拼写一个字母，其中一个字母与一个列表相关联，H来自一个列表，A来自另一个列表，依此类推" src="/assets/images/cs50Week5Slide207-3edee4e4fa2985886f8a32ed65296cd3.png" title="tries" width="960" height="540" class="img_ev3q"></p></li><li><p>Harry 的存储方式类似，与 Hagrid 共享前两个字母 H 和 A。</p><p><img loading="lazy" alt="hagrid一次拼写一个字母，其中一个字母与一个列表相关联，H来自一个列表，A来自另一个列表，依此类推，harry的拼写方式类似，其中hagrid和harry共享两个共同的字母H和A" src="/assets/images/cs50Week5Slide209-e84d3edae45bf09acd5d180623b379d0.png" title="tries" width="960" height="540" class="img_ev3q"></p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="总结一下">总结一下<a href="#总结一下" class="hash-link" aria-label="Direct link to 总结一下" title="Direct link to 总结一下">​</a></h2><p>在本节课中，我们学习了如何利用指针构建新的数据结构，主要涉及以下内容……</p><ul><li>数据结构</li><li>栈和队列</li><li>调整数组大小</li><li>链表</li><li>字典</li><li>Tries</li></ul><p>下次见！</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/curriculum-resource/cs50x/cs50x_zh/lecture6"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">数据结构</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/curriculum-resource/cs50x/cs50x_zh/lecture6/problem set"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">问题集</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#欢迎" class="table-of-contents__link toc-highlight">欢迎!</a></li><li><a href="#数据结构" class="table-of-contents__link toc-highlight">数据结构</a></li><li><a href="#栈和队列" class="table-of-contents__link toc-highlight">栈和队列</a></li><li><a href="#jack-学习事实" class="table-of-contents__link toc-highlight">Jack 学习事实</a></li><li><a href="#调整数组尺寸" class="table-of-contents__link toc-highlight">调整数组尺寸</a></li><li><a href="#链表" class="table-of-contents__link toc-highlight">链表</a></li><li><a href="#trees" class="table-of-contents__link toc-highlight">Trees</a></li><li><a href="#字典" class="table-of-contents__link toc-highlight">字典</a></li><li><a href="#散列和散列表" class="table-of-contents__link toc-highlight">散列和散列表</a></li><li><a href="#前缀树-trie" class="table-of-contents__link toc-highlight">前缀树 (Trie)</a></li><li><a href="#总结一下" class="table-of-contents__link toc-highlight">总结一下</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">CS学习社区</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">路线图</a></li></ul></div><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyleft © 2025 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.778e0441.js"></script>
<script src="/assets/js/main.3597ac80.js"></script>
</body>
</html>