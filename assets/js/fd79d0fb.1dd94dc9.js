"use strict";(self.webpackChunklearncs_set=self.webpackChunklearncs_set||[]).push([[403],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>h});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),d=p(a),u=i,h=d["".concat(l,".").concat(u)]||d[u]||c[u]||r;return a?n.createElement(h,o(o({ref:t},m),{},{components:a})):n.createElement(h,o({ref:t},m))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},82703:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var n=a(87462),i=(a(67294),a(3905));const r={title:"Lab 08 Hashmaps"},o=void 0,s={unversionedId:"curriculum-resource/cs61b/labs/lab08/index",id:"curriculum-resource/cs61b/labs/lab08/index",title:"Lab 08 Hashmaps",description:"FAQ",source:"@site/docs/curriculum-resource/cs61b/labs/lab08/index.md",sourceDirName:"curriculum-resource/cs61b/labs/lab08",slug:"/curriculum-resource/cs61b/labs/lab08/",permalink:"/docs/curriculum-resource/cs61b/labs/lab08/",draft:!1,tags:[],version:"current",frontMatter:{title:"Lab 08 Hashmaps"},sidebar:"tutorialSidebar",previous:{title:"FAQ",permalink:"/docs/curriculum-resource/cs61b/labs/lab07/faq"},next:{title:"FAQ - Lab08",permalink:"/docs/curriculum-resource/cs61b/labs/lab08/faq"}},l={},p=[{value:"FAQ",id:"faq",level:2},{value:"Introduction",id:"introduction",level:2},{value:"MyHashMap",id:"myhashmap",level:2},{value:"Overview",id:"overview",level:3},{value:"Refresher Animation",id:"refresher-animation",level:3},{value:"Skeleton Code",id:"skeleton-code",level:3},{value:"Implementation Requirements",id:"implementation-requirements",level:3},{value:"Resources",id:"resources",level:3},{value:"Testing",id:"testing",level:3},{value:"Speed Testing",id:"speed-testing",level:2},{value:"Different Bucket Types",id:"different-bucket-types",level:2},{value:"Deliverables and Scoring",id:"deliverables-and-scoring",level:2},{value:"Submission",id:"submission",level:2},{value:"Optional Exercises",id:"optional-exercises",level:2}],m={toc:p},d="wrapper";function c(e){let{components:t,...r}=e;return(0,i.kt)(d,(0,n.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"faq"},"FAQ"),(0,i.kt)("p",null,"The FAQ for this lab can be found ",(0,i.kt)("a",{parentName:"p",href:"/docs/curriculum-resource/cs61b/labs/lab08/faq"},"here"),"."),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"In this lab, you'll work on ",(0,i.kt)("inlineCode",{parentName:"p"},"MyHashMap"),", a hashtable-based implementation of\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"Map61B")," interface. This will be very similar to Lab 06, except this time\nwe're building a ",(0,i.kt)("inlineCode",{parentName:"p"},"HashMap")," rather than a ",(0,i.kt)("inlineCode",{parentName:"p"},"TreeMap"),"."),(0,i.kt)("p",null,"After you've completed your implementation, you'll compare the performance of\nyour implementation to a list-based Map implementation ",(0,i.kt)("inlineCode",{parentName:"p"},"ULLMap")," as well as the\nbuilt-in Java ",(0,i.kt)("inlineCode",{parentName:"p"},"HashMap")," class (which also uses a hash table). We'll also compare\nthe performance of ",(0,i.kt)("inlineCode",{parentName:"p"},"MyHashMap")," when it uses different data structures to be the\nbuckets."),(0,i.kt)("h2",{id:"myhashmap"},"MyHashMap"),(0,i.kt)("h3",{id:"overview"},"Overview"),(0,i.kt)("p",null,"We've created a class ",(0,i.kt)("inlineCode",{parentName:"p"},"MyHashMap")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"MyHashMap.java"),", with very minimal starter\ncode. Your goal is to implement all of the methods in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Map61B")," interface\nfrom which ",(0,i.kt)("inlineCode",{parentName:"p"},"MyHashMap")," inherits, ",(0,i.kt)("em",{parentName:"p"},"except")," ",(0,i.kt)("inlineCode",{parentName:"p"},"remove"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"keySet")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"iterator"),"\n(optional for Lab 08). For these, feel free to throw an\n",(0,i.kt)("inlineCode",{parentName:"p"},"UnsupportedOperationException"),"."),(0,i.kt)("p",null,"Note that your code will not compile until you implement all the methods of\n",(0,i.kt)("inlineCode",{parentName:"p"},"Map61B"),". You can implement methods one at a time by writing the method\nsignatures of all the required methods, but throwing\n",(0,i.kt)("inlineCode",{parentName:"p"},"UnsupportedOperationException"),"s for the implementations until you get around to\nactually writing them."),(0,i.kt)("h3",{id:"refresher-animation"},"Refresher Animation"),(0,i.kt)("p",null,"The following is a quick animation of how a hash table works. ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," refers to the\nnumber of items in the hash table, and ",(0,i.kt)("inlineCode",{parentName:"p"},"M")," refers to the number of buckets."),(0,i.kt)("p",null,"We use an object's ",(0,i.kt)("inlineCode",{parentName:"p"},"hashCode")," modulo'd (%) by the number of buckets to determine\nwhich bucket the object (represented by a shape) falls into. When the load\nfactor is reached, we multiply the number of buckets by the resizing factor and\nrehash all of the items, modulo-ing them by the new number of buckets."),(0,i.kt)("p",null,"For the video animation below, the hash function is arbitrary and outputs a random\ninteger for each shape (the object) that is inputted. "),(0,i.kt)("p",{align:"center"},(0,i.kt)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/tUEixFouAjg?start=5",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0})),(0,i.kt)("p",null,"Credits to Meshan Khosla for this animation!"),(0,i.kt)("h3",{id:"skeleton-code"},"Skeleton Code"),(0,i.kt)("p",null,"You might recall from lecture that when we build a hash table, we can choose a\nnumber of different data structures to be the buckets. The classic approach is\nto choose a ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList"),". But we can also choose ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList"),"s, ",(0,i.kt)("inlineCode",{parentName:"p"},"TreeSet"),"s, or\neven other crazier data structures like ",(0,i.kt)("inlineCode",{parentName:"p"},"PriorityQueue"),"s or even other\n",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet"),"s!"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"ht-buckets",src:a(83287).Z,width:"1698",height:"772"})),(0,i.kt)("p",null,"During this lab, we will try out hash tables with different data structures for\neach of the buckets, and see empirically if there is an asymptotic difference\nbetween using different data structures as hash table buckets."),(0,i.kt)("p",null,"For this lab, we will be trying out ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"Stack"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayDeque")," (unfortunately, no ",(0,i.kt)("inlineCode",{parentName:"p"},"TreeSet")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"PriorityQueue")," like\nthe diagram above shows due to excessive boilerplate, though you're welcome to\ntry it if you'd like). That's a lot of classes!"),(0,i.kt)("p",null,"You can imagine that if we implemented ",(0,i.kt)("inlineCode",{parentName:"p"},"MyHashMap")," without much care, it would\ntake a lot of effort with Find + Replace to be able to change out the bucket\ntype with a different bucket type. For example, if we wanted to change all our\n",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList")," buckets to ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList")," buckets, we would have to Find + Replace for\nall occurrences of ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList")," and replace that with ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList"),". This is not\nideal - for example, we may have a non-bucket component that relies on some\n",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList")," methods. We wouldn't want to ruin our code by changing that to a\n",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList"),"!"),(0,i.kt)("p",null,"The purpose of the starter code is to have an easier way to try out different\nbucket types with ",(0,i.kt)("inlineCode",{parentName:"p"},"MyHashMap"),". It accomplishes this through polymorphism and\ninheritance, which we learned about earlier this semester. It also makes use of\n",(0,i.kt)("strong",{parentName:"p"},"factory methods and classes"),", which are utility code used to create objects.\nThis is a common pattern when working with more advanced code, though the\ndetails are out-of-scope for 61B."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"MyHashMap")," implements the ",(0,i.kt)("inlineCode",{parentName:"p"},"Map61B")," interface through use of a hash table. In\nthe starter code, we give the instance variable\n",(0,i.kt)("inlineCode",{parentName:"p"},"private Collection<Node>[] buckets"),", which is the underlying data structure of\nthe hash table. Let's unpack what this code means:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"buckets")," is a ",(0,i.kt)("inlineCode",{parentName:"li"},"private")," variable in the ",(0,i.kt)("inlineCode",{parentName:"li"},"MyHashMap")," class.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"private Collection<Node>[] buckets;\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It is an array (or table) of ",(0,i.kt)("inlineCode",{parentName:"li"},"Collection<Node>")," objects, where each\n",(0,i.kt)("inlineCode",{parentName:"li"},"Collection")," of ",(0,i.kt)("inlineCode",{parentName:"li"},"Node"),"s represents a single bucket in the hash table"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Node")," is a private (nested) helper class we give that stores a single key-value\nmapping. The starter code for this class should be straightforward to\nunderstand, and should not require any modification.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"protected class Node {\n    K key;\n    V value;\n\n    Node(K k, V v) {\n        key = k;\n        value = v;\n    }\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html"},(0,i.kt)("inlineCode",{parentName:"a"},"java.util.Collection")),"\nis an interface which most data structures inherit from, and it represents a\ngroup of objects. The ",(0,i.kt)("inlineCode",{parentName:"li"},"Collection")," interface supports methods such as ",(0,i.kt)("inlineCode",{parentName:"li"},"add"),",\n",(0,i.kt)("inlineCode",{parentName:"li"},"remove"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"iterator"),". Many data structures in ",(0,i.kt)("inlineCode",{parentName:"li"},"java.util")," implement\n",(0,i.kt)("inlineCode",{parentName:"li"},"Collection"),", including ",(0,i.kt)("inlineCode",{parentName:"li"},"ArrayList"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"LinkedList"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"TreeSet"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"HashSet"),",\n",(0,i.kt)("inlineCode",{parentName:"li"},"PriorityQueue"),", and many others. Note that because these data structures\nimplement ",(0,i.kt)("inlineCode",{parentName:"li"},"Collection"),", we can assign them to a variable of static type\n",(0,i.kt)("inlineCode",{parentName:"li"},"Collection")," with polymorphism."),(0,i.kt)("li",{parentName:"ul"},"Therefore, our array of ",(0,i.kt)("inlineCode",{parentName:"li"},"Collection<Node>")," objects can be instantiated by many\ndifferent types of data structures, e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"LinkedList<Node>")," or\n",(0,i.kt)("inlineCode",{parentName:"li"},"ArrayList<Node>"),".\n",(0,i.kt)("strong",{parentName:"li"},"Make sure your buckets generalize to any Collection!")," See the below warning\nfor how to do this."),(0,i.kt)("li",{parentName:"ul"},"When creating a new ",(0,i.kt)("inlineCode",{parentName:"li"},"Collection<Node>[]")," to store in our ",(0,i.kt)("inlineCode",{parentName:"li"},"buckets")," variable,\nbe aware that in Java, you\n",(0,i.kt)("a",{parentName:"li",href:"https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#createArrays"},"cannot create an array of parameterized type"),".\n",(0,i.kt)("inlineCode",{parentName:"li"},"Collection<Node>")," is a parameterized type, because we parameterize the\n",(0,i.kt)("inlineCode",{parentName:"li"},"Collection")," class with the ",(0,i.kt)("inlineCode",{parentName:"li"},"Node")," class. Therefore, Java disallows\n",(0,i.kt)("inlineCode",{parentName:"li"},"new Collection<Node>[size]"),", for any given ",(0,i.kt)("inlineCode",{parentName:"li"},"size"),'. If you try to do this, you\nwill get a "Generic array creation" error.')),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"To get around this, you should instead create a ",(0,i.kt)("inlineCode",{parentName:"p"},"new Collection[size]"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"size")," is the\ndesired size."),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"The elements of a ",(0,i.kt)("inlineCode",{parentName:"li"},"Collection[]")," can be a collection of any\ntype, like a ",(0,i.kt)("inlineCode",{parentName:"li"},"Collection<Integer>")," or a ",(0,i.kt)("inlineCode",{parentName:"li"},"Collection<Node>"),". ",(0,i.kt)("strong",{parentName:"li"},"For our purposes,\nwe will only add elements of type ",(0,i.kt)("inlineCode",{parentName:"strong"},"Collection<Node>")," to our ",(0,i.kt)("inlineCode",{parentName:"strong"},"Collection[]"),"."))),(0,i.kt)("p",{parentName:"admonition"},"The mechanism by which different implementations of the hash table implement\ndifferent buckets is through a factory method\n",(0,i.kt)("inlineCode",{parentName:"p"},"protected Collection<Node> createBucket()"),", which simply returns a\n",(0,i.kt)("inlineCode",{parentName:"p"},"Collection"),". For ",(0,i.kt)("inlineCode",{parentName:"p"},"MyHashMap.java"),", you can choose any data structure you'd\nlike. For example, if you choose ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList"),", the body of ",(0,i.kt)("inlineCode",{parentName:"p"},"createBucket")," would\nsimply be:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"protected Collection<Node> createBucket() {\n    return new LinkedList<>();\n}\n"))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Instead of creating new bucket data structures with the ",(0,i.kt)("inlineCode",{parentName:"strong"},"new")," operator, you\nmust use the ",(0,i.kt)("inlineCode",{parentName:"strong"},"createBucket")," method instead"),". This might seem useless at first,\nbut it allows our factory classes to override the ",(0,i.kt)("inlineCode",{parentName:"p"},"createBucket")," method in order\nto provide different data structures as each of the buckets. ",(0,i.kt)("br",null),(0,i.kt)("br",null),"\nIn ",(0,i.kt)("inlineCode",{parentName:"p"},"MyHashMap"),", you can just have this method return a new ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList")," or\n",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList"),"."),(0,i.kt)("h3",{id:"implementation-requirements"},"Implementation Requirements"),(0,i.kt)("p",null,"You should implement the following constructors:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public MyHashMap();\npublic MyHashMap(int initialCapacity);\npublic MyHashMap(int initialCapacity, double loadFactor);\n")),(0,i.kt)("p",null,"Some additional requirements for ",(0,i.kt)("inlineCode",{parentName:"p"},"MyHashMap")," are below:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Your hash map should initially have a number of buckets equal to\n",(0,i.kt)("inlineCode",{parentName:"li"},"initialCapacity"),". You should increase the size of your ",(0,i.kt)("inlineCode",{parentName:"li"},"MyHashMap")," when the\nload factor exceeds the maximum ",(0,i.kt)("inlineCode",{parentName:"li"},"loadFactor")," threshold. Recall that the\ncurrent ",(0,i.kt)("strong",{parentName:"li"},"load factor")," can be computed as ",(0,i.kt)("inlineCode",{parentName:"li"},"loadFactor = N/M"),", where ",(0,i.kt)("inlineCode",{parentName:"li"},"N")," is\nthe number of elements in the map and ",(0,i.kt)("inlineCode",{parentName:"li"},"M")," is the number of buckets. The load\nfactor represents the amount of elements per bucket, on average. If\n",(0,i.kt)("inlineCode",{parentName:"li"},"initialCapacity")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"loadFactor")," aren't given, you should set defaults\n",(0,i.kt)("inlineCode",{parentName:"li"},"initialCapacity = 16")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"loadFactor = 0.75")," (as Java's ",(0,i.kt)("a",{parentName:"li",href:"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/HashMap.html#%3Cinit%3E()"},"built-in HashMap")," does)."),(0,i.kt)("li",{parentName:"ul"},"You should handle collisions with separate chaining. You should not use any\nlibraries other than the bucket classes, ",(0,i.kt)("inlineCode",{parentName:"li"},"Collection"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"Iterator"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"Set"),", and\n",(0,i.kt)("inlineCode",{parentName:"li"},"HashSet"),". For more detail on how you should implement separate chaining, see\nthe ",(0,i.kt)("strong",{parentName:"li"},"Skeleton Code")," section above."),(0,i.kt)("li",{parentName:"ul"},"Because we use a ",(0,i.kt)("inlineCode",{parentName:"li"},"Collection<Node>[]")," for our ",(0,i.kt)("inlineCode",{parentName:"li"},"buckets"),", when implementing\n",(0,i.kt)("inlineCode",{parentName:"li"},"MyHashMap"),", you are restricted to using methods that are specified by the\n",(0,i.kt)("inlineCode",{parentName:"li"},"Collection")," interface. ",(0,i.kt)("strong",{parentName:"li"},"When you are searching for a ",(0,i.kt)("inlineCode",{parentName:"strong"},"Node")," in a ",(0,i.kt)("inlineCode",{parentName:"strong"},"Collection"),",\niterate over the ",(0,i.kt)("inlineCode",{parentName:"strong"},"Collection"),", and find the ",(0,i.kt)("inlineCode",{parentName:"strong"},"Node")," whose ",(0,i.kt)("inlineCode",{parentName:"strong"},"key")," is\n",(0,i.kt)("inlineCode",{parentName:"strong"},".equals()")," to the desired key.")),(0,i.kt)("li",{parentName:"ul"},"If the same key is inserted more than once, the value should be updated each\ntime (i.e., no ",(0,i.kt)("inlineCode",{parentName:"li"},"Node"),"s should be added). You can assume ",(0,i.kt)("inlineCode",{parentName:"li"},"null")," keys will never\nbe inserted."),(0,i.kt)("li",{parentName:"ul"},"When resizing, make sure to multiplicatively (geometrically) resize, not\nadditively (arithmetically) resize. You are ",(0,i.kt)("strong",{parentName:"li"},"not")," required to resize down."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"MyHashMap")," operations should all be constant amortized time, assuming that\nthe ",(0,i.kt)("inlineCode",{parentName:"li"},"hashCode")," of any objects inserted spread things out nicely (",(0,i.kt)("strong",{parentName:"li"},"recall: every\n",(0,i.kt)("inlineCode",{parentName:"strong"},"Object")," in Java has its own ",(0,i.kt)("inlineCode",{parentName:"strong"},"hashCode()")," method"),").")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"hashCode()")," can return a ",(0,i.kt)("em",{parentName:"p"},"negative value"),"! Java's modulo operator ",(0,i.kt)("inlineCode",{parentName:"p"},"%")," will\nreturn a negative value for negative inputs, but we need to send items to a\nbucket in the range ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},"["),(0,i.kt)("mn",{parentName:"mrow"},"0"),(0,i.kt)("mo",{parentName:"mrow",separator:"true"},","),(0,i.kt)("mi",{parentName:"mrow"},"M"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"[0, M)")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mopen"},"["),(0,i.kt)("span",{parentName:"span",className:"mord"},"0"),(0,i.kt)("span",{parentName:"span",className:"mpunct"},","),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10903em"}},"M"),(0,i.kt)("span",{parentName:"span",className:"mclose"},")"))))),". There are a myriad of ways to handle this:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"(Recommended) You can use ",(0,i.kt)("inlineCode",{parentName:"li"},"Math.floorMod()")," in place of ",(0,i.kt)("inlineCode",{parentName:"li"},"%")," for the modulo\noperation. This has a non-negative range of values, similar to Python's modulo."),(0,i.kt)("li",{parentName:"ol"},"If the resulting value after the ",(0,i.kt)("inlineCode",{parentName:"li"},"%")," operation is negative, you can add\nthe size of the array to it."),(0,i.kt)("li",{parentName:"ol"},"You can use the ",(0,i.kt)("inlineCode",{parentName:"li"},"Math.abs()")," function to convert the negative value to a\npositive value. Note that ",(0,i.kt)("span",{parentName:"li",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,i.kt)("mi",{parentName:"mrow"},"x"),(0,i.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,i.kt)("mtext",{parentName:"mrow"},"\u2009"),(0,i.kt)("mrow",{parentName:"mrow"},(0,i.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"m"),(0,i.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"o"),(0,i.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"d")),(0,i.kt)("mtext",{parentName:"mrow"},"\u2009"),(0,i.kt)("mi",{parentName:"mrow"},"m")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"|x| \\, \\mathrm{mod} \\, m")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"\u2223"),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,i.kt)("span",{parentName:"span",className:"mord"},"\u2223"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mord mathrm"},"mod")),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"m"))))),",\n",(0,i.kt)("span",{parentName:"li",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223"),(0,i.kt)("mi",{parentName:"mrow"},"x"),(0,i.kt)("mtext",{parentName:"mrow"},"\u2009"),(0,i.kt)("mrow",{parentName:"mrow"},(0,i.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"m"),(0,i.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"o"),(0,i.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"d")),(0,i.kt)("mtext",{parentName:"mrow"},"\u2009"),(0,i.kt)("mi",{parentName:"mrow"},"m"),(0,i.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"\u2223")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"|x \\, \\mathrm{mod} \\, m|")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"\u2223"),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mord mathrm"},"mod")),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"m"),(0,i.kt)("span",{parentName:"span",className:"mord"},"\u2223"))))),", and ",(0,i.kt)("span",{parentName:"li",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"x"),(0,i.kt)("mtext",{parentName:"mrow"},"\u2009"),(0,i.kt)("mrow",{parentName:"mrow"},(0,i.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"m"),(0,i.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"o"),(0,i.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"d")),(0,i.kt)("mtext",{parentName:"mrow"},"\u2009"),(0,i.kt)("mi",{parentName:"mrow"},"m")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x \\, \\mathrm{mod} \\, m")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mord mathrm"},"mod")),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"m"))))),(0,i.kt)("strong",{parentName:"li"},"are not equivalent in general"),"! We're just using the modulo operation here\nto make sure we have a valid index. We don't necessarily care too much about\nthe exact bucket the item goes into, because a good hash function should\nspread things out nicely over positive and negative numbers."),(0,i.kt)("li",{parentName:"ol"},"Option (3) but with a bitmask (don't worry if you don't know what this\nmeans). This is out-of-scope for 61B, but some of the resources do this,\nwhich is why we've put it here.")),(0,i.kt)("p",null,"{: .task}\nComplete the ",(0,i.kt)("inlineCode",{parentName:"p"},"MyHashMap")," class according to the specifications in ",(0,i.kt)("inlineCode",{parentName:"p"},"Map61B"),"\nand the guidelines above."),(0,i.kt)("h3",{id:"resources"},"Resources"),(0,i.kt)("p",null,"You may find the following resources useful"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Lecture slides:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.google.com/presentation/d/1sVRw4ec0Kq41_OSB-ix94u09WyQnHWf0YsOhlclnM0w"},"Lecture 19")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.google.com/presentation/d/1y0iOW7U3UAiO6lK3ArrVHSwDbX998Q4YDcZ_HeToL2s/"},"Lecture 20"))))),(0,i.kt)("p",null,"The following may contain antiquated code or use unfamiliar techniques, but should\nstill be useful:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ULLMap.java")," (provided), a working unordered linked list based ",(0,i.kt)("inlineCode",{parentName:"li"},"Map61B")," implementation")),(0,i.kt)("h3",{id:"testing"},"Testing"),(0,i.kt)("p",null,"You can test your implementation using ",(0,i.kt)("inlineCode",{parentName:"p"},"TestMyHashMap.java"),". Some of the tests\nare quite tricky and do weird stuff we haven't learned in 61B. The\ncomments will prove useful to see what the tests are actually doing."),(0,i.kt)("p",null,"If you've correctly implemented generic ",(0,i.kt)("inlineCode",{parentName:"p"},"Collection")," buckets, you should also be\npassing the tests in ",(0,i.kt)("inlineCode",{parentName:"p"},"TestMyHashMapBuckets.java"),". The\n",(0,i.kt)("inlineCode",{parentName:"p"},"TestMyHashMapBuckets.java")," file simply calls methods in ",(0,i.kt)("inlineCode",{parentName:"p"},"TestMyHashMap.java"),"\nfor each of the different map subclasses that implement a different bucket data\nstructure. Make sure you've correctly implemented ",(0,i.kt)("inlineCode",{parentName:"p"},"MyHashMap")," using the factory\nmethods provided (i.e., ",(0,i.kt)("inlineCode",{parentName:"p"},"createBucket"),") for ",(0,i.kt)("inlineCode",{parentName:"p"},"TestHashMapBuckets.java")," to pass."),(0,i.kt)("p",null,"If you choose to implement the additional ",(0,i.kt)("inlineCode",{parentName:"p"},"remove"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"keySet"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"iterator"),"\nmethods, we provide some tests in ",(0,i.kt)("inlineCode",{parentName:"p"},"TestHashMapExtra.java"),"."),(0,i.kt)("h2",{id:"speed-testing"},"Speed Testing"),(0,i.kt)("p",null,"There are two interactive speed tests provided in ",(0,i.kt)("inlineCode",{parentName:"p"},"InsertRandomSpeedTest.java"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"InsertInOrderSpeedTest.java"),". Do not attempt to run these tests before\nyou've completed ",(0,i.kt)("inlineCode",{parentName:"p"},"MyHashMap"),". Once you're ready, you can run the tests in\nIntelliJ."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"InsertRandomSpeedTest")," class performs tests on element-insertion speed of\nyour ",(0,i.kt)("inlineCode",{parentName:"p"},"MyHashMap"),", ",(0,i.kt)("strong",{parentName:"p"},"ULLMap")," (provided), and Java's built-in ",(0,i.kt)("strong",{parentName:"p"},"HashMap"),". It\nworks by asking the user for an input size ",(0,i.kt)("inlineCode",{parentName:"p"},"N"),", then generates ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," Strings of\nlength ",(0,i.kt)("inlineCode",{parentName:"p"},"10")," and inserts them into the maps as ",(0,i.kt)("inlineCode",{parentName:"p"},"<String, Integer>")," pairs."),(0,i.kt)("p",null,"Try it out and see how your data structure scales with ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," compared to the naive\nand industrial-strength implementations. Record your results in the provided\nfile named ",(0,i.kt)("inlineCode",{parentName:"p"},"src/results.txt"),". There is no standard format required for\nyour results, and there is no required number of data points. We expect you to\nwrite at least a sentence or two with your observations, though."),(0,i.kt)("p",null,"Now try running ",(0,i.kt)("inlineCode",{parentName:"p"},"InsertInOrderSpeedTest"),", which behaves similarly to\n",(0,i.kt)("inlineCode",{parentName:"p"},"InsertRandomSpeedTest"),", except this time the ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),"s in ",(0,i.kt)("inlineCode",{parentName:"p"},"<String, Integer>"),"\nkey-value pairs are inserted in ",(0,i.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Lexicographical_order"},"lexicographically-increasing\norder"),". Your code should be in the rough ballpark of Java's built in solution -- say,\nwithin a factor of 10 or so. What this tells us is that state-of-the-art\n",(0,i.kt)("inlineCode",{parentName:"p"},"HashMaps")," are relatively easy to implement compared to state-of-the-art\n",(0,i.kt)("inlineCode",{parentName:"p"},"TreeMaps"),". Consider this relation with ",(0,i.kt)("inlineCode",{parentName:"p"},"BSTMap"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"TreeMap")," and other data structures -\nare there certain instances where a ",(0,i.kt)("inlineCode",{parentName:"p"},"Hashmap")," might be better? Discuss this with your\npeers, and add your answer to ",(0,i.kt)("inlineCode",{parentName:"p"},"results.txt"),"."),(0,i.kt)("h2",{id:"different-bucket-types"},"Different Bucket Types"),(0,i.kt)("p",null,"If you've correctly implemented generic ",(0,i.kt)("inlineCode",{parentName:"p"},"Collection")," buckets, most of the work\nis done! We can directly compare the different data structures used to implement\nbuckets. We provide ",(0,i.kt)("inlineCode",{parentName:"p"},"speed/BucketsSpeedTest.java"),", which is an\ninteractive test that queries the user for an integer ",(0,i.kt)("inlineCode",{parentName:"p"},"L")," for the length of\nstring to use on subsequent operations. Then, in a loop, it queries the user for\nan integer ",(0,i.kt)("inlineCode",{parentName:"p"},"N"),", and runs a speed test on your ",(0,i.kt)("inlineCode",{parentName:"p"},"MyHashMap")," using different types of\nbuckets."),(0,i.kt)("p",null,"Try it out and compare how the different implementations scale with ",(0,i.kt)("inlineCode",{parentName:"p"},"N"),". Discuss\nyour results with your peers, and record your responses in ",(0,i.kt)("inlineCode",{parentName:"p"},"results.txt"),"."),(0,i.kt)("p",null,"You might notice that our implementation using ",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet"),"s as buckets searches\nfor a ",(0,i.kt)("inlineCode",{parentName:"p"},"Node")," by iterating over the entire data structure. But we know hash\ntables support more efficient lookups than that. Would our hash table speed up\nasymptotically if we were able to use a constant-time search over the ",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet"),"?\nYou do not need to implement anything new here, just discuss with your peers,\nand record your ideas in ",(0,i.kt)("inlineCode",{parentName:"p"},"results.txt"),"."),(0,i.kt)("p",null,"{: .task}\nRun the above speed tests in the ",(0,i.kt)("inlineCode",{parentName:"p"},"speed")," directory and record your results in ",(0,i.kt)("inlineCode",{parentName:"p"},"results.txt"),"."),(0,i.kt)("h2",{id:"deliverables-and-scoring"},"Deliverables and Scoring"),(0,i.kt)("p",null,"The lab is out of 5 points. There is one\nhidden test on Gradescope (that checks your ",(0,i.kt)("inlineCode",{parentName:"p"},"results.txt"),"). The rest of the\ntests are local. If you pass all the local tests and fill out the ",(0,i.kt)("inlineCode",{parentName:"p"},"results.txt"),"\nfile sufficiently, you will get full credit on Gradescope."),(0,i.kt)("p",null,"Each of the following is worth ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mfrac",{parentName:"mrow"},(0,i.kt)("mn",{parentName:"mfrac"},"5"),(0,i.kt)("mn",{parentName:"mfrac"},"11"))),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\frac{5}{11}")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1.1901em",verticalAlign:"-0.345em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mopen nulldelimiter"}),(0,i.kt)("span",{parentName:"span",className:"mfrac"},(0,i.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,i.kt)("span",{parentName:"span",className:"vlist-r"},(0,i.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8451em"}},(0,i.kt)("span",{parentName:"span",style:{top:"-2.655em"}},(0,i.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,i.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,i.kt)("span",{parentName:"span",className:"mord mtight"},(0,i.kt)("span",{parentName:"span",className:"mord mtight"},"11")))),(0,i.kt)("span",{parentName:"span",style:{top:"-3.23em"}},(0,i.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,i.kt)("span",{parentName:"span",className:"frac-line",style:{borderBottomWidth:"0.04em"}})),(0,i.kt)("span",{parentName:"span",style:{top:"-3.394em"}},(0,i.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,i.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,i.kt)("span",{parentName:"span",className:"mord mtight"},(0,i.kt)("span",{parentName:"span",className:"mord mtight"},"5"))))),(0,i.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,i.kt)("span",{parentName:"span",className:"vlist-r"},(0,i.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.345em"}},(0,i.kt)("span",{parentName:"span"}))))),(0,i.kt)("span",{parentName:"span",className:"mclose nulldelimiter"}))))))," points and corresponds to a unit test:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Generics"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"clear")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"containsKey")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"get")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"size")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"put")),(0,i.kt)("li",{parentName:"ul"},"Functionality"),(0,i.kt)("li",{parentName:"ul"},"Resizing"),(0,i.kt)("li",{parentName:"ul"},"Edge cases"),(0,i.kt)("li",{parentName:"ul"},"Buckets (all of ",(0,i.kt)("inlineCode",{parentName:"li"},"TestMyHashMapBuckets"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"results.txt")," (not tested locally, but on the Gradescope autograder)")),(0,i.kt)("p",null,"As mentioned, if you are not implementing the ",(0,i.kt)("a",{parentName:"p",href:"#optional-exercises"},"optional exercises"),",\nthrow an ",(0,i.kt)("inlineCode",{parentName:"p"},"UnsupportedOperationException"),", like below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"throw new UnsupportedOperationException(); \n")),(0,i.kt)("h2",{id:"submission"},"Submission"),(0,i.kt)("p",null,"Just as you did for the previous assignments, add, commit, then push your Lab 08\ncode to GitHub. Then, submit to Gradescope to test your code. "),(0,i.kt)("h2",{id:"optional-exercises"},"Optional Exercises"),(0,i.kt)("p",null,"These will not be graded, but you can still receive feedback with the given tests."),(0,i.kt)("p",null,"Implement the methods ",(0,i.kt)("inlineCode",{parentName:"p"},"remove(K key)")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"remove(K key, V value)"),", in your\n",(0,i.kt)("inlineCode",{parentName:"p"},"MyHashMap")," class. For an extra challenge, implement ",(0,i.kt)("inlineCode",{parentName:"p"},"keySet()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"iterator()"),"\nwithout using a second instance variable to store the set of keys."),(0,i.kt)("p",null,"For ",(0,i.kt)("inlineCode",{parentName:"p"},"remove"),", you should return ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," if the argument key does not exist in the\n",(0,i.kt)("inlineCode",{parentName:"p"},"MyHashMap"),". Otherwise, delete the key-value pair (key, value) and return the\nassociated value."))}c.isMDXComponent=!0},83287:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/ht-buckets-13ea915435e1f8f4389230e18e7d3445.png"}}]);