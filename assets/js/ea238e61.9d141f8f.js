"use strict";(self.webpackChunklearncs_set=self.webpackChunklearncs_set||[]).push([[3673],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var o=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=o.createContext({}),u=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=u(e.components);return o.createElement(l.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=u(n),m=i,h=d["".concat(l,".").concat(m)]||d[m]||c[m]||r;return n?o.createElement(h,a(a({ref:t},p),{},{components:n})):o.createElement(h,a({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,a=new Array(r);a[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:i,a[1]=s;for(var u=2;u<r;u++)a[u]=n[u];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},24191:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var o=n(87462),i=(n(67294),n(3905));const r={},a="Homework 3 Solutions | CS 61A Spring 2024",s={unversionedId:"curriculum-resource/cs61a/homework/sol-hw03",id:"curriculum-resource/cs61a/homework/sol-hw03",title:"Homework 3 Solutions | CS 61A Spring 2024",description:"Homework 3 Solutions",source:"@site/docs/curriculum-resource/cs61a/homework/sol-hw03.md",sourceDirName:"curriculum-resource/cs61a/homework",slug:"/curriculum-resource/cs61a/homework/sol-hw03",permalink:"/docs/curriculum-resource/cs61a/homework/sol-hw03",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Homework 2 Solutions | CS 61A Spring 2024",permalink:"/docs/curriculum-resource/cs61a/homework/sol-hw02"},next:{title:"Homework 4 Solutions | CS 61A Spring 2024",permalink:"/docs/curriculum-resource/cs61a/homework/sol-hw04"}},l={},u=[{value:"Homework 3 Solutions",id:"homework-3-solutions",level:2},{value:"Solution Files",id:"solution-files",level:2},{value:"Required Questions",id:"required-questions",level:2},{value:"Getting Started Videos",id:"getting-started-videos",level:2},{value:"Q1: Num Eights",id:"q1-num-eights",level:3},{value:"Q2: Digit Distance",id:"q2-digit-distance",level:3},{value:"Q3: Interleaved Sum",id:"q3-interleaved-sum",level:3},{value:"Q4: Count Coins",id:"q4-count-coins",level:3},{value:"Check Your Score Locally",id:"check-your-score-locally",level:2},{value:"Submit",id:"submit",level:2},{value:"Exam Practice",id:"exam-practice",level:2},{value:"Just For Fun Questions",id:"just-for-fun-questions",level:2},{value:"Q5: Towers of Hanoi",id:"q5-towers-of-hanoi",level:3},{value:"Q6: Anonymous Factorial",id:"q6-anonymous-factorial",level:3}],p={toc:u},d="wrapper";function c(e){let{components:t,...r}=e;return(0,i.kt)(d,(0,o.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"homework-3-solutions--cs-61a-spring-2024"},"Homework 3 Solutions | CS 61A Spring 2024"),(0,i.kt)("h2",{id:"homework-3-solutions"},"Homework 3 Solutions"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{target:"_blank",href:n(93779).Z},"hw03.zip"))),(0,i.kt)("h2",{id:"solution-files"},"Solution Files"),(0,i.kt)("p",null,"You can find the solutions in ",(0,i.kt)("a",{parentName:"p",href:"https://cs61a.org//hw/sol-hw03/hw03.py"},"hw03.py"),"."),(0,i.kt)("h2",{id:"required-questions"},"Required Questions"),(0,i.kt)("h2",{id:"getting-started-videos"},"Getting Started Videos"),(0,i.kt)("p",null,"These videos may provide some helpful direction for tackling the coding problems on this assignment."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"To see these videos, you should be logged into your berkeley.edu email.")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://youtu.be/playlist?list=PLx38hZJ5RLZceh9L8HHuBvUjozvwJSC0i"},"YouTube link")),(0,i.kt)("h3",{id:"q1-num-eights"},"Q1: Num Eights"),(0,i.kt)("p",null,"Write a recursive function ",(0,i.kt)("inlineCode",{parentName:"p"},"num_eights")," that takes a positive integer ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," and returns the number of times the digit 8 appears in ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Important:")," Use recursion; the tests will fail if you use any assignment statements or loops. (You can, however, use function definitions if you'd like.)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"def num_eights(n):\n    \"\"\"Returns the number of times 8 appears as a digit of n.\n\n    >>> num_eights(3)\n    0\n    >>> num_eights(8)\n    1\n    >>> num_eights(88888888)\n    8\n    >>> num_eights(2638)\n    1\n    >>> num_eights(86380)\n    2\n    >>> num_eights(12345)\n    0\n    >>> num_eights(8782089)\n    3\n    >>> from construct_check import check\n    >>> # ban all assignment statements\n    >>> check(HW_SOURCE_FILE, 'num_eights',\n    ...       ['Assign', 'AnnAssign', 'AugAssign', 'NamedExpr', 'For', 'While'])\n    True\n    \"\"\"\nif n % 10 == 8:\n        return 1 + num_eights(n // 10)\n    elif n < 10:\n        return 0\n    else:\n        return num_eights(n // 10)\n")),(0,i.kt)("p",null,"Use Ok to test your code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"python3 ok -q num_eights\n")),(0,i.kt)("p",null,"The equivalent iterative version of this problem might look something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"total = 0\nwhile n > 0:\n    if n % 10 == 8:\n        total = total + 1\n    n = n // 10\nreturn total\n")),(0,i.kt)("p",null,"The main idea is that we check each digit for a eight. The recursive solution is similar, except that you depend on the recursive call to count the occurences of eight in the rest of the number. Then, you add that to the number of eights you see in the current digit."),(0,i.kt)("h3",{id:"q2-digit-distance"},"Q2: Digit Distance"),(0,i.kt)("p",null,"For a given integer, the ",(0,i.kt)("em",{parentName:"p"},"digit distance")," is the sum of the absolute differences between consecutive digits. For example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The digit distance of ",(0,i.kt)("inlineCode",{parentName:"li"},"6")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"0"),"."),(0,i.kt)("li",{parentName:"ul"},"The digit distance of ",(0,i.kt)("inlineCode",{parentName:"li"},"61")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"5"),", as the absolute value of ",(0,i.kt)("inlineCode",{parentName:"li"},"6 - 1")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"5"),"."),(0,i.kt)("li",{parentName:"ul"},"The digit distance of ",(0,i.kt)("inlineCode",{parentName:"li"},"71253")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"12")," (",(0,i.kt)("inlineCode",{parentName:"li"},"6 + 1 + 3 + 2"),").")),(0,i.kt)("p",null,"Write a function that determines the digit distance of a given positive integer. You must use recursion or the tests will fail."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Hint:")," There are multiple valid ways of solving this problem! If you're stuck, try writing out an iterative solution first, and then convert your iterative solution into a recursive one.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"def digit_distance(n):\n    \"\"\"Determines the digit distance of n.\n\n    >>> digit_distance(3)\n    0\n    >>> digit_distance(777)\n    0\n    >>> digit_distance(314)\n    5\n    >>> digit_distance(31415926535)\n    32\n    >>> digit_distance(3464660003)\n    16\n    >>> from construct_check import check\n    >>> # ban all loops\n    >>> check(HW_SOURCE_FILE, 'digit_distance',\n    ...       ['For', 'While'])\n    True\n    \"\"\"\nif n < 10:\n        return 0\n    return abs(n % 10 - (n // 10) % 10) + digit_distance(n // 10)\n\n# Alternate solution 1\ndef digit_distance_alt(n):\n    def helper(prev, n):\n        if n == 0:\n            return 0\n        dist = abs(prev - n % 10)\n        return dist + helper(n % 10, n // 10)\n    return helper(n % 10, n // 10)\n\n# Alternate solution 2\ndef digit_distance_alt_2(n):\n    def helper(dist, prev, n):\n        if n == 0:\n            return dist\n        dist += abs(prev - n % 10)\n        prev = n % 10\n        n //= 10\n        return helper(dist, prev, n)\n    return helper(0, n % 10, n // 10)\n")),(0,i.kt)("p",null,"Use Ok to test your code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"python3 ok -q digit_distance\n")),(0,i.kt)("p",null,"The equivalent iterative version of the problem might look something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"def distance(n):\n    dist = 0\n    prev = n % 10\n    n //= 10\n    while n > 0:\n        dist += abs(prev - n % 10)\n        prev = n % 10\n        n //= 10\n    return dist\n")),(0,i.kt)("p",null,"The main idea is that we take each parameter in our iterative solution and define those parameters as inputs into our helper function. The recursive solution otherwise follows the same body as above, where we take the last two digits of the number, compute the distance between them, then shift the number down by one digit by calculating ",(0,i.kt)("inlineCode",{parentName:"p"},"n // 10"),"."),(0,i.kt)("p",null,"This skeleton can be simplified when implemented with recursion (see alternate solution), but reusing the above iterative body is sufficient for this problem."),(0,i.kt)("h3",{id:"q3-interleaved-sum"},"Q3: Interleaved Sum"),(0,i.kt)("p",null,"Write a function ",(0,i.kt)("inlineCode",{parentName:"p"},"interleaved_sum"),", which takes in a number ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," and two one-argument functions: ",(0,i.kt)("inlineCode",{parentName:"p"},"odd_func")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"even_func"),". It applies ",(0,i.kt)("inlineCode",{parentName:"p"},"odd_func")," to every odd number and ",(0,i.kt)("inlineCode",{parentName:"p"},"even_func")," to every even number from 1 to ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," ",(0,i.kt)("em",{parentName:"p"},"including")," ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," and returns the sum."),(0,i.kt)("p",null,"For example, executing ",(0,i.kt)("inlineCode",{parentName:"p"},"interleaved_sum(5, lambda x: x, lambda x: x * x)")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"1 + 2*2 + 3 + 4*4 + 5 = 29"),"."),(0,i.kt)("p",null,"Implement this function without using any loops or directly testing if a number is odd or even -- no modulos (",(0,i.kt)("inlineCode",{parentName:"p"},"%"),") allowed! Instead of checking whether a number is even or odd, start with 1, which you know is an odd number."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Hint: Introduce an inner helper function that takes an odd number ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," and computes an interleaved sum from ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," (including ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),").")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"def interleaved_sum(n, odd_func, even_func):\n    \"\"\"Compute the sum odd_func(1) + even_func(2) + odd_func(3) + ..., up\n    to n.\n\n    >>> identity = lambda x: x\n    >>> square = lambda x: x * x\n    >>> triple = lambda x: x * 3\n    >>> interleaved_sum(5, identity, square) # 1   + 2*2 + 3   + 4*4 + 5\n    29\n    >>> interleaved_sum(5, square, identity) # 1*1 + 2   + 3*3 + 4   + 5*5\n    41\n    >>> interleaved_sum(4, triple, square)   # 1*3 + 2*2 + 3*3 + 4*4\n    32\n    >>> interleaved_sum(4, square, triple)   # 1*1 + 2*3 + 3*3 + 4*3\n    28\n    >>> from construct_check import check\n    >>> check(HW_SOURCE_FILE, 'interleaved_sum', ['While', 'For', 'Mod']) # ban loops and %\n    True\n    \"\"\"\ndef sum_from(k):\n        if k > n:\n            return 0\n        elif k == n:\n            return odd_func(k)\n        else:\n            return odd_func(k) + even_func(k+1) + sum_from(k + 2)\n    return sum_from(1)\n")),(0,i.kt)("p",null,"Use Ok to test your code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"python3 ok -q interleaved_sum\n")),(0,i.kt)("h3",{id:"q4-count-coins"},"Q4: Count Coins"),(0,i.kt)("p",null,"Given a positive integer ",(0,i.kt)("inlineCode",{parentName:"p"},"total"),", a set of coins makes change for ",(0,i.kt)("inlineCode",{parentName:"p"},"total")," if the sum of the values of the coins is ",(0,i.kt)("inlineCode",{parentName:"p"},"total"),". Here we will use standard US Coin values: 1, 5, 10, 25. For example, the following sets make change for ",(0,i.kt)("inlineCode",{parentName:"p"},"15"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"15 1-cent coins"),(0,i.kt)("li",{parentName:"ul"},"10 1-cent, 1 5-cent coins"),(0,i.kt)("li",{parentName:"ul"},"5 1-cent, 2 5-cent coins"),(0,i.kt)("li",{parentName:"ul"},"5 1-cent, 1 10-cent coins"),(0,i.kt)("li",{parentName:"ul"},"3 5-cent coins"),(0,i.kt)("li",{parentName:"ul"},"1 5-cent, 1 10-cent coin")),(0,i.kt)("p",null,"Thus, there are 6 ways to make change for ",(0,i.kt)("inlineCode",{parentName:"p"},"15"),". Write a ",(0,i.kt)("strong",{parentName:"p"},"recursive")," function ",(0,i.kt)("inlineCode",{parentName:"p"},"count_coins")," that takes a positive integer ",(0,i.kt)("inlineCode",{parentName:"p"},"total")," and returns the number of ways to make change for ",(0,i.kt)("inlineCode",{parentName:"p"},"total")," using coins."),(0,i.kt)("p",null,"You can use either of the functions given to you:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"next_larger_coin")," will return the next larger coin denomination from the input, i.e. ",(0,i.kt)("inlineCode",{parentName:"li"},"next_larger_coin(5)")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"10"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"next_smaller_coin")," will return the next smaller coin denomination from the input, i.e. ",(0,i.kt)("inlineCode",{parentName:"li"},"next_smaller_coin(5)")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"1"),"."),(0,i.kt)("li",{parentName:"ul"},"Either function will return ",(0,i.kt)("inlineCode",{parentName:"li"},"None")," if the next coin value does not exist")),(0,i.kt)("p",null,"There are two main ways in which you can approach this problem. One way uses ",(0,i.kt)("inlineCode",{parentName:"p"},"next_larger_coin"),", and another uses ",(0,i.kt)("inlineCode",{parentName:"p"},"next_smaller_coin"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Important:")," Use recursion; the tests will fail if you use loops."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Hint:")," Refer the ",(0,i.kt)("a",{parentName:"p",href:"https://www.composingprograms.com/pages/17-recursive-functions.html#example-partitions"},"implementation")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"count_partitions")," for an example of how to count the ways to sum up to a final value with smaller parts. If you need to keep track of more than one value across recursive calls, consider writing a helper function.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'def next_larger_coin(coin):\n    """Returns the next larger coin in order.\n    >>> next_larger_coin(1)\n    5\n    >>> next_larger_coin(5)\n    10\n    >>> next_larger_coin(10)\n    25\n    >>> next_larger_coin(2) # Other values return None\n    """\n    if coin == 1:\n        return 5\n    elif coin == 5:\n        return 10\n    elif coin == 10:\n        return 25\n\ndef next_smaller_coin(coin):\n    """Returns the next smaller coin in order.\n    >>> next_smaller_coin(25)\n    10\n    >>> next_smaller_coin(10)\n    5\n    >>> next_smaller_coin(5)\n    1\n    >>> next_smaller_coin(2) # Other values return None\n    """\n    if coin == 25:\n        return 10\n    elif coin == 10:\n        return 5\n    elif coin == 5:\n        return 1\n\ndef count_coins(total):\n    """Return the number of ways to make change using coins of value of 1, 5, 10, 25.\n    >>> count_coins(15)\n    6\n    >>> count_coins(10)\n    4\n    >>> count_coins(20)\n    9\n    >>> count_coins(100) # How many ways to make change for a dollar?\n    242\n    >>> count_coins(200)\n    1463\n    >>> from construct_check import check\n    >>> # ban iteration\n    >>> check(HW_SOURCE_FILE, \'count_coins\', [\'While\', \'For\'])\n    True\n    """\ndef constrained_count(total, smallest_coin):\n        if total == 0:\n            return 1\n        if total < 0:\n            return 0\n        if smallest_coin == None:\n            return 0\n        without_coin = constrained_count(total, next_larger_coin(smallest_coin))\n        with_coin = constrained_count(total - smallest_coin, smallest_coin)\n        return without_coin + with_coin\n    return constrained_count(total, 1)\n\n    # Alternate solution: using next_smaller_coin\n    def constrained_count_small(total, largest_coin):\n        if total == 0:\n            return 1\n        if total < 0:\n            return 0\n        if largest_coin == None:\n            return 0\n        without_coin = constrained_count_small(total, next_smaller_coin(largest_coin))\n        with_coin = constrained_count_small(total - largest_coin, largest_coin)\n        return without_coin + with_coin\n    return constrained_count_small(total, 25)\n')),(0,i.kt)("p",null,"Use Ok to test your code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"python3 ok -q count_coins\n")),(0,i.kt)("p",null,"This is remarkably similar to the ",(0,i.kt)("inlineCode",{parentName:"p"},"count_partitions")," problem, with a few minor differences:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A maximum partition size is not given, so we need to create a helper function that takes in two arguments and also create another helper function to find the max coin."),(0,i.kt)("li",{parentName:"ul"},"Partition size is not linear. To get the next partition you need to call ",(0,i.kt)("inlineCode",{parentName:"li"},"next_larger_coin")," if you are counting up (i.e. from the smallest coin to the largest coin), or ",(0,i.kt)("inlineCode",{parentName:"li"},"next_smaller_coin")," if you are counting down.")),(0,i.kt)("h2",{id:"check-your-score-locally"},"Check Your Score Locally"),(0,i.kt)("p",null,"You can locally check your score on each question of this assignment by running"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"python3 ok --score\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"This does NOT submit the assignment!")," When you are satisfied with your score, submit the assignment to Gradescope to receive credit for it."),(0,i.kt)("h2",{id:"submit"},"Submit"),(0,i.kt)("p",null,"Submit this assignment by uploading any files you've edited ",(0,i.kt)("strong",{parentName:"p"},"to the appropriate Gradescope assignment.")," ",(0,i.kt)("a",{parentName:"p",href:"https://cs61a.org/lab/lab00/#submit-with-gradescope"},"Lab 00")," has detailed instructions."),(0,i.kt)("p",null,"In addition, all students who are ",(0,i.kt)("strong",{parentName:"p"},"not")," in the mega lab must complete this ",(0,i.kt)("a",{parentName:"p",href:"https://go.cs61a.org/lab-att"},"attendance form"),". Submit this form each week, whether you attend lab or missed it for a good reason. The attendance form is not required for mega section students."),(0,i.kt)("h2",{id:"exam-practice"},"Exam Practice"),(0,i.kt)("p",null,"Homework assignments will also contain prior exam-level questions for you to take a look at. These questions have no submission component; feel free to attempt them if you'd like a challenge!"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Fall 2017 MT1 Q4a: ",(0,i.kt)("a",{parentName:"li",href:"https://inst.eecs.berkeley.edu/~cs61a/fa21/exam/fa17/mt1/61a-fa17-mt1.pdf#page=5"},"Digital")),(0,i.kt)("li",{parentName:"ol"},"Summer 2018 MT1 Q5a: ",(0,i.kt)("a",{parentName:"li",href:"https://inst.eecs.berkeley.edu/~cs61a/su18/assets/pdfs/61a-su18-mt.pdf#page=5"},"Won't You Be My Neighbor?")),(0,i.kt)("li",{parentName:"ol"},"Fall 2019 Final Q6b: ",(0,i.kt)("a",{parentName:"li",href:"https://inst.eecs.berkeley.edu/~cs61a/sp21/exam/fa19/final/61a-fa19-final.pdf#page=6"},"Palindromes"))),(0,i.kt)("h2",{id:"just-for-fun-questions"},"Just For Fun Questions"),(0,i.kt)("p",null,"The questions below are out of scope for 61A. You can try them if you want an extra challenge, but they're just puzzles that are not required for the course. Almost all students will skip them, and that's fine. We will ",(0,i.kt)("strong",{parentName:"p"},"not")," be prioritizing support for these questions on Ed or during Office Hours."),(0,i.kt)("h3",{id:"q5-towers-of-hanoi"},"Q5: Towers of Hanoi"),(0,i.kt)("p",null,"A classic puzzle called the Towers of Hanoi is a game that consists of three rods, and a number of disks of different sizes which can slide onto any rod. The puzzle starts with ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," disks in a neat stack in ascending order of size on a ",(0,i.kt)("inlineCode",{parentName:"p"},"start")," rod, the smallest at the top, forming a conical shape. ",(0,i.kt)("img",{alt:"Towers of Hanoi",src:n(74938).Z,width:"677",height:"298"})," The objective of the puzzle is to move the entire stack to an ",(0,i.kt)("inlineCode",{parentName:"p"},"end")," rod, obeying the following rules:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Only one disk may be moved at a time."),(0,i.kt)("li",{parentName:"ul"},"Each move consists of taking the top (smallest) disk from one of the rods and sliding it onto another rod, on top of the other disks that may already be present on that rod."),(0,i.kt)("li",{parentName:"ul"},"No disk may be placed on top of a smaller disk.")),(0,i.kt)("p",null,"Complete the definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"move_stack"),", which prints out the steps required to move ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," disks from the ",(0,i.kt)("inlineCode",{parentName:"p"},"start")," rod to the ",(0,i.kt)("inlineCode",{parentName:"p"},"end")," rod without violating the rules. The provided ",(0,i.kt)("inlineCode",{parentName:"p"},"print_move")," function will print out the step to move a single disk from the given ",(0,i.kt)("inlineCode",{parentName:"p"},"origin")," to the given ",(0,i.kt)("inlineCode",{parentName:"p"},"destination"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Hint:")," Draw out a few games with various ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," on a piece of paper and try to find a pattern of disk movements that applies to any ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),". In your solution, take the recursive leap of faith whenever you need to move any amount of disks less than ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," from one rod to another. If you need more help, see the following hints.")),(0,i.kt)("p",null,"See the following animation of the Towers of Hanoi, found on ",(0,i.kt)("a",{parentName:"p",href:"https://commons.wikimedia.org/wiki/File:Iterative_algorithm_solving_a_6_disks_Tower_of_Hanoi.gif"},"Wikimedia")," by user ",(0,i.kt)("a",{parentName:"p",href:"https://commons.wikimedia.org/wiki/User:Trixx"},"Trixx"),"."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(82088).Z,width:"622",height:"622"})),(0,i.kt)("p",null,"The strategy used in Towers of Hanoi is to move all but the bottom disc to the second peg, then moving the bottom disc to the third peg, then moving all but the second disc from the second to the third peg."),(0,i.kt)("p",null,"One thing you don't need to worry about is collecting all the steps. ",(0,i.kt)("inlineCode",{parentName:"p"},"print"),' effectively "collects" all the results in the terminal as long as you make sure that the moves are printed in order.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'def print_move(origin, destination):\n    """Print instructions to move a disk."""\n    print("Move the top disk from rod", origin, "to rod", destination)\n\ndef move_stack(n, start, end):\n    """Print the moves required to move n disks on the start pole to the end\n    pole without violating the rules of Towers of Hanoi.\n\n    n -- number of disks\n    start -- a pole position, either 1, 2, or 3\n    end -- a pole position, either 1, 2, or 3\n\n    There are exactly three poles, and start and end must be different. Assume\n    that the start pole has at least n disks of increasing size, and the end\n    pole is either empty or has a top disk larger than the top n start disks.\n\n    >>> move_stack(1, 1, 3)\n    Move the top disk from rod 1 to rod 3\n    >>> move_stack(2, 1, 3)\n    Move the top disk from rod 1 to rod 2\n    Move the top disk from rod 1 to rod 3\n    Move the top disk from rod 2 to rod 3\n    >>> move_stack(3, 1, 3)\n    Move the top disk from rod 1 to rod 3\n    Move the top disk from rod 1 to rod 2\n    Move the top disk from rod 3 to rod 2\n    Move the top disk from rod 1 to rod 3\n    Move the top disk from rod 2 to rod 1\n    Move the top disk from rod 2 to rod 3\n    Move the top disk from rod 1 to rod 3\n    """\n    assert 1 <= start <= 3 and 1 <= end <= 3 and start != end, "Bad start/end"\nif n == 1:\n        print_move(start, end)\n    else:\n        other = 6 - start - end\n        move_stack(n-1, start, other)\n        print_move(start, end)\n        move_stack(n-1, other, end)\n')),(0,i.kt)("p",null,"Use Ok to test your code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"python3 ok -q move_stack\n")),(0,i.kt)("p",null,"To solve the Towers of Hanoi problem for ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," disks, we need to do three steps:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Move everything but the last disk (",(0,i.kt)("inlineCode",{parentName:"li"},"n-1")," disks) to someplace in the middle (not the start nor the end rod)."),(0,i.kt)("li",{parentName:"ol"},"Move the last disk (a single disk) to the end rod. This must occur after step 1 (we have to move everything above it away first)!"),(0,i.kt)("li",{parentName:"ol"},"Move everything but the last disk (the disks from step 1) from the middle on top of the end rod.")),(0,i.kt)("p",null,"We take advantage of the fact that the recursive function ",(0,i.kt)("inlineCode",{parentName:"p"},"move_stack")," is guaranteed to move ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," disks from ",(0,i.kt)("inlineCode",{parentName:"p"},"start")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"end")," while obeying the rules of Towers of Hanoi. The only thing that remains is to make sure that we have set up the playing board to make that possible."),(0,i.kt)("p",null,"Since we move a disk to end rod, we run the risk of ",(0,i.kt)("inlineCode",{parentName:"p"},"move_stack")," doing an improper move (big disk on top of small disk). But since we're moving the biggest disk possible, nothing in the ",(0,i.kt)("inlineCode",{parentName:"p"},"n-1")," disks above that is bigger. Therefore, even though we do not explicitly state the Towers of Hanoi constraints, we can still carry out the correct steps."),(0,i.kt)("p",null,"Video walkthrough:"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://youtu.be/VwynGQiCTFM"},"YouTube link")),(0,i.kt)("h3",{id:"q6-anonymous-factorial"},"Q6: Anonymous Factorial"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"This question demonstrates that it's possible to write recursive functions without assigning them a name in the global frame.")),(0,i.kt)("p",null,"The recursive factorial function can be written as a single expression by using a ",(0,i.kt)("a",{parentName:"p",href:"http://docs.python.org/py3k/reference/expressions.html#conditional-expressions"},"conditional expression"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},">>> fact = lambda n: 1 if n == 1 else mul(n, fact(sub(n, 1)))\n>>> fact(5)\n120\n")),(0,i.kt)("p",null,"However, this implementation relies on the fact (no pun intended) that ",(0,i.kt)("inlineCode",{parentName:"p"},"fact")," has a name, to which we refer in the body of ",(0,i.kt)("inlineCode",{parentName:"p"},"fact"),". To write a recursive function, we have always given it a name using a ",(0,i.kt)("inlineCode",{parentName:"p"},"def")," or assignment statement so that we can refer to the function within its own body. In this question, your job is to define ",(0,i.kt)("inlineCode",{parentName:"p"},"fact")," recursively without giving it a name!"),(0,i.kt)("p",null,"Write an expression that computes ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," factorial using only call expressions, conditional expressions, and ",(0,i.kt)("inlineCode",{parentName:"p"},"lambda")," expressions (no assignment or ",(0,i.kt)("inlineCode",{parentName:"p"},"def")," statements)."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Note:")," You are not allowed to use ",(0,i.kt)("inlineCode",{parentName:"p"},"make_anonymous_factorial")," in your return expression.")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"sub")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"mul")," functions from the ",(0,i.kt)("inlineCode",{parentName:"p"},"operator")," module are the only built-in functions required to solve this problem."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"from operator import sub, mul\n\ndef make_anonymous_factorial():\n    \"\"\"Return the value of an expression that computes factorial.\n\n    >>> make_anonymous_factorial()(5)\n    120\n    >>> from construct_check import check\n    >>> # ban any assignments or recursion\n    >>> check(HW_SOURCE_FILE, 'make_anonymous_factorial',\n    ...     ['Assign', 'AnnAssign', 'AugAssign', 'NamedExpr', 'FunctionDef', 'Recursion'])\n    True\n    \"\"\"\nreturn (lambda f: lambda k: f(f, k))(lambda f, k: k if k == 1 else mul(k, f(f, sub(k, 1))))\n    # Alternate solution:\n    #   return (lambda f: f(f))(lambda f: lambda x: 1 if x == 0 else x * f(f)(x - 1))\n")),(0,i.kt)("p",null,"Use Ok to test your code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"python3 ok -q make_anonymous_factorial\n")))}c.isMDXComponent=!0},93779:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/files/hw03-9a35aac45e1f1fce1eed9027452bed2c.zip"},82088:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/Iterative_algorithm_solving_a_6_disks_Tower_of_Hanoi-2cd081139c909c3938b15afd8364bd37.gif"},74938:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/Tower_of_Hanoi-d312f70e33eba788eb2678a109f4b698.jpeg"}}]);