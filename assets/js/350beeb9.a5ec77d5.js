"use strict";(self.webpackChunklearncs_set=self.webpackChunklearncs_set||[]).push([[1707],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},h="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),h=d(n),u=o,m=h["".concat(s,".").concat(u)]||h[u]||c[u]||r;return n?a.createElement(m,i(i({ref:t},p),{},{components:n})):a.createElement(m,i({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[h]="string"==typeof e?e:o,i[1]=l;for(var d=2;d<r;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},35620:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var a=n(87462),o=(n(67294),n(3905));const r={title:"Lab 07 LLRBs"},i=void 0,l={unversionedId:"curriculum-resource/cs61b/labs/lab07/index",id:"curriculum-resource/cs61b/labs/lab07/index",title:"Lab 07 LLRBs",description:"FAQ",source:"@site/docs/curriculum-resource/cs61b/labs/lab07/index.md",sourceDirName:"curriculum-resource/cs61b/labs/lab07",slug:"/curriculum-resource/cs61b/labs/lab07/",permalink:"/docs/curriculum-resource/cs61b/labs/lab07/",draft:!1,tags:[],version:"current",frontMatter:{title:"Lab 07 LLRBs"},sidebar:"tutorialSidebar",previous:{title:"FAQ",permalink:"/docs/curriculum-resource/cs61b/labs/lab06/faq"},next:{title:"FAQ",permalink:"/docs/curriculum-resource/cs61b/labs/lab07/faq"}},s={},d=[{value:"FAQ",id:"faq",level:2},{value:"Before You Begin",id:"before-you-begin",level:2},{value:"Learning Goals",id:"learning-goals",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Links vs Nodes",id:"links-vs-nodes",level:3},{value:"Left-Leaning Red-Black Trees",id:"left-leaning-red-black-trees",level:2},{value:"LLRB Tree Properties",id:"llrb-tree-properties",level:3},{value:"Inserting Into LLRB Trees",id:"inserting-into-llrb-trees",level:2},{value:"Invariant: If a node has one red child, it must be on the left",id:"invariant-if-a-node-has-one-red-child-it-must-be-on-the-left",level:3},{value:"Invariant: No node can have two red children",id:"invariant-no-node-can-have-two-red-children",level:3},{value:"Invariant: No red node can have a red parent (every red node\u2019s parent is black)",id:"invariant-no-red-node-can-have-a-red-parent-every-red-nodes-parent-is-black",level:3},{value:"Two consecutive left-leaning red nodes.",id:"two-consecutive-left-leaning-red-nodes",level:4},{value:"Red node with a right-leaning red child/node.",id:"red-node-with-a-right-leaning-red-childnode",level:4},{value:"Upward Propagation",id:"upward-propagation",level:4},{value:"LLRB Insertion Summary",id:"llrb-insertion-summary",level:3},{value:"LLRB Tree Implementation",id:"llrb-tree-implementation",level:2},{value:"Exercise: Color Flip",id:"exercise-color-flip",level:3},{value:"Exercise: Rotations",id:"exercise-rotations",level:3},{value:"Exercise: <code>insert</code>",id:"exercise-insert",level:3},{value:"Testing",id:"testing",level:2},{value:"Deliverables",id:"deliverables",level:2}],p={toc:d},h="wrapper";function c(e){let{components:t,...r}=e;return(0,o.kt)(h,(0,a.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"faq"},"FAQ"),(0,o.kt)("p",null,"The FAQ for this lab can be found ",(0,o.kt)("a",{parentName:"p",href:"/docs/curriculum-resource/cs61b/labs/lab07/faq"},"here"),"."),(0,o.kt)("h2",{id:"before-you-begin"},"Before You Begin"),(0,o.kt)("p",null,"As usual, pull the Lab 07 files from the ",(0,o.kt)("inlineCode",{parentName:"p"},"skeleton")," and open them in IntelliJ."),(0,o.kt)("h2",{id:"learning-goals"},"Learning Goals"),(0,o.kt)("p",null,"In this lab, we will be implementing left-leaning red-black trees. "),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"In the previous labs, we've analyzed the performance of algorithms for\naccess and insertion into the binary search tree. However, in some cases,\nwe've always assumed that the trees were ",(0,o.kt)("em",{parentName:"p"},"balanced")," - as we've seen,\nit's possible to produce a ",(0,o.kt)("em",{parentName:"p"},"spindly")," tree that affects the performance\nof our data structure. "),(0,o.kt)("p",null,'Informally, a tree being "balanced" means that the paths from the root to\neach leaf are all roughly the same length. Any algorithm that looks once at\neach level of the tree -- such as searching for a value in the binary search\ntree -- only looks at the number of layers. In regard to the binary search\ntree, the smallest number of layers we can have is logarithmic with respect\nto number of nodes (i.e. $$\\log N$$). '),(0,o.kt)("p",null,'To maintain this property of "balanced", we want to prevent the worst case scenario\nof obtaining a "spindly" tree, which leads to worse performance times. This is where\nbalanced search trees/b-trees come in - they are effectively self-balancing and will\nmaintain the "balanced" property that we want.'),(0,o.kt)("p",null,"However, in this lab, we won't be focusing on implementing balanced search trees - why? While\nthey do guarantee that a path from the root to any leaf is $$O(\\log N)$$, they're\nalso notoriously difficult and cumbersome to code, with numerous corner cases for\ncommon operations. They are still commonly used and provide plenty of benefits, but\nthey do have drawbacks. ",(0,o.kt)("strong",{parentName:"p"},"Keep in mind that we'll still reference balanced search trees\nthroughout this lab (any reference to a balanced search tree from here on out is a reference\nto a 2-3 tree).")),(0,o.kt)("p",null,"We then turn our attention to a related data structure: ",(0,o.kt)("strong",{parentName:"p"},"left-leaning red-black trees"),".\nWe recommend that you review the relevant lecture slides before getting started on this lab. "),(0,o.kt)("h3",{id:"links-vs-nodes"},"Links vs Nodes"),(0,o.kt)("admonition",{type:"danger"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("strong",{parentName:"p"},"Please do not skip this section. This is important for you to\nread before you continue on with the rest of the lab.")," It will be much harder for you\nif you do not read this section.")),(0,o.kt)("p",null,"In lecture, we've introduced the concept of LLRBs with ",(0,o.kt)("strong",{parentName:"p"},"links"),". However, for this lab,\nwe will not be representing our LLRBs with links. Instead, we'll be using ",(0,o.kt)("strong",{parentName:"p"},"nodes"),". The main\nreason for this is that the implementation with links ",(0,o.kt)("strong",{parentName:"p"},"is much harder")," than with nodes.\nTo cover our ground here, consider the example below of how we've introduced the visualization\nof it in lecture."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(89936).Z,width:"737",height:"535"})),(0,o.kt)("p",null,"For this lab, since we'll be handling colored nodes - the relationship between the red link\nand its connected node can be defined like below:"),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(28852).Z,width:"1560",height:"323"})),(0,o.kt)("p",null,"Originally, ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," was connected to ",(0,o.kt)("inlineCode",{parentName:"p"},"B")," by a red link. But if we use colored nodes in our representation\ninstead of links, ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," itself would be colored red. The visualization above is meant to show\nhow a red link would map to a colored node, so please keep this mind for the rest of the lab!"),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("strong",{parentName:"p"},"Be aware of the relationship between the colored link and\nthe corresponding colored node, as for the rest of the lab, we'll be using colored nodes\nin our examples and descriptions to make the lab implementation easier."))),(0,o.kt)("h2",{id:"left-leaning-red-black-trees"},"Left-Leaning Red-Black Trees"),(0,o.kt)("p",null,'At its core, LLRBs are just a binary search tree, but there are a few additional\ninvariants related to "coloring" each node red or black. This "coloring" creates\na one-to-one mapping between 2-3 trees and LLRBs! ',(0,o.kt)("strong",{parentName:"p"},"In particular, every 2-3 tree\ncorresponds to exactly one LLRB, and vice-versa.")),(0,o.kt)("p",null,"The consequence is quite astounding: LLRBs maintain the balance of\n2-3 trees while inheriting all normal binary search tree operations\nwith additional housekeeping."),(0,o.kt)("h3",{id:"llrb-tree-properties"},"LLRB Tree Properties"),(0,o.kt)("p",null,"We now specify some properties of LLRB trees. In particular, we\nuse the one-to-one mapping between valid LLRB trees and 2-3\ntrees to derive some of these properties."),(0,o.kt)("p",null,"Using colored nodes as our representation, the root node must be colored black.\n: Our interpretation of red nodes is that they are in the same 2-3 node as\ntheir parent. The root node has no parent, so it cannot be red."),(0,o.kt)("p",null,"If a node has one red child, it must be on the left.\n: This makes the tree left-leaning."),(0,o.kt)("p",null,"No node can have two red children.\n: If a node has two red children, then both children are in the same 2-3 node\nas the parent. This means that the corresponding 2-3 node contains 3 keys,\nwhich is not allowed."),(0,o.kt)("p",null,"No red node can have a red parent (every red node's parent is black).\n: If a red node has a red parent, then both the red child and red parent are in\nthe same 2-3 node as the red parent's parent. This means that the\ncorresponding 2-3 node contains 3 keys, which is not allowed."),(0,o.kt)("p",null,"In a balanced LLRB tree, every path to a null reference goes through the same number of black nodes.\n: In a balanced 2-3 tree, every null node is the same distance from the root.\nWe also know that every black node in an LLRB tree corresponds to exactly one\nnode in the equivalent 2-3 tree. Therefore, every null node in an LLRB tree\nis the same number of black nodes from the root."),(0,o.kt)("h2",{id:"inserting-into-llrb-trees"},"Inserting Into LLRB Trees"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Insertion into LLRB trees starts off with the regular binary search tree\ninsertion algorithm"),", where we search to find the appropriate leaf location."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("strong",{parentName:"p"},"Whenever we insert a node into a LLRB, we insert it as a red node."))),(0,o.kt)("p",null,"However, once we've placed the node, this can can break the LLRB\ninvariants, so we need additional operations that can \"restore\" LLRB properties.\nWe know that there is a one-to-one correspondence of valid\nLLRB to 2-3 trees. Let's use this correspondence to try to derive\nthese operations."),(0,o.kt)("p",null,"We'll cover different cases when our invariants are broken and the appropriate\noperations to fix them. "),(0,o.kt)("h3",{id:"invariant-if-a-node-has-one-red-child-it-must-be-on-the-left"},"Invariant: If a node has one red child, it must be on the left"),(0,o.kt)("p",null,"As mentioned, our inserted node will be red. Let's say we insert our node into our\nLLRB and it ends up as a ",(0,o.kt)("strong",{parentName:"p"},"right child")," of node ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," (this implies that the value in our\nnode is greater than ",(0,o.kt)("inlineCode",{parentName:"p"},"a"),"). ",(0,o.kt)("strong",{parentName:"p"},"Let's assume that the left child of node ",(0,o.kt)("inlineCode",{parentName:"strong"},"a")," is black or\ndoesn't exist."),' This breaks our invariant, where "If a node has one red\nchild, it must be on the left". Since we can\'t have any red-leaning nodes, we\nwould want to ',(0,o.kt)("strong",{parentName:"p"},"rotate left")," on the parent node. An example is shown below:"),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(75182).Z,width:"1451",height:"728"}),'{: style="max-height: 250px;" }'),(0,o.kt)("h3",{id:"invariant-no-node-can-have-two-red-children"},"Invariant: No node can have two red children"),(0,o.kt)("p",null,"Let's consider another case. Similar to above, we insert our node into the LLRB\nas a red node, and it ends up as the ",(0,o.kt)("strong",{parentName:"p"},"right child")," of node ",(0,o.kt)("inlineCode",{parentName:"p"},"b")," (in this example).\nWhat happens when node ",(0,o.kt)("inlineCode",{parentName:"p"},"b"),'\'s left child is a red node? This then breaks the invariant\nof "No node can have two red children". We then perform the operation\n"color flip" on the parent. Here, we apply the color flip operation on ',(0,o.kt)("inlineCode",{parentName:"p"},"b"),",\nflipping its color and its childrens' colors."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(31690).Z,width:"2279",height:"886"}),'{: style="max-height: 250px;" }'),(0,o.kt)("p",null,"We will return to this configuration later."),(0,o.kt)("h3",{id:"invariant-no-red-node-can-have-a-red-parent-every-red-nodes-parent-is-black"},"Invariant: No red node can have a red parent (every red node\u2019s parent is black)"),(0,o.kt)("p",null,"This can be broken down into two cases defined below.  "),(0,o.kt)("h4",{id:"two-consecutive-left-leaning-red-nodes"},"Two consecutive left-leaning red nodes."),(0,o.kt)("p",null,'What happens if we insert our node and it ends up as a left child of a red node?\nIn this case, we then want to adjust our operation and "rotate right" (',(0,o.kt)("strong",{parentName:"p"},"in other\nwords, it is not possible to have two left-leaning red nodes"),")."),(0,o.kt)("p",null,"Rotating right is the opposite of rotating left! It will give us back the\noriginal subtree if applied to the new root."),(0,o.kt)("p",null,"In this case, we rotate right on ",(0,o.kt)("inlineCode",{parentName:"p"},"b"),":"),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(60922).Z,width:"1757",height:"845"}),'{: style="max-height: 250px;" }'),(0,o.kt)("p",null,"At this point, we notice that it's the same pattern as the previous case, so\nwe apply a color flip to ",(0,o.kt)("inlineCode",{parentName:"p"},"a"),"."),(0,o.kt)("h4",{id:"red-node-with-a-right-leaning-red-childnode"},"Red node with a right-leaning red child/node."),(0,o.kt)("p",null,"In the other case, we might end up with our node becoming the right child of an\nalready red node. In this case, we then apply our rotate left operation. "),(0,o.kt)("p",null,"As shown below, we rotate left on ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," in this example and we get:"),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(47652).Z,width:"1444",height:"850"}),'{: style="max-height: 250px;" }'),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note that this ties into the invariant mentioned above, where we can't have a\nred-leaning right node.")," Here, we have the previous case again, so we know that we can rotate right on\n",(0,o.kt)("inlineCode",{parentName:"p"},"b")," and apply a color flip to the root, ",(0,o.kt)("inlineCode",{parentName:"p"},"x"),"."),(0,o.kt)("h4",{id:"upward-propagation"},"Upward Propagation"),(0,o.kt)("p",null,"Hold on -- notice that some of these cases we just covered have ended up in a color flip.\nWhat if the subtree we modified was a ",(0,o.kt)("em",{parentName:"p"},"right subtree"),", and the rest of the tree looked\nlike this:"),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(57399).Z,width:"893",height:"846"}),'{: style="max-height: 250px;" }'),(0,o.kt)("p",null,"Just like how pushing up a key in a 2-3 tree may result in overstuffing\nthe parent node, ",(0,o.kt)("strong",{parentName:"p"},"performing these transformations may ",(0,o.kt)("em",{parentName:"strong"},"also")," violate an LLRB\ninvariant"),", giving us one of these three cases again. We resolve\nthese cases until we either:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Do not have any broken invariants"),(0,o.kt)("li",{parentName:"ul"},"Flip the root's color")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"What this means is that performing some of these operations (color flip,\nrotate right, or rotate left) may end up breaking another invariant, resulting\nin more operations. As we try to resolve these cases, these transformations\neffectively work up the LLRB tree until we've resolved them according to the\nconditions above. ",(0,o.kt)("br",null),(0,o.kt)("br",null)," In some cases, we must remember to flip the\nroot back to black in our representation.")),(0,o.kt)("h3",{id:"llrb-insertion-summary"},"LLRB Insertion Summary"),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"This section will the most helpful for lab, as you can refer to the diagrams below\non how you would perform the three operations. Consider how you can translate the\nrotation operations and color flip operations to a problem involving nodes\nand pointer reassignments.")),(0,o.kt)("p",null,"We discussed three operations that we can use to \"fix\" the LLRB invariants\nafter inserting a node. Because it's possible to have upward propagation as mentioned above,\nlet's try to generalize our operations a little more visually (specifically for our rotations). "),(0,o.kt)("p",null,"We have two rotations, that can be used to move a right child or left child\nup into their parent's position:"),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(94960).Z,width:"1695",height:"700"}),'{: style="max-height: 250px;" }'),(0,o.kt)("p",null,"Here's a brief description of what happens when we ",(0,o.kt)("inlineCode",{parentName:"p"},"rotateRight(b)"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The root of the subtree has changed from ",(0,o.kt)("inlineCode",{parentName:"li"},"b")," to ",(0,o.kt)("inlineCode",{parentName:"li"},"a"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"a")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"b"),' have moved to the "right".'),(0,o.kt)("li",{parentName:"ul"},"The two nodes swap colors so that the new root is the same color as the old root."),(0,o.kt)("li",{parentName:"ul"},"The reorganized subtree still satisfies the binary search property.")),(0,o.kt)("p",null,"Here's a brief description of what happens when we ",(0,o.kt)("inlineCode",{parentName:"p"},"rotateLeft(a)"),": "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The root of the subtree has changed from ",(0,o.kt)("inlineCode",{parentName:"li"},"a")," to ",(0,o.kt)("inlineCode",{parentName:"li"},"b"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"a")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"b"),' have moved to the "left".'),(0,o.kt)("li",{parentName:"ul"},"The two nodes swap colors so that the new root is the same color as the old root."),(0,o.kt)("li",{parentName:"ul"},"The reorganized subtree still satisfies the binary search property.")),(0,o.kt)("p",null,"We also have the color flip operation:"),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(31690).Z,width:"2279",height:"886"}),'{: style="max-height: 250px;" }'),(0,o.kt)("h2",{id:"llrb-tree-implementation"},"LLRB Tree Implementation"),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("strong",{parentName:"p"},"Have you read this ",(0,o.kt)("a",{parentName:"strong",href:"#links-vs-nodes"},"section")," yet? If you haven't\ndone so, please do before you start implementing this lab."))),(0,o.kt)("p",null,"Before starting, make sure to read through the entire class, ",(0,o.kt)("inlineCode",{parentName:"p"},"RedBlackTree.java"),", especially\nthe provided nested node class. Make sure to also read the comments for each method! "),(0,o.kt)("h3",{id:"exercise-color-flip"},"Exercise: Color Flip"),(0,o.kt)("p",null,"Let's first consider the color flip operation that is essential to LLRB tree\nimplementation. Given a node, this operation simply flips its color and\nthe children's colors."),(0,o.kt)("p",null,":::task\nImplement the ",(0,o.kt)("inlineCode",{parentName:"p"},"flipColors")," method in ",(0,o.kt)("inlineCode",{parentName:"p"},"RedBlackTree.java"),".\n:::"),(0,o.kt)("h3",{id:"exercise-rotations"},"Exercise: Rotations"),(0,o.kt)("p",null,"We have seen that we can rotate the tree to balance it without violating the\nbinary search tree invariants. Now, will implement it ourselves!"),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("strong",{parentName:"p"},"For your implementation, make sure to swap the colors of the old root\nand the new root!")," ",(0,o.kt)("br",null),(0,o.kt)("br",null)," Hint: The two operations are symmetric.\nShould the code significantly differ? If you find yourself stuck, take\na look at the examples that are shown above!")),(0,o.kt)("p",null,":::task\nIn ",(0,o.kt)("inlineCode",{parentName:"p"},"RedBlackTree.java"),", implement ",(0,o.kt)("inlineCode",{parentName:"p"},"rotateRight")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"rotateLeft"),".\n:::"),(0,o.kt)("h3",{id:"exercise-insert"},"Exercise: ",(0,o.kt)("inlineCode",{parentName:"h3"},"insert")),(0,o.kt)("p",null,"We will now implement ",(0,o.kt)("inlineCode",{parentName:"p"},"insert")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"RedBlackTree.java"),". We have provided you\nwith some of the logic structure with comments. The first part of ",(0,o.kt)("inlineCode",{parentName:"p"},"insert"),"\nshould hand normal binary search tree insertion. You'll then want to handle\nthe different cases that causes one of the operations\n(",(0,o.kt)("inlineCode",{parentName:"p"},"rotateLeft"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"rotateRight"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"colorFlip"),") to occur. ",(0,o.kt)("strong",{parentName:"p"},"Make sure you follow\nthe steps from all the cases very carefully!")),(0,o.kt)("p",null,"Make sure to use the methods you've already implemented (",(0,o.kt)("inlineCode",{parentName:"p"},"rotateRight"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"rotateLeft"),",\n",(0,o.kt)("inlineCode",{parentName:"p"},"flipColors"),") to simplify the code writing. "),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("strong",{parentName:"p"},"The helper method ",(0,o.kt)("inlineCode",{parentName:"strong"},"isRed")," has already been provided to you in\nthe skeleton code so make sure to use it!"))),(0,o.kt)("p",null,":::task\nImplement the ",(0,o.kt)("inlineCode",{parentName:"p"},"insert")," method in ",(0,o.kt)("inlineCode",{parentName:"p"},"RedBlackTree.java"),".\n:::"),(0,o.kt)("h2",{id:"testing"},"Testing"),(0,o.kt)("p",null,"All tests have been provided to you locally. If you pass all tests in\n",(0,o.kt)("inlineCode",{parentName:"p"},"TestRedBlackTree.java"),", you will receive full credit on Gradescope.\nComments have been provided for you throughout the tests\nto help you further debug. "),(0,o.kt)("h2",{id:"deliverables"},"Deliverables"),(0,o.kt)("p",null,"Complete the following methods in ",(0,o.kt)("inlineCode",{parentName:"p"},"RedBlackTree.java"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"flipColors")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"rotateRight")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"rotateLeft")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"insert"))),(0,o.kt)("p",null,"This lab is worth 5 points."))}c.isMDXComponent=!0},31690:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/color_flip-fff5fe0f085f1a6a121ace272a70dc2b.png"},28852:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/link_to_node-cc1ccebb2d99803c0af5ced34a1f10b8.png"},89936:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/original_links-20de0e3ef8c0150c7115fd179b32a2b7.png"},75182:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/rotate_left-be9c1e8dcfe9aa972c75323d17fd677d.png"},47652:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/rotate_left2-173cd2d003e67880a264f8ab3f4f571a.png"},60922:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/rotate_right-718f1e3ea08863cebe2c2608e37ee283.png"},94960:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/rotations_summary-8489e3ff14ad54eba929429c86c747a1.png"},57399:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/upward_propagation-f93ede141d5fd5f5ce1a5d0ce728005d.png"}}]);