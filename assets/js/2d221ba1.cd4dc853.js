"use strict";(self.webpackChunklearncs_set=self.webpackChunklearncs_set||[]).push([[3742],{3905:(t,e,n)=>{n.d(e,{Zo:()=>d,kt:()=>c});var a=n(67294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function l(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},i=Object.keys(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var s=a.createContext({}),u=function(t){var e=a.useContext(s),n=e;return t&&(n="function"==typeof t?t(e):l(l({},e),t)),n},d=function(t){var e=u(t.components);return a.createElement(s.Provider,{value:e},t.children)},p="mdxType",m={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},h=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,i=t.originalType,s=t.parentName,d=o(t,["components","mdxType","originalType","parentName"]),p=u(n),h=r,c=p["".concat(s,".").concat(h)]||p[h]||m[h]||i;return n?a.createElement(c,l(l({ref:e},d),{},{components:n})):a.createElement(c,l({ref:e},d))}));function c(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var i=n.length,l=new Array(i);l[0]=h;var o={};for(var s in e)hasOwnProperty.call(e,s)&&(o[s]=e[s]);o.originalType=t,o[p]="string"==typeof t?t:r,l[1]=o;for(var u=2;u<i;u++)l[u]=n[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},99155:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var a=n(87462),r=(n(67294),n(3905));const i={title:"Project3"},l="Project 3: CS61CPU",o={unversionedId:"curriculum-resource/cs61c/projects/proj3",id:"curriculum-resource/cs61c/projects/proj3",title:"Project3",description:"Overview",source:"@site/docs/curriculum-resource/cs61c/projects/proj3.md",sourceDirName:"curriculum-resource/cs61c/projects",slug:"/curriculum-resource/cs61c/projects/proj3",permalink:"/docs/curriculum-resource/cs61c/projects/proj3",draft:!1,tags:[],version:"current",frontMatter:{title:"Project3"},sidebar:"tutorialSidebar",previous:{title:"Project2",permalink:"/docs/curriculum-resource/cs61c/projects/proj2"},next:{title:"Project4",permalink:"/docs/curriculum-resource/cs61c/projects/proj4"}},s={},u=[{value:"Overview",id:"overview",level:2},{value:"Tips and Guidelines",id:"tips-and-guidelines",level:2},{value:"alt-text",id:"alt-text",level:2},{value:"Part A: Getting Started",id:"part-a-getting-started",level:2},{value:"Task 1: Arithmetic Logic Unit (ALU)",id:"task-1-arithmetic-logic-unit-alu",level:2},{value:"ALU Testing",id:"alu-testing",level:3},{value:"Task 2: Register File (RegFile)",id:"task-2-register-file-regfile",level:2},{value:"RegFile Testing",id:"regfile-testing",level:3},{value:"Task 3: The <code>addi</code> Instruction",id:"task-3-the-addi-instruction",level:2},{value:"Info: Memory",id:"info-memory",level:3},{value:"Info: Branch Comparator",id:"info-branch-comparator",level:3},{value:"Info: Immediate Generator",id:"info-immediate-generator",level:3},{value:"Info: Processor",id:"info-processor",level:3},{value:"Info: Control Logic",id:"info-control-logic",level:3},{value:"Single Stage CPU: A Guide",id:"single-stage-cpu-a-guide",level:3},{value:"Stage 1: Instruction Fetch",id:"stage-1-instruction-fetch",level:4},{value:"Stage 2: Instruction Decode",id:"stage-2-instruction-decode",level:4},{value:"Stage 3: Execute",id:"stage-3-execute",level:4},{value:"Stage 4: Memory",id:"stage-4-memory",level:4},{value:"Stage 5: Write Back",id:"stage-5-write-back",level:4},{value:"Pipelining Your CPU",id:"pipelining-your-cpu",level:3},{value:"Testing",id:"testing",level:3},{value:"Understanding the Tests",id:"understanding-the-tests",level:4},{value:"<code>addi</code> Tests",id:"addi-tests",level:4},{value:"Part A: Submission",id:"part-a-submission",level:2},{value:"Part B",id:"part-b",level:2},{value:"Task 4: More Instructions",id:"task-4-more-instructions",level:2},{value:"The Instruction Set Architecture (ISA)",id:"the-instruction-set-architecture-isa",level:3},{value:"Info: Memory",id:"info-memory-1",level:3},{value:"Info: Branch Comparator",id:"info-branch-comparator-1",level:3},{value:"Info: Immediate Generator",id:"info-immediate-generator-1",level:3},{value:"Info: Control Logic",id:"info-control-logic-1",level:3},{value:"Info: Control Status Register (CSR)",id:"info-control-status-register-csr",level:3},{value:"Info: Processor",id:"info-processor-1",level:3},{value:"CPU Testing: Pipelined Sanity Tests",id:"cpu-testing-pipelined-sanity-tests",level:3},{value:"Task 5: Custom Tests",id:"task-5-custom-tests",level:2},{value:"Creating Custom Tests",id:"creating-custom-tests",level:3},{value:"Test Coverage",id:"test-coverage",level:3},{value:"Part B: Submission",id:"part-b-submission",level:2},{value:"Frequently Asked Questions",id:"frequently-asked-questions",level:2},{value:"Grading",id:"grading",level:2},{value:"Design Contest",id:"design-contest",level:2},{value:"Gate equivalence",id:"gate-equivalence",level:3},{value:"Longest Path",id:"longest-path",level:3},{value:"Tips",id:"tips",level:3}],d={toc:u},p="wrapper";function m(t){let{components:e,...i}=t;return(0,r.kt)(p,(0,a.Z)({},d,i,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"project-3-cs61cpu"},"Project 3: CS61CPU"),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Part A Deadline: Friday, October 16, 2020")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Part B Deadline: Sunday, November 1, 2020")),(0,r.kt)("p",null,"So you\u2019ve (hopefully) dealt with CS61Classify. But, you might be wondering, how exactly do all those ",(0,r.kt)("inlineCode",{parentName:"p"},"sw ra, 40(sp)")," instructions get executed? What\u2019s inside that mystery chip in your computer called the \u201cCPU\u201d? Welcome to Project 3!"),(0,r.kt)("p",null,"In Part A (Tasks 1-3), you\u2019ll be wiring up the ALU and RegFile for a basic RISC-V CPU, as well as implementing the CPU datapath for executing ",(0,r.kt)("inlineCode",{parentName:"p"},"addi")," instructions. In Part B (Tasks 4-5), you\u2019ll use these components (and others) to wire up a working CPU that runs actual RISC-V instructions!"),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"tips-and-guidelines"},"Tips and Guidelines"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Do not use the version of Logisim preinstalled on the Soda lab computers, as this will mess up your circuits! Use the ",(0,r.kt)("inlineCode",{parentName:"li"},"logisim-evolution.jar")," provided in your project repository."),(0,r.kt)("li",{parentName:"ul"},"You are only allowed to use Logisim\u2019s built-in blocks from the following libraries for all parts of this project: Wiring (",(0,r.kt)("strong",{parentName:"li"},"except Transistor, Transmission Gate, POR, Pull Resistor, Power, Ground, POR, Do not connect"),"), Gates, Plexers, Arithmetic (",(0,r.kt)("strong",{parentName:"li"},"except Divider"),"), Memory (",(0,r.kt)("strong",{parentName:"li"},"except RAM, Random Generator"),") Note that the use of ",(0,r.kt)("strong",{parentName:"li"},"ROM")," is allowed."),(0,r.kt)("li",{parentName:"ul"},"Save frequently and commit frequently! Try to save your code in Logisim every 5 minutes or so, and commit every time you produce a new feature, even if it is small."),(0,r.kt)("li",{parentName:"ul"},"Sanity tests for most project tasks are included with the project starter code. More information is available under the Testing section of each task."),(0,r.kt)("li",{parentName:"ul"},"See ",(0,r.kt)("a",{parentName:"li",href:"https://web.archive.org/web/20220121165045/https://inst.eecs.berkeley.edu/~cs61c/fa20/lectures/videos?ytvid=qFIPWt9Pu7I"},"this video")," for a custom tests and debugging walkthrough video"),(0,r.kt)("li",{parentName:"ul"},"Do not move the input and output pins in your circuit, since this could knock the pins out of alignment (in other words, autograder tests will fail)! Check the harness circuits, as well as ",(0,r.kt)("inlineCode",{parentName:"li"},"cpu.circ"),", to make sure your circuits fit in the testing harnesses."),(0,r.kt)("li",{parentName:"ul"},"You may make new subcircuits, but they must be located in the files given in the starter code. You may not make new ",(0,r.kt)("inlineCode",{parentName:"li"},".circ")," files; the autograder will fail you if you do this!"),(0,r.kt)("li",{parentName:"ul"},"You must use unique names for each subcircuit across all ",(0,r.kt)("inlineCode",{parentName:"li"},".circ")," files. Failing to do this will result in reduced autograder points. You may not change the names of any circuits provided in the starter files."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},".circ")," files use the XML format, which makes it hard for Git to automerge. We recommend working on a single computer at a time; if you use multiple computers, make sure that you have pushed and pulled your code before switching devices."),(0,r.kt)("li",{parentName:"ul"},"Your submission must be reasonably efficient: It should not take a very long time to run a single test."),(0,r.kt)("li",{parentName:"ul"},"We recommend completing Lab 05 before starting on Part A of the project and Lab 06 before starting on Part B of this project. Both labs cover many Logisim basics that will be useful for the respective parts of the project."),(0,r.kt)("li",{parentName:"ul"},"A Logisim library reference can be found by going to ",(0,r.kt)("inlineCode",{parentName:"li"},"Help->Library Reference")," within Logisim."),(0,r.kt)("li",{parentName:"ul"},"Some common sources of Logisim errors, for your debugging convenience:")),(0,r.kt)("h2",{id:"alt-text"},(0,r.kt)("img",{alt:"alt-text",src:n(50473).Z})),(0,r.kt)("h2",{id:"part-a-getting-started"},"Part A: Getting Started"),(0,r.kt)("p",null,"For this project, the computer you\u2019re working on needs be able to run Java and Python 3, which you should have set up in Project 2. This project specification will use ",(0,r.kt)("inlineCode",{parentName:"p"},"python3")," for sample commands; depending on your system, you may need to use ",(0,r.kt)("inlineCode",{parentName:"p"},"python")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"py")," instead. We will be using Logisim Evolution, a Java-based GUI program, so we strongly recommend working on a laptop or desktop with Java installed and ",(0,r.kt)("strong",{parentName:"p"},"a monitor directly attached"),". Using window forwarding over a Hive SSH session is discouraged, and may lead to instability and general headaches."),(0,r.kt)("p",null,"Please follow the directions in this Google Form to get a repository: ",(0,r.kt)("a",{parentName:"p",href:"https://web.archive.org/web/20220121165045/https://docs.google.com/forms/d/e/1FAIpQLSf6m3CjVF1IxwM6l1dTRjeAtTqwk_5974pOFvhdwCr0ZYrqDQ/viewform?usp=sf_link"},"https://docs.google.com/forms/d/e/1FAIpQLSf6m3CjVF1IxwM6l1dTRjeAtTqwk","_","5974pOFvhdwCr0ZYrqDQ/viewform?usp=sf","_","link"),". After completing the form, clone your GitHub Classroom repository and add the starter code repository as a remote:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"$ git clone YOUR_REPO_URL\n$ cd YOUR_REPO_NAME\n$ git remote add starter https://github.com/61c-teach/fa20-proj3-starter.git\n$ git pull starter master\n\n")),(0,r.kt)("p",null,"If we make changes to the starter code, you can update your repository with ",(0,r.kt)("inlineCode",{parentName:"p"},"git pull starter master"),"."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"task-1-arithmetic-logic-unit-alu"},"Task 1: Arithmetic Logic Unit (ALU)"),(0,r.kt)("p",null,"Your first task is to create an ALU that supports all the operations needed by the instructions in our ISA (which is described in further detail in the next section). Please note that we treat overflow as RISC-V does with unsigned instructions, meaning that we ignore overflow."),(0,r.kt)("p",null,"We have provided a skeleton of an ALU for you in ",(0,r.kt)("inlineCode",{parentName:"p"},"alu.circ"),". It has three inputs:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Input Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Bit Width"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"A"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Data to use for Input A in the ALU operation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"B"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Data to use for Input B in the ALU operation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ALUSel"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"Selects which operation the ALU should perform (see the list of operations with corresponding switch values below)")))),(0,r.kt)("p",null,"\u2026 and one output:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Output Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Bit Width"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Result"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Result of the ALU operation")))),(0,r.kt)("p",null,"Below is the list of ALU operations for you to implement, along with their associated ALUSel values. All of them are required. You are allowed and encouraged to use built-in Logisim blocks to implement the arithmetic operations. ",(0,r.kt)("strong",{parentName:"p"},"Please note that mulh is no longer extra credit due to the addition of a signed multiplier in Logisim which makes implementation as simple as mulhu.")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Switch Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Instruction"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"add: ",(0,r.kt)("inlineCode",{parentName:"td"},"Result = A + B"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"and: ",(0,r.kt)("inlineCode",{parentName:"td"},"Result = A & B"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"or: `Result = A")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},"xor: ",(0,r.kt)("inlineCode",{parentName:"td"},"Result = A ^ B"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"srl: ",(0,r.kt)("inlineCode",{parentName:"td"},"Result = (unsigned) A >> B"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"sra: ",(0,r.kt)("inlineCode",{parentName:"td"},"Result = (signed) A >> B"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},"sll: ",(0,r.kt)("inlineCode",{parentName:"td"},"Result = A << B"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"7"),(0,r.kt)("td",{parentName:"tr",align:null},"slt: ",(0,r.kt)("inlineCode",{parentName:"td"},"Result = (A < B (signed)) ? 1 : 0"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"8"),(0,r.kt)("td",{parentName:"tr",align:null},"Unused")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"9"),(0,r.kt)("td",{parentName:"tr",align:null},"Unused")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"10"),(0,r.kt)("td",{parentName:"tr",align:null},"mul: ",(0,r.kt)("inlineCode",{parentName:"td"},"Result = (signed) (A * B)[31:0]"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"11"),(0,r.kt)("td",{parentName:"tr",align:null},"mulhu: ",(0,r.kt)("inlineCode",{parentName:"td"},"Result = (A * B)[63:32]"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"12"),(0,r.kt)("td",{parentName:"tr",align:null},"sub: ",(0,r.kt)("inlineCode",{parentName:"td"},"Result = A - B"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"13"),(0,r.kt)("td",{parentName:"tr",align:null},"bsel: ",(0,r.kt)("inlineCode",{parentName:"td"},"Result = B"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"14"),(0,r.kt)("td",{parentName:"tr",align:null},"mulh: ",(0,r.kt)("inlineCode",{parentName:"td"},"Result = (signed) (A * B)[63:32]"))))),(0,r.kt)("p",null,"When implementing ",(0,r.kt)("inlineCode",{parentName:"p"},"mul")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"mulh"),", notice that the multiply block has a \u201cCarry Out\u201d output (the adder block also has this, but you will not need this)."),(0,r.kt)("p",null,"You can make any modifications to ",(0,r.kt)("inlineCode",{parentName:"p"},"alu.circ")," you want, but the outputs ",(0,r.kt)("strong",{parentName:"p"},"must")," obey the behavior specified above. If you create additional subcircuits, they must also be in ",(0,r.kt)("inlineCode",{parentName:"p"},"alu.circ")," (you may not make new ",(0,r.kt)("inlineCode",{parentName:"p"},".circ")," files). Additionally, your ALU ",(0,r.kt)("strong",{parentName:"p"},"must")," be able to fit in the provided harness ",(0,r.kt)("inlineCode",{parentName:"p"},"alu_harness.circ"),". This means that you should take care not to move inputs or outputs. To verify that changes you made didn\u2019t break anything, you can open ",(0,r.kt)("inlineCode",{parentName:"p"},"alu_harness.circ")," and ensure there are no errors and that the circuit functions well."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Hints:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"add")," is already made for you; feel free to use a similar structure when implementing your other blocks."),(0,r.kt)("li",{parentName:"ul"},"You can hover your cursor over an input/output on a block to get more detailed information about that input/output."),(0,r.kt)("li",{parentName:"ul"},"If you want to know more details about each block, go to Help->Library Reference for more information on the block and its inputs and outputs."),(0,r.kt)("li",{parentName:"ul"},"You might find bit splitters or extenders useful when implementing ",(0,r.kt)("inlineCode",{parentName:"li"},"sra")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"srl"),"."),(0,r.kt)("li",{parentName:"ul"},"Use tunnels! They will make your wiring cleaner and easier to follow, and will reduce your chances of encountering crossed wires or unexpected errors."),(0,r.kt)("li",{parentName:"ul"},"A multiplexer (MUX) might be useful when deciding which block output you want to output. In other words, consider simply processing the input in all blocks, and then outputing the one of your choice.")),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"alu-testing"},"ALU Testing"),(0,r.kt)("p",null,"We\u2019ve provided a group of ALU sanity tests in the ",(0,r.kt)("inlineCode",{parentName:"p"},"tests/part_a/alu")," directory. Running the test runner for this group will run the ALU tests and produce output in the ",(0,r.kt)("inlineCode",{parentName:"p"},"tests/part_a/alu/student_output")," directory. As a reminder you can find a debugging walkthrough at ",(0,r.kt)("a",{parentName:"p",href:"https://web.archive.org/web/20220121165045/https://inst.eecs.berkeley.edu/~cs61c/fa20/lectures/videos?ytvid=qFIPWt9Pu7I"},"this video"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"$ python3 test_runner.py part_a alu\n\n")),(0,r.kt)("p",null,"We\u2019ve also provided ",(0,r.kt)("inlineCode",{parentName:"p"},"binary_to_hex_alu.py"),", which can interpret this output in a readable format for you. To use it, do the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"$ cd tests/part_a/alu\n$ python3 binary_to_hex_alu.py PATH_TO_OUTPUT_FILE\n\n")),(0,r.kt)("p",null,"For example, to see ",(0,r.kt)("inlineCode",{parentName:"p"},"reference_output/alu-add-ref.out")," in readable format, you would do this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"$ cd tests/part_a/alu\n$ python3 binary_to_hex_alu.py reference_output/alu-add-ref.out\n\n")),(0,r.kt)("p",null,"If you want to see the difference between your output and the reference solution, put the readable outputs into new ",(0,r.kt)("inlineCode",{parentName:"p"},".out")," files and ",(0,r.kt)("inlineCode",{parentName:"p"},"diff")," them. For example, for the ",(0,r.kt)("inlineCode",{parentName:"p"},"alu-add")," test, you would do:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"$ cd tests/part_a/alu\n$ python3 binary_to_hex_alu.py reference_output/alu-add-ref.out > reference.out\n$ python3 binary_to_hex_alu.py student_output/alu-add-student.out > student.out\n$ diff reference.out student.out\n\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"task-2-register-file-regfile"},"Task 2: Register File (RegFile)"),(0,r.kt)("p",null,"As you learned in class, RISC-V architecture has 32 registers. For this project ",(0,r.kt)("strong",{parentName:"p"},"we will implement all of them"),". To aid in debugging ",(0,r.kt)("strong",{parentName:"p"},"we have written the regfile to expose the 9 ports specified below"),". Please make sure that the values of these register are attached to the proper outputs."),(0,r.kt)("p",null,"Your RegFile should be able to write to or read from these registers specified in a given RISC-V instruction without affecting any other registers. There is one notable exception: your RegFile should NOT write to x0, even if an instruction tries. Remember that the zero register should ALWAYS have the value 0x0. You should NOT gate the clock at any point in your RegFile: the clock signal should ALWAYS connect directly to the clock input of the registers without passing through ANY combinational logic."),(0,r.kt)("p",null,"The exposed registers and their corresponding numbers are listed below."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Register Number"),(0,r.kt)("th",{parentName:"tr",align:null},"Register Name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"x0"),(0,r.kt)("td",{parentName:"tr",align:null},"x0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"x1"),(0,r.kt)("td",{parentName:"tr",align:null},"ra")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"x2"),(0,r.kt)("td",{parentName:"tr",align:null},"sp")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"x5"),(0,r.kt)("td",{parentName:"tr",align:null},"t0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"x6"),(0,r.kt)("td",{parentName:"tr",align:null},"t1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"x7"),(0,r.kt)("td",{parentName:"tr",align:null},"t2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"x8"),(0,r.kt)("td",{parentName:"tr",align:null},"s0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"x9"),(0,r.kt)("td",{parentName:"tr",align:null},"s1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"x10"),(0,r.kt)("td",{parentName:"tr",align:null},"a0")))),(0,r.kt)("p",null,"You are provided with the skeleton of a register file in ",(0,r.kt)("inlineCode",{parentName:"p"},"regfile.circ"),". The register file circuit has six inputs:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Input Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Bit Width"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Clock"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Input providing the clock. This signal can be sent into subcircuits or attached directly to the clock inputs of memory units in Logisim, but should not otherwise be gated (i.e., do not invert it, do not \u201cand\u201d it with anything, etc.).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"RegWEn"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Determines whether data is written to the register file on the next rising edge of the clock.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Read Register 1 (rs1)"),(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"Determines which register\u2019s value is sent to the Read Data 1 output, see below.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Read Register 2 (rs2)"),(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"Determines which register\u2019s value is sent to the Read Data 2 output, see below.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Write Register (rd)"),(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"Determines which register to set to the value of Write Data on the next rising edge of the clock, assuming that RegWEn is a 1.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Write Data (wb)"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Determines what data to write to the register identified by the Write Register input on the next rising edge of the clock, assuming that RegWEn is 1.")))),(0,r.kt)("p",null,"The register file also has the following outputs:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Output Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Bit Width"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rs1"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Driven with the value of the register identified by the Read Register 1 input.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Driven with the value of the register identified by the Read Register 2 input.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ra")," Value"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Always driven with the value of ",(0,r.kt)("inlineCode",{parentName:"td"},"ra")," (This is a DEBUG/TEST output.)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"sp")," Value"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Always driven with the value of ",(0,r.kt)("inlineCode",{parentName:"td"},"sp")," (This is a DEBUG/TEST output.)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"t0")," Value"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Always driven with the value of ",(0,r.kt)("inlineCode",{parentName:"td"},"t0")," (This is a DEBUG/TEST output.)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"t1")," Value"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Always driven with the value of ",(0,r.kt)("inlineCode",{parentName:"td"},"t1")," (This is a DEBUG/TEST output.)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"t2")," Value"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Always driven with the value of ",(0,r.kt)("inlineCode",{parentName:"td"},"t2")," (This is a DEBUG/TEST output.)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"s0")," Value"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Always driven with the value of ",(0,r.kt)("inlineCode",{parentName:"td"},"s0")," (This is a DEBUG/TEST output.)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"s1")," Value"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Always driven with the value of ",(0,r.kt)("inlineCode",{parentName:"td"},"s1")," (This is a DEBUG/TEST output.)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"a0")," Value"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Always driven with the value of ",(0,r.kt)("inlineCode",{parentName:"td"},"a0")," (This is a DEBUG/TEST output.)")))),(0,r.kt)("p",null,"The test outputs at the top of your ",(0,r.kt)("inlineCode",{parentName:"p"},"regfile.circ")," file are present for testing and debugging purposes. If you were implementing a real register file, you would omit those outputs. In our case, be sure they are included correctly\u2013if they are not, you will not pass."),(0,r.kt)("p",null,"You can make any modifications to ",(0,r.kt)("inlineCode",{parentName:"p"},"regfile.circ")," you want, but the outputs must obey the behavior specified above. If you create additional subcircuits, they must also be in ",(0,r.kt)("inlineCode",{parentName:"p"},"regfile.circ")," (you may not make new ",(0,r.kt)("inlineCode",{parentName:"p"},".circ")," files). In addition, your ",(0,r.kt)("inlineCode",{parentName:"p"},"regfile.circ")," that you submit ",(0,r.kt)("strong",{parentName:"p"},"must")," fit into the ",(0,r.kt)("inlineCode",{parentName:"p"},"regfile_harness.circ")," file we have provided for you. This means that you should take care not to move inputs or outputs. To verify changes you have made didn\u2019t break anything, you can open ",(0,r.kt)("inlineCode",{parentName:"p"},"regfile_harness.circ")," and ensure there are no errors and that the circuit functions well."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Hints:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Take advantage of copy-paste! It might be a good idea to make one register completely and use it as a template for the others to avoid repetitive work."),(0,r.kt)("li",{parentName:"ul"},"I would advise you not to use the enable input on your MUXes. In fact, you can turn that feature off. I would also advise you to also turn \u201cthree-state?\u201d to off. Take a look at all the inputs to a Logisim register and see what they all do."),(0,r.kt)("li",{parentName:"ul"},"Again, MUXes are your friend, but also DeMUXes."),(0,r.kt)("li",{parentName:"ul"},"Think about what happens in the register file after a single instruction is executed. Which values change? Which values stay the same? Registers are clock-triggered\u2013what does that mean?"),(0,r.kt)("li",{parentName:"ul"},"Keep in mind registers have an \u201cenable\u201d input available, as well as a clock input."),(0,r.kt)("li",{parentName:"ul"},"What is the value of ",(0,r.kt)("inlineCode",{parentName:"li"},"x0"),"?")),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"regfile-testing"},"RegFile Testing"),(0,r.kt)("p",null,"We\u2019ve provided a group of RegFile sanity tests in the ",(0,r.kt)("inlineCode",{parentName:"p"},"tests/part_a/regfile")," directory. Running the test runner for this group will run the ALU tests and produce output in the ",(0,r.kt)("inlineCode",{parentName:"p"},"tests/part_a/regfile/student_output")," directory."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"$ python3 test_runner.py part_a regfile\n\n")),(0,r.kt)("p",null,"We\u2019ve also provided ",(0,r.kt)("inlineCode",{parentName:"p"},"binary_to_hex_regfile.py"),", which works like ",(0,r.kt)("inlineCode",{parentName:"p"},"binary_to_hex_alu.py")," from Task 1."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"task-3-the-addi-instruction"},"Task 3: The ",(0,r.kt)("inlineCode",{parentName:"h2"},"addi")," Instruction"),(0,r.kt)("p",null,"As your final task for Part A, you\u2019re going to implement a CPU that\u2019s capable of executing one instruction: ",(0,r.kt)("inlineCode",{parentName:"p"},"addi"),"! You\u2019re welcome to implement other instructions at this time, but you\u2019ll only be graded on whether or not ",(0,r.kt)("inlineCode",{parentName:"p"},"addi")," executes correctly for Part A. In Part B, there will be more detailed instructions on how to implement the other instructions."),(0,r.kt)("h3",{id:"info-memory"},"Info: Memory"),(0,r.kt)("p",null,"The Memory unit (located in ",(0,r.kt)("inlineCode",{parentName:"p"},"mem.circ"),") is already fully implemented for you and attached to the outputs of your CPU in ",(0,r.kt)("inlineCode",{parentName:"p"},"test_harness.circ"),"! The ",(0,r.kt)("inlineCode",{parentName:"p"},"addi")," instruction does NOT use the Memory unit, so you leave those ouputs undriven for Part A. Note that the supplied memory is word-addressable but ",(0,r.kt)("strong",{parentName:"p"},"byte")," level write enabled. This means that the Write","_","En signal is 4 bits wide and acts as a write mask for the input data. For example, if Write","_","En is ",(0,r.kt)("inlineCode",{parentName:"p"},"1'b1000"),", only the most significant byte of the addressed word in memory will be overwritten. The ReadData port will always return the value in memory at the supplied address, regardless of Write","_","En."),(0,r.kt)("p",null,"Here\u2019s a quick summary of its inputs and outputs:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Signal Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Direction"),(0,r.kt)("th",{parentName:"tr",align:null},"Bit Width"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"WriteAddr"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Address to read/write to in Memory")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"WriteData"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Value to be written to Memory")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Write","_","En"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"The write mask for instructions that write to Memory and zero otherwise")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CLK"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Driven by the clock input to the CPU")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ReadData"),(0,r.kt)("td",{parentName:"tr",align:null},"Output"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Value of the data stored at the specified address")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"info-branch-comparator"},"Info: Branch Comparator"),(0,r.kt)("p",null,"The Branch Comparator unit (located in ",(0,r.kt)("inlineCode",{parentName:"p"},"branch_comp.circ"),") provided in the skeleton is unimplemented, but the ",(0,r.kt)("inlineCode",{parentName:"p"},"addi")," instruction does NOT use the Branch Comparator unit, so you don\u2019t have to worry about it for Part A."),(0,r.kt)("p",null,"If you are interested, here\u2019s a quick summary of its inputs and outputs:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Signal Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Direction"),(0,r.kt)("th",{parentName:"tr",align:null},"Bit Width"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rs1"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Value in the first register to be compared")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Value in the second register to be compared")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BrUn"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Equal to one when an unsigned comparison is wanted, or zero when a signed comparison is wanted")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BrEq"),(0,r.kt)("td",{parentName:"tr",align:null},"Output"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Equal to one if the two values are equal")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BrLt"),(0,r.kt)("td",{parentName:"tr",align:null},"Output"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Equal to one if the value in rs1 is less than the value in rs2")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"info-immediate-generator"},"Info: Immediate Generator"),(0,r.kt)("p",null,"The Immediate Generator (\u201cImm Gen\u201d) unit (located in ",(0,r.kt)("inlineCode",{parentName:"p"},"imm_gen.circ"),") provided in the skeleton is unimplemented. The ",(0,r.kt)("inlineCode",{parentName:"p"},"addi")," instruction requires an immediate generator, but for now you can hard-wire it to construct the immediate for the ",(0,r.kt)("inlineCode",{parentName:"p"},"addi")," instruction, without worrying about other immediate types."),(0,r.kt)("p",null,"To edit this subcircuit, edit the ",(0,r.kt)("inlineCode",{parentName:"p"},"imm_gen.circ")," file and not the ",(0,r.kt)("inlineCode",{parentName:"p"},"imm_gen")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"cpu.circ"),". Note that if you modify this circuit, you will need to close and open ",(0,r.kt)("inlineCode",{parentName:"p"},"cpu.circ")," to load the changes in your CPU."),(0,r.kt)("p",null,"Here\u2019s a quick summary of its inputs and outputs:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Signal Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Direction"),(0,r.kt)("th",{parentName:"tr",align:null},"Bit Width"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"inst"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"The instruction being executed")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ImmSel"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},"Value determining how to reconstruct the immediate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"imm"),(0,r.kt)("td",{parentName:"tr",align:null},"Output"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Value of the immediate in the instruction")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"info-processor"},"Info: Processor"),(0,r.kt)("p",null,"We have provided a skeleton for your processor in ",(0,r.kt)("inlineCode",{parentName:"p"},"cpu.circ"),". You will be using your own implementations of the ALU and RegFile as you construct your datapath. You are responsible for constructing the entire datapath from scratch. For Part A, your completed processor should support the ",(0,r.kt)("inlineCode",{parentName:"p"},"addi")," instruction using a two-stage pipeline, with IF in the first stage and ID, EX, MEM, and WB in the second stage. To start, however, we recommend you create a single-stage processor with no pipelining. Once that is working, you can modify your processor so that it has a 2-stage pipeline."),(0,r.kt)("p",null,"Your processor will sit in a processor harness ",(0,r.kt)("inlineCode",{parentName:"p"},"test_harness.circ")," that contains the Memory unit. That processor harness then sits in a testing harness ",(0,r.kt)("inlineCode",{parentName:"p"},"run.circ")," that provides the instructions to the processor. Your process will output the address of an instruction, and accept the instruction at that address as an input. It will also output the data memory address, data memory write enable, and accept the data at that address as an input. Essentially, these two test harnesses are your data memory and instruction respectively. We recommend that you take some time to inspect ",(0,r.kt)("inlineCode",{parentName:"p"},"test_harness.circ")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"run.circ")," to see exactly what\u2019s going on. ",(0,r.kt)("inlineCode",{parentName:"p"},"test_harness.circ")," will be used in the tests provided to you for sanity checking, so make sure your CPU fits in the harness before testing and submitting your work! Your processor has 3 inputs that come from the harness:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Input Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Bit Width"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"READ","_","DATA"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Driven with the data at the data memory address identified by the WRITE","_","ADDRESS (see below).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"INSTRUCTION"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Driven with the instruction at the instruction memory address identified by the FETCH","_","ADDRESS (see below).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CLOCK"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"The input for the clock. As with the register file, this can be sent into subcircuits (e.g. the CLK input for your register file) or attached directly to the clock inputs of memory units in Logisim, but should not otherwise be gated (i.e., do not invert it, do not ",(0,r.kt)("inlineCode",{parentName:"td"},"AND")," it with anything, etc.).")))),(0,r.kt)("p",null,"Your processor must provide the following outputs to the first level harness:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Output Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Bit Width"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ra"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Driven with the contents of ",(0,r.kt)("inlineCode",{parentName:"td"},"ra")," (FOR TESTING)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sp"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Driven with the contents of ",(0,r.kt)("inlineCode",{parentName:"td"},"sp")," (FOR TESTING)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"t0"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Driven with the contents of ",(0,r.kt)("inlineCode",{parentName:"td"},"t0")," (FOR TESTING)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"t1"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Driven with the contents of ",(0,r.kt)("inlineCode",{parentName:"td"},"t1")," (FOR TESTING)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"t2"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Driven with the contents of ",(0,r.kt)("inlineCode",{parentName:"td"},"t2")," (FOR TESTING)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"s0"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Driven with the contents of ",(0,r.kt)("inlineCode",{parentName:"td"},"s0")," (FOR TESTING)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"s1"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Driven with the contents of ",(0,r.kt)("inlineCode",{parentName:"td"},"s1")," (FOR TESTING)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"a0"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Driven with the contents of ",(0,r.kt)("inlineCode",{parentName:"td"},"a0")," (FOR TESTING)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tohost"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Driven with the contents of CSR ",(0,r.kt)("inlineCode",{parentName:"td"},"0x51E")," (FOR TESTING)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"WRITE","_","ADDRESS"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"This output is used to select which address to read/write data from in data memory.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"WRITE","_","DATA"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"This output is used to provide write data to data memory.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"WRITE","_","ENABLE"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"This output is used to provide the write enable mask to data memory.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fetch","_","addr"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"This output is used to select which instruction is presented to the processor on the INSTRUCTION input.")))),(0,r.kt)("p",null,"Just like with the ALU and RegFile, be careful ",(0,r.kt)("strong",{parentName:"p"},"NOT")," to move the input or output pins! See the \u201cTesting\u201d section for more information on the harness and tests."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"info-control-logic"},"Info: Control Logic"),(0,r.kt)("p",null,"The Control Logic unit (",(0,r.kt)("inlineCode",{parentName:"p"},"control_logic.circ"),") provided in the skeleton is unimplemented. Designing your control logic unit will probably be your biggest challenge in Part B. For Part A, you can put a constant for each control signal, because ",(0,r.kt)("inlineCode",{parentName:"p"},"addi")," is the only instruction you\u2019ll be implementing. As you implement ",(0,r.kt)("inlineCode",{parentName:"p"},"addi"),", think about where you\u2019ll need to make additions in order to support other instructions."),(0,r.kt)("p",null,"To edit this subcircuit, edit the ",(0,r.kt)("inlineCode",{parentName:"p"},"control_logic.circ")," file and not the ",(0,r.kt)("inlineCode",{parentName:"p"},"control_logic")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"cpu.circ"),". Note that if you modify this circuit, you will need to close and open ",(0,r.kt)("inlineCode",{parentName:"p"},"cpu.circ")," to load the changes in your CPU."),(0,r.kt)("p",null,"You are welcome to add more inputs or outputs to the existing starter circuit as your control logic demands. You may also use as many or as few of the supplied ports as needed. That being said, please do not change or remove any of the existing ports during this process."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"single-stage-cpu-a-guide"},"Single Stage CPU: A Guide"),(0,r.kt)("p",null,"We know that trying to build a CPU with a blank slate might be intimidating, so we wrote the following guide to help you."),(0,r.kt)("p",null,"Recall the five stages of the CPU pipeline:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Instruction Fetch (IF)"),(0,r.kt)("li",{parentName:"ol"},"Instruction Decode (ID)"),(0,r.kt)("li",{parentName:"ol"},"Execute (EX)"),(0,r.kt)("li",{parentName:"ol"},"Memory (MEM)"),(0,r.kt)("li",{parentName:"ol"},"Write Back (WB)")),(0,r.kt)("p",null,"This guide will help you work through each of these stages for the ",(0,r.kt)("inlineCode",{parentName:"p"},"addi")," instruction. Each section will contain questions for you to think through and pointers to important details, but it won\u2019t tell you exactly how to implement the instruction."),(0,r.kt)("p",null,"You may need to read and understand each question before going to the next one, and you can see the answers by ",(0,r.kt)("em",{parentName:"p"},"clicking on the question"),". During your implementation, feel free to place things in subcircuits as you see fit."),(0,r.kt)("h4",{id:"stage-1-instruction-fetch"},"Stage 1: Instruction Fetch"),(0,r.kt)("p",null,"The main thing we are concerned about in this stage is: how do we get the current instruction? From lecture, we know that instructions are stored in the instruction memory, and each of these instructions can be accessed through an address."),(0,r.kt)("p",null,"1","."," Which file in the project holds your instruction memory? How does it connect to your ","`","cpu.circ","`"," file? The instruction memory is the ROM module in ","`","run.circ","`",". It provides an input into your CPU named ","`","INSTRUCTION","`"," and takes an output from your CPU. In your ","`","cpu.circ","`"," file, that output is called ","`","PROGRAM","_","COUNTER","`",". In ","`","run.circ","`",", it is called ","`","fetch","_","addr","`",". 2","."," In your CPU, how would changing the address you output as ","`","PROGRAM","_","COUNTER","`"," affect the instruction input? The instruction that ","`","run.circ","`"," outputs to your CPU should be the instruction at address ","`","PROGRAM","_","COUNTER","`"," (or ","`","fetch","_","addr","`",") in instruction memory. 3","."," How do you know what ","`","PROGRAM","_","COUNTER","`"," should be? ","`","PROGRAM","_","COUNTER","`"," is the address of the current instruction being executed, so it is saved in the PC register. For this project, your PC will start at 0, as that is the default value for a register. 4","."," For basic programs without any jumps or branches, how will the PC change from line to line? The PC must increment by 1 instruction in order to go to the next instruction, as the address held by the PC register represents what instruction to execute. This means that your PC will typically increase by 4 (assuming no branch or jump) line to line."),(0,r.kt)("p",null,"In ",(0,r.kt)("inlineCode",{parentName:"p"},"cpu.circ"),", we have provided a simple PC register implementation - ignoring jumps and branches. You will implement branches and jumps in Part B of the project, but for now we are only concerned with being able to run ",(0,r.kt)("inlineCode",{parentName:"p"},"addi")," instructions."),(0,r.kt)("p",null,"Remember that we will eventually implement a 2-stage pipelined processor, so the IF stage is separate from the remaining stages. What circuitry separates the different stages of a pipeline? Specifically, what circuitry separates IF from the next stage? Will you need to add anything?"),(0,r.kt)("h4",{id:"stage-2-instruction-decode"},"Stage 2: Instruction Decode"),(0,r.kt)("p",null,"Now that we have our instruction coming from the ",(0,r.kt)("inlineCode",{parentName:"p"},"instruction")," input, we break it down in the Instruction Decode step according to the RISC-V instruction formats you have learned."),(0,r.kt)("p",null,"1","."," What type of instruction is addi? What are the different bit fields and which bits are needed for each? I type. The fields are: - ","`","imm ","[","31-20","]","`"," - ","`","rs1 ","[","19-15","]","`"," - ","`","funct3 ","[","14-12","]","`"," - ","`","rd ","[","11-7","]","`"," - ","`","opcode ","[","6-0","]","`"," 2","."," In Logisim, what tool would you use to ",(0,r.kt)("strong",{parentName:"p"},"split")," out different groups of bits? The Splitter!"),(0,r.kt)("p",null,"3","."," Implement the instruction field decode stage using the instruction input. You should use tunnels to label and group the bits."),(0,r.kt)("p",null,"4","."," Now we need to get the data from the corresponding registers, using the register file. Which instruction fields should be connected to the register file? Which inputs of the register file should it connect to? Instruction field ","`","rs1","`"," will need to connect to read register 1."),(0,r.kt)("p",null,"5","."," Implement reading from the register file. You will have to bring in your RegFile from Part A. Remember to connect the clock!"),(0,r.kt)("p",null,"6","."," What does the Immediate Generator need to do? For addi, the immediate generator takes in 12 bits from the instruction and produces a signed 32-bit immediate. You will need to implement this logic in the Immediate Generator subcircuit!"),(0,r.kt)("h4",{id:"stage-3-execute"},"Stage 3: Execute"),(0,r.kt)("p",null,"The Execute stage is where the computation of most instructions is performed. This is also where we will introduce the idea of using a Control Module."),(0,r.kt)("p",null,"1","."," For the add instruction, what should be your inputs to the ALU? Read Data 1 (rs1) and the immediate produced by the Immediate Generator. 2","."," In the ALU, what is the purpose of ALU","_","Sel? It determines which operation the ALU will perform. 3","."," Although it is possible for now to just put a constant as the ALUSel, why would this be infeasible as you implement more instructions? With more instructions, the input to the ALU might need to change, so you will need to have some sort of circuit that changes ALUSel depending on the instruction being executed."),(0,r.kt)("p",null,"4","."," Bring in your ALU and connect the ALU inputs correctly. Do you need to connect the clock? Why or why not?"),(0,r.kt)("h4",{id:"stage-4-memory"},"Stage 4: Memory"),(0,r.kt)("p",null,"The memory stage is where the memory can be written to using store instructions and read from using load instructions. Because the ",(0,r.kt)("inlineCode",{parentName:"p"},"addi")," instruction does not use memory, we will not spend too much time here."),(0,r.kt)("p",null,"At this point, we cannot connect most of the inputs, as we don\u2019t know where they should come from."),(0,r.kt)("h4",{id:"stage-5-write-back"},"Stage 5: Write Back"),(0,r.kt)("p",null,"The write back stage is where the results of the operation is saved back to the registers."),(0,r.kt)("p",null,"1","."," Do ","`","addi","`"," instructions need to write back to a register? Yes. ","`","addi","`"," takes the output of a an addition computation in the ALU and writes it back to the register file."),(0,r.kt)("p",null,"2","."," Let's create the write back phase so that it is able to write both ALU and MEM outputs to the Register File. Later, when you implement branching/jumping, you may need to add more to this mux. However, at the moment, we need to choose between the ALU and MEM outputs, as only one wire can end up being an input to the register file. Bring a wire from both the ALU and ","`","READ","_","DATA","`",", and connect it to a MUX."),(0,r.kt)("p",null,"3","."," What should you use as the Select input to the MUX? What does the input depend on? This input should be able to choose between three MUX inputs: (1) ALU, (2) MEM ","[","`","READ","_","DATA","`","]",", and (3) PC + 4 (when will you use this?) The control signal that determines which of these inputs is written back is called WBSel. For now, there should only be one value that WBSel can take on -- whatever it should be for ","`","addi","`",". 4","."," Now that we have the inputs to the MUX sorted out, we need to wire the output. Where should the output connect to? Because the output is the data that you want to write into the Register File, it should connect to the Write Data input on the Register File."),(0,r.kt)("p",null,"5","."," There are two more inputs on the Register File which are important for writing data: RegWEn and rd. One of these will come from the Instruction Decode stage and the other one will be a new control signal that you need to design for Part B. Please finish off the Writeback stage by these inputs on the RegFile correctly."),(0,r.kt)("p",null,"If you have done all of the steps correctly, you should have a single-cycle processor that works for ",(0,r.kt)("inlineCode",{parentName:"p"},"addi")," instructions."),(0,r.kt)("p",null,"Run ",(0,r.kt)("inlineCode",{parentName:"p"},"python3 test_runner.py part_a addi_single")," and see if it\u2019s working correctly!"),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"pipelining-your-cpu"},"Pipelining Your CPU"),(0,r.kt)("p",null,"Now it\u2019s time to implement pipelining in your CPU! For this project, you\u2019ll need to implement a 2-stage pipeline, which is still conceptually similar to the 5-stage pipeline covered in lecture and discussion (review those if you haven\u2019t already). The two stages you\u2019ll implement are:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"1","."," Instruction Fetch:")," An instruction is fetched from the instruction memory."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"2","."," Execute:")," The instruction is decoded, executed, and committed (written back). This is a combination of the remaining four stages of a normal five-stage RISC-V pipeline (ID, EX, MEM and WB)."),(0,r.kt)("p",null,"Because all of the control and execution is handled in the Execute stage, ",(0,r.kt)("strong",{parentName:"p"},"your processor should be more or less indistinguishable from a single-cycle implementation, barring the one-cycle startup latency.")," However, we will be enforcing the two-stage pipeline design. Some things to consider:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Will the IF and EX stages have the same or different ",(0,r.kt)("inlineCode",{parentName:"li"},"PC")," values?"),(0,r.kt)("li",{parentName:"ul"},"Do you need to store the ",(0,r.kt)("inlineCode",{parentName:"li"},"PC")," between the pipelining stages?")),(0,r.kt)("p",null,"You might also notice a bootstrapping problem here: during the first cycle, the instruction register sitting between the pipeline stages won\u2019t contain an instruction loaded from memory. How do we deal with this? It happens that Logisim automatically sets registers to zero on reset; the instruction register will then contain a ",(0,r.kt)("inlineCode",{parentName:"p"},"nop"),". We will allow you to depend on this behavior of Logisim. Remember to go to Simulate ",(0,r.kt)("inlineCode",{parentName:"p"},"--\x3e")," Reset Simulation (Cmd + R or Ctrl + R on Windows) to reset your processor."),(0,r.kt)("p",null,"After pipelining your processor, you should be able to pass ",(0,r.kt)("inlineCode",{parentName:"p"},"python3 test_runner.py part_a addi_pipelined")," test. Note that the single-stage test will now fail, which is expected behavior (why? look back at the reference outputs for each test, and think about the effects of pipelining on different stages)."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"testing"},"Testing"),(0,r.kt)("h4",{id:"understanding-the-tests"},"Understanding the Tests"),(0,r.kt)("p",null,"Each test is a copy of the ",(0,r.kt)("inlineCode",{parentName:"p"},"run.circ")," file included with the starter code that has instructions loaded into its IMEM. When you run logisim-evolution from the command line, the clock ticks, the program counter is incremented, and the values in each of the outputs is printed to stdout."),(0,r.kt)("p",null,"Let\u2019s take as the one stage addi test as an example. It has 3 addi instructions (",(0,r.kt)("inlineCode",{parentName:"p"},"addi t0, x0, 5"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"addi t1, t0, 7"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"addi s0, t0, 9"),"). Open ",(0,r.kt)("inlineCode",{parentName:"p"},"tests/part_a/addi_pipelined/cpu-addi-pipelined.circ")," in Logisim Evolution, and take a closer look at the various parts of the test file. At the top, you\u2019ll see the place where your CPU is connected to the test outputs. With the starter code, you\u2019ll see all xxxx\u2019s, as you do below; when your CPU is working, this should not be the case. Your CPU takes in one input (instruction), and along with the values in each of the registers, it has one additional output: ",(0,r.kt)("inlineCode",{parentName:"p"},"fetch_addr"),", or the address of the instruction to be fetched from IMEM to be executed the next clock cycle."),(0,r.kt)("p",null,"Be careful that you don\u2019t move any of the inputs/outputs of your CPU around, or add any additional inputs/outputs. This will change the shape of the CPU subcircuit, and as a result the connections in the test files may no longer work properly."),(0,r.kt)("p",null,"Below the CPU, you\u2019ll see instruction memory. The hex for the 3 addi instructions (0x00500293, 0x00728313, 0x00928413) has been loaded into instruction memory. Instruction memory takes in one input (called ",(0,r.kt)("inlineCode",{parentName:"p"},"fetch_addr"),") and outputs the instruction at that address. ",(0,r.kt)("inlineCode",{parentName:"p"},"fetch_addr")," is a 32-bit value, but because Logisim Evolution caps the size of ROM units at 2^16B, we have to use a splitter to get only 14 bits from ",(0,r.kt)("inlineCode",{parentName:"p"},"fetch_addr")," (ignoring the bottommost two bits). Notice that ",(0,r.kt)("inlineCode",{parentName:"p"},"fetch_addr")," is a ",(0,r.kt)("strong",{parentName:"p"},"byte address"),", not a word address."),(0,r.kt)("p",null,"So what happens when the clock ticks? Each tick of the clock increments an input in the test file called ",(0,r.kt)("inlineCode",{parentName:"p"},"Time_Step"),". The clock will continue to tick until ",(0,r.kt)("inlineCode",{parentName:"p"},"Time_Step")," is equal to the halting constant for that test file (for this particular test file, the halting constant is 5). At that point, the Logisim Evolution command line will print the values in each of your outputs to stdout. Our tests will compare this output to the expected; if your output is different, you will fail the test."),(0,r.kt)("h4",{id:"addi-tests"},(0,r.kt)("inlineCode",{parentName:"h4"},"addi")," Tests"),(0,r.kt)("p",null,"We\u2019ve included 2 tests for the ",(0,r.kt)("inlineCode",{parentName:"p"},"addi")," instruction with the starter code: one for a single-cycle CPU and one for a pipelined CPU. You can run the pipelined tests with the following commands (replace ",(0,r.kt)("inlineCode",{parentName:"p"},"pipelined")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"single")," for single-cycle tests):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"$ python3 test_runner.py part_a addi_pipelined # For a pipelined CPU\n\n")),(0,r.kt)("p",null,"You can see the ",(0,r.kt)("inlineCode",{parentName:"p"},".s")," (RISC-V) and ",(0,r.kt)("inlineCode",{parentName:"p"},".hex")," (machine code) files for the test in ",(0,r.kt)("inlineCode",{parentName:"p"},"tests/part_a/addi_pipelined/inputs"),"."),(0,r.kt)("p",null,"We\u2019ve included a Python script to interpret your output: ",(0,r.kt)("inlineCode",{parentName:"p"},"binary_to_hex_cpu.py"),", which works like ",(0,r.kt)("inlineCode",{parentName:"p"},"binary_to_hex_alu.py")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"binary_to_hex_regfile.py")," from the previous tasks. To use the script to see your CPU\u2019s output, run:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"$ cd tests/part_a/addi_pipelined\n$ python3 binary_to_hex_cpu.py student_output/CPU-addi-pipelined-student.out\n\n")),(0,r.kt)("p",null,"or, to see the reference output, run:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"$ cd tests/part_a/addi_pipelined\n$ python3 binary_to_hex_cpu.py reference_output/CPU-addi-pipelined-ref.out\n\n")),(0,r.kt)("p",null,"As a reminder you can find a debugging walkthrough at ",(0,r.kt)("a",{parentName:"p",href:"https://web.archive.org/web/20220121165045/https://inst.eecs.berkeley.edu/~cs61c/fa20/lectures/videos?ytvid=qFIPWt9Pu7I"},"this video"),"."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"part-a-submission"},"Part A: Submission"),(0,r.kt)("p",null,"At this point, if you\u2019ve completed tasks 1-3, you\u2019ve finished Part A of the project!"),(0,r.kt)("p",null,"Double-check that you have not moved your input/output pins, and that your circuits fit in the provided testing harnesses. Make sure that you did not create any additional ",(0,r.kt)("inlineCode",{parentName:"p"},".circ")," files; the autograder will only be testing the circuit files you needed to edit in the starter code (",(0,r.kt)("inlineCode",{parentName:"p"},"alu.circ"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"branch_comp.circ"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"control_logic.circ"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"cpu.circ"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"imm_gen.circ"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"regfile.circ"),")."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Your last bit of work before you submit is to write down how you implemented components for this part of the project readme.md. There is already a template for you to use and don\u2019t worry about going into too much detail, we just want you to reflect on what you did in this part and explain the reasoning behind the design choices you made! You must also document the breakdown of labor between you and your partner! Tell us who did what in both implementation and design.")),(0,r.kt)("p",null,"Submit your repo to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Project 3A")," assignment on Gradescope."),(0,r.kt)("p",null,"The autograder for Part A uses the same tests as the test files provided in the starter code."),(0,r.kt)("p",null,"The rest of this spec describes the tasks for Part B."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"part-b"},"Part B"),(0,r.kt)("h2",{id:"task-4-more-instructions"},"Task 4: More Instructions"),(0,r.kt)("p",null,"In Task 3, you wired up a basic pipelined CPU capable of executing ",(0,r.kt)("inlineCode",{parentName:"p"},"addi")," instructions. Now, you\u2019ll implement support for more instructions!"),(0,r.kt)("h3",{id:"the-instruction-set-architecture-isa"},"The Instruction Set Architecture (ISA)"),(0,r.kt)("p",null,"We will be grading your CPU implementation on ",(0,r.kt)("strong",{parentName:"p"},"only")," the instructions listed below. Your CPU must support these instructions, but feel free to implement any additional instructions you want as long as they don\u2019t affect your implementation of the required instructions. Implementing additional instructions will not affect your score."),(0,r.kt)("table",null,(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("b",null,"Instruction")),(0,r.kt)("td",null,(0,r.kt)("b",null,"Type")),(0,r.kt)("td",null,(0,r.kt)("b",null,"Opcode")),(0,r.kt)("td",null,(0,r.kt)("b",null,"Funct3")),(0,r.kt)("td",null,(0,r.kt)("b",null,"Funct7/Immediate")),(0,r.kt)("td",null,(0,r.kt)("b",null,"Operation"))),(0,r.kt)("tr",null,(0,r.kt)("td",null,"add rd, rs1, rs2"),(0,r.kt)("td",{rowspan:"12"},"R"),(0,r.kt)("td",{rowspan:"12"},"0x33"),(0,r.kt)("td",null,"0x0"),(0,r.kt)("td",null,"0x00"),(0,r.kt)("td",null,"R[rd] \u2190 R[rs1] + R[rs2]")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"mul rd, rs1, rs2"),(0,r.kt)("td",null,"0x0"),(0,r.kt)("td",null,"0x01"),(0,r.kt)("td",null,"R[rd] \u2190 (R[rs1] * R[rs2])[31:0]")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"sub rd, rs1, rs2"),(0,r.kt)("td",null,"0x0"),(0,r.kt)("td",null,"0x20"),(0,r.kt)("td",null,"R[rd] \u2190 R[rs1] - R[rs2]")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"sll rd, rs1, rs2"),(0,r.kt)("td",null,"0x1"),(0,r.kt)("td",null,"0x00"),(0,r.kt)("td",null,"R[rd] \u2190 R[rs1] << R[rs2]")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"mulh rd, rs1, rs2"),(0,r.kt)("td",null,"0x1"),(0,r.kt)("td",null,"0x01"),(0,r.kt)("td",null,"R[rd] \u2190 (R[rs1] * R [rs2])[63:32]")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"mulhu rd, rs1, rs2"),(0,r.kt)("td",null,"0x3"),(0,r.kt)("td",null,"0x01"),(0,r.kt)("td",null,"(unsigned) R[rd] \u2190 (R[rs1] * R[rs2])[63:32]")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"slt rd, rs1, rs2"),(0,r.kt)("td",null,"0x2"),(0,r.kt)("td",null,"0x00"),(0,r.kt)("td",null,"R[rd] \u2190 (R[rs1] < R[rs2]) ? 1 : 0 (signed)")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"xor rd, rs1, rs2"),(0,r.kt)("td",null,"0x4"),(0,r.kt)("td",null,"0x00"),(0,r.kt)("td",null,"R[rd] \u2190 R[rs1] ^ R[rs2]")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"srl rd, rs1, rs2"),(0,r.kt)("td",null,"0x5"),(0,r.kt)("td",null,"0x00"),(0,r.kt)("td",null,"(unsigned) R[rd] \u2190 R[rs1] >> R[rs2]")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"sra rd, rs1, rs2"),(0,r.kt)("td",null,"0x5"),(0,r.kt)("td",null,"0x20"),(0,r.kt)("td",null,"(signed) R[rd] \u2190 R[rs1] >> R[rs2]")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"or rd, rs1, rs2"),(0,r.kt)("td",null,"0x6"),(0,r.kt)("td",null,"0x00"),(0,r.kt)("td",null,"R[rd] \u2190 R[rs1] | R[rs2]")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"and rd, rs1, rs2"),(0,r.kt)("td",null,"0x7"),(0,r.kt)("td",null,"0x00"),(0,r.kt)("td",null,"R[rd] \u2190 R[rs1] & R[rs2]")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"lb rd, offset(rs1)"),(0,r.kt)("td",{rowspan:"11"},"I"),(0,r.kt)("td",{rowspan:"3"},"0x03"),(0,r.kt)("td",null,"0x0"),(0,r.kt)("td",null),(0,r.kt)("td",null,"R[rd] \u2190 SignExt(Mem(R[rs1] + offset, byte))")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"lh rd, offset(rs1)"),(0,r.kt)("td",null,"0x1"),(0,r.kt)("td",null),(0,r.kt)("td",null,"R[rd] \u2190 SignExt(Mem(R[rs1] + offset, half))")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"lw rd, offset(rs1)"),(0,r.kt)("td",null,"0x2"),(0,r.kt)("td",null),(0,r.kt)("td",null,"R[rd] \u2190 Mem(R[rs1] + offset, word)")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"addi rd, rs1, imm"),(0,r.kt)("td",{rowspan:"8"},"0x13"),(0,r.kt)("td",null,"0x0"),(0,r.kt)("td",null),(0,r.kt)("td",null,"R[rd] \u2190 R[rs1] + imm")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"slli rd, rs1, imm"),(0,r.kt)("td",null,"0x1"),(0,r.kt)("td",null,"0x00"),(0,r.kt)("td",null,"R[rd] \u2190 R[rs1] << imm")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"slti rd, rs1, imm"),(0,r.kt)("td",null,"0x2"),(0,r.kt)("td",null),(0,r.kt)("td",null,"R[rd] \u2190 (R[rs1] < imm) ? 1 : 0")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"xori rd, rs1, imm"),(0,r.kt)("td",null,"0x4"),(0,r.kt)("td",null),(0,r.kt)("td",null,"R[rd] \u2190 R[rs1] ^ imm")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"srli rd, rs1, imm"),(0,r.kt)("td",null,"0x5"),(0,r.kt)("td",null,"0x00"),(0,r.kt)("td",null,"R[rd] \u2190 R[rs1] >> imm")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"srai rd, rs1, imm"),(0,r.kt)("td",null,"0x5"),(0,r.kt)("td",null,"0x20"),(0,r.kt)("td",null,"R[rd] \u2190 R[rs1] >> imm")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"ori rd, rs1, imm"),(0,r.kt)("td",null,"0x6"),(0,r.kt)("td",null),(0,r.kt)("td",null,"R[rd] \u2190 R[rs1] | imm")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"andi rd, rs1, imm"),(0,r.kt)("td",null,"0x7"),(0,r.kt)("td",null),(0,r.kt)("td",null,"R[rd] \u2190 R[rs1] & imm")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"sb rs2, offset(rs1)"),(0,r.kt)("td",{rowspan:"3"},"S"),(0,r.kt)("td",{rowspan:"3"},"0x23"),(0,r.kt)("td",null,"0x0"),(0,r.kt)("td",null),(0,r.kt)("td",null,"Mem(R[rs1] + offset) \u2190 R[rs2][7:0]")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"sh rs2, offset(rs1)"),(0,r.kt)("td",null,"0x1"),(0,r.kt)("td",null),(0,r.kt)("td",null,"Mem(R[rs1] + offset) \u2190 R[rs2][15:0]")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"sw rs2, offset(rs1)"),(0,r.kt)("td",null,"0x2"),(0,r.kt)("td",null),(0,r.kt)("td",null,"Mem(R[rs1] + offset) \u2190 R[rs2]")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"beq rs1, rs2, offset"),(0,r.kt)("td",{rowspan:"6"},"SB"),(0,r.kt)("td",{rowspan:"6"},"0x63"),(0,r.kt)("td",null,"0x0"),(0,r.kt)("td",null),(0,r.kt)("td",null,"if(R[rs1] == R[rs2])",(0,r.kt)("br",null),"\xa0PC \u2190 PC + ","{","offset, 1b0","}")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"bne rs1, rs2, offset"),(0,r.kt)("td",null,"0x1"),(0,r.kt)("td",null),(0,r.kt)("td",null,"if(R[rs1] != R[rs2])",(0,r.kt)("br",null),"\xa0PC \u2190 PC + ","{","offset, 1b0","}")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"blt rs1, rs2, offset"),(0,r.kt)("td",null,"0x4"),(0,r.kt)("td",null),(0,r.kt)("td",null,"if(R[rs1] < R[rs2] (signed))",(0,r.kt)("br",null),"\xa0PC \u2190 PC + ","{","offset, 1b0","}")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"bge rs1, rs2, offset"),(0,r.kt)("td",null,"0x5"),(0,r.kt)("td",null),(0,r.kt)("td",null,"if(R[rs1] >= R[rs2] (signed))",(0,r.kt)("br",null),"\xa0PC \u2190 PC + ","{","offset, 1b0","}")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"bltu rs1, rs2, offset"),(0,r.kt)("td",null,"0x6"),(0,r.kt)("td",null),(0,r.kt)("td",null,"if(R[rs1] < R[rs2] (unsigned))",(0,r.kt)("br",null),"\xa0PC \u2190 PC + ","{","offset, 1b0","}")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"bgeu rs1, rs2, offset"),(0,r.kt)("td",null,"0x7"),(0,r.kt)("td",null),(0,r.kt)("td",null,"if(R[rs1] >= R[rs2] (unsigned))",(0,r.kt)("br",null),"\xa0PC \u2190 PC + ","{","offset, 1b0","}")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"auipc rd, offset"),(0,r.kt)("td",{rowspan:"2"},"U"),(0,r.kt)("td",null,"0x17"),(0,r.kt)("td",null),(0,r.kt)("td",null),(0,r.kt)("td",null,"R[rd] \u2190 PC + ","{","offset, 12b0","}")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"lui rd, offset"),(0,r.kt)("td",null,"0x37"),(0,r.kt)("td",null),(0,r.kt)("td",null),(0,r.kt)("td",null,"R[rd] \u2190 ","{","offset, 12b0","}")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"jal rd, imm"),(0,r.kt)("td",null,"UJ"),(0,r.kt)("td",null,"0x6f"),(0,r.kt)("td",null),(0,r.kt)("td",null),(0,r.kt)("td",null,"R[rd] \u2190 PC + 4",(0,r.kt)("br",null),"\xa0PC \u2190 PC + ","{","imm, 1b0","}")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"jalr rd, rs1, imm"),(0,r.kt)("td",null,"I"),(0,r.kt)("td",null,"0x67"),(0,r.kt)("td",null,"0x0"),(0,r.kt)("td",null),(0,r.kt)("td",null,"R[rd] \u2190 PC + 4",(0,r.kt)("br",null),"\xa0PC \u2190 R[rs1] + ","{","imm","}")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"csrw rd, csr, rs1"),(0,r.kt)("td",null,"I"),(0,r.kt)("td",null,"0x73"),(0,r.kt)("td",null,"0x1"),(0,r.kt)("td",null),(0,r.kt)("td",null,"CSR[csr] \u2190 R[rs1]")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"csrwi rd, csr, uimm"),(0,r.kt)("td",null,"I"),(0,r.kt)("td",null,"0x73"),(0,r.kt)("td",null,"0x5"),(0,r.kt)("td",null),(0,r.kt)("td",null,"CSR[csr] \u2190 ","{","uimm","}")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"info-memory-1"},"Info: Memory"),(0,r.kt)("p",null,"The Memory unit (located in ",(0,r.kt)("inlineCode",{parentName:"p"},"mem.circ"),") is already fully implemented for you and attached to the outputs of your CPU in ",(0,r.kt)("inlineCode",{parentName:"p"},"test_harness.circ"),"! You ",(0,r.kt)("strong",{parentName:"p"},"must not")," add ",(0,r.kt)("inlineCode",{parentName:"p"},"mem.circ")," into your CPU, doing so will cause the autograder to fail and you will not receive a score."),(0,r.kt)("p",null,"Note that the address you give to memory is a byte address, but memory returns an entire word of memory. The memory unit ignores the bottom two bits of the address you provide to it, and treats its input as a ",(0,r.kt)("strong",{parentName:"p"},"word address")," rather than a ",(0,r.kt)("strong",{parentName:"p"},"byte address"),". For example, if you input the 32-bit address 0x0000","_","1007, it wil be treated as the word address 0x0000","_","1004, and you will get as output the 4 bytes at addresses 0x0000","_","1004, 0x0000","_","1005, 0x0000","_","1006, and 0x0000","_","1007."),(0,r.kt)("p",null,"Note that for the ",(0,r.kt)("inlineCode",{parentName:"p"},"lw"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"lh"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"sh"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"sw")," instructions, the RISC-V ISA supports unaligned accesses, but implementing them is complicated. We\u2019ll only be implementing ",(0,r.kt)("em",{parentName:"p"},"aligned")," memory accesses in this project. This means that operations will only be defined when they do not exceed the boundaries of a contiguous word in memory. An example of such an operation is any ",(0,r.kt)("inlineCode",{parentName:"p"},"lw")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"sw")," that operates on an address that is a multiple of 4. Since the address is a multiple of 4 and we load 4 bytes in a word, the total memory fetched does not exceed the boundaries of a contiguous word in memory. You ",(0,r.kt)("strong",{parentName:"p"},"must not")," implement unaligned accesses; you would likely need to use stalling, which would result in your output not matching our expected output (bad for your score)."),(0,r.kt)("p",null,"Remember that the memory is also ",(0,r.kt)("strong",{parentName:"p"},"byte")," level write enabled. This means that the Write","_","En signal is 4 bits wide and acts as a write mask for the input data. For example, if Write","_","En is ",(0,r.kt)("inlineCode",{parentName:"p"},"1'b1000"),", only the most significant byte of the addressed word in memory will be overwritten. The ReadData port will always return the value in memory at the supplied address, regardless of Write","_","En."),(0,r.kt)("p",null,"Again, here\u2019s a quick summary of its inputs and outputs:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Signal Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Direction"),(0,r.kt)("th",{parentName:"tr",align:null},"Bit Width"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"WriteAddr"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Address to read/write to in Memory")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"WriteData"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Value to be written to Memory")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Write","_","En"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"The write mask for instructions that write to Memory and zero otherwise")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CLK"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Driven by the clock input to the CPU")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ReadData"),(0,r.kt)("td",{parentName:"tr",align:null},"Output"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Value of the data stored at the specified address")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"info-branch-comparator-1"},"Info: Branch Comparator"),(0,r.kt)("p",null,"The Branch Comparator unit (located in ",(0,r.kt)("inlineCode",{parentName:"p"},"branch_comp.circ"),") compares two values and outputs control signals that will be used to make branching decisions. You will need to implement logic for this circuit."),(0,r.kt)("p",null,"To edit this subcircuit, edit the ",(0,r.kt)("inlineCode",{parentName:"p"},"branch_comp.circ")," file and not the ",(0,r.kt)("inlineCode",{parentName:"p"},"branch_comp")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"cpu.circ"),". Note that if you modify this circuit, you will need to close and open ",(0,r.kt)("inlineCode",{parentName:"p"},"cpu.circ")," to load the changes in your CPU."),(0,r.kt)("p",null,"Again, here\u2019s a quick summary of its inputs and outputs:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Signal Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Direction"),(0,r.kt)("th",{parentName:"tr",align:null},"Bit Width"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rs1"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Value in the first register to be compared")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rs2"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Value in the second register to be compared")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BrUn"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Equal to one when an unsigned comparison is wanted, or zero when a signed comparison is wanted")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BrEq"),(0,r.kt)("td",{parentName:"tr",align:null},"Output"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Equal to one if the two values are equal")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BrLt"),(0,r.kt)("td",{parentName:"tr",align:null},"Output"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Equal to one if the value in rs1 is less than the value in rs2")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"info-immediate-generator-1"},"Info: Immediate Generator"),(0,r.kt)("p",null,"The Immediate Generator (\u201cImm Gen\u201d) unit (located in ",(0,r.kt)("inlineCode",{parentName:"p"},"imm_gen.circ"),") extracts the appropriate immediate from ",(0,r.kt)("inlineCode",{parentName:"p"},"I"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"S"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"B"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"U"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"J")," type instructions. Remember that in RISC-V, all immediates that leave the immediate generator are 32-bits and sign-extended! See the table below for how each immediate should be formatted:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"alt-text",src:n(22511).Z})),(0,r.kt)("p",null,"To edit this subcircuit, edit the ",(0,r.kt)("inlineCode",{parentName:"p"},"imm_gen.circ")," file and not the ",(0,r.kt)("inlineCode",{parentName:"p"},"imm_gen")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"cpu.circ"),". Note that if you modify this circuit, you will need to close and open ",(0,r.kt)("inlineCode",{parentName:"p"},"cpu.circ")," to load the changes in your CPU."),(0,r.kt)("p",null,"Again, here\u2019s a quick summary of its inputs and outputs:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Signal Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Direction"),(0,r.kt)("th",{parentName:"tr",align:null},"Bit Width"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"inst"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"The instruction being executed")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ImmSel"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},"Value determining how to reconstruct the immediate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"imm"),(0,r.kt)("td",{parentName:"tr",align:null},"Output"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Value of the immediate in the instruction")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"info-control-logic-1"},"Info: Control Logic"),(0,r.kt)("p",null,"The Control Logic unit (",(0,r.kt)("inlineCode",{parentName:"p"},"control_logic.circ"),") provided in the skeleton is based on the control logic unit in the 5-stage CPU used in lecture and discussion. In order to correctly identify each instruction, control signals play a very important part in this project. However, figuring out all of the control signals may seem intimidating. We suggest taking a look at the lecture slides and discussion worksheets to get started. Try walking through the datapath with different types of instructions; when you see a MUX or other component, think about what selector/enable value you will need for that instruction."),(0,r.kt)("p",null,"You are welcome to add more inputs or outputs to the existing starter circuit as your control logic demands. You may also use as many or as few of the supplied ports as needed. That being said, please do not change or remove any of the existing ports during this process."),(0,r.kt)("p",null,"There are a two major approaches to implementing the control logic so that it can extract the ",(0,r.kt)("inlineCode",{parentName:"p"},"opcode"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"funct3"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"funct7")," from an instruction and set the control signals appropriately."),(0,r.kt)("p",null,"The recommended method is ",(0,r.kt)("strong",{parentName:"p"},"hard-wired control"),", as discussed in lecture, which is usually the preferred approach for RISC architectures like MIPS and RISC-V. Hard-wired control uses \u201cAND\u201d, \u201cOR\u201d, and \u201cNOT\u201d gates (along with the various components we\u2019ve learned can be built from these gates, like MUXes and DEMUXes) to produce the appropriate control signals. An ",(0,r.kt)("strong",{parentName:"p"},"instruction decoder")," takes in an instruction and outputs all of the control signals for that instruction."),(0,r.kt)("p",null,"The other way to do it is to use ",(0,r.kt)("strong",{parentName:"p"},"ROM control"),". Every instruction implemented by a processor maps to an address in a Read-Only Memory (ROM) unit. At that address in the ROM is the control word for that instruction. An ",(0,r.kt)("strong",{parentName:"p"},"address decoder")," takes in an instruction and outputs the address of the control word for that instruction. This approach is common in CISC architectures like Intel\u2019s x86-64, and, in real life, offers some flexibility because it can be re-programmed by changing the contents of the ROM."),(0,r.kt)("p",null,"To edit this subcircuit, edit the ",(0,r.kt)("inlineCode",{parentName:"p"},"control_logic.circ")," file and not the ",(0,r.kt)("inlineCode",{parentName:"p"},"control_logic")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"cpu.circ"),". Note that if you modify this circuit, you will need to close and open ",(0,r.kt)("inlineCode",{parentName:"p"},"cpu.circ")," to load the changes in your CPU."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"info-control-status-register-csr"},"Info: Control Status Register (CSR)"),(0,r.kt)("p",null,"In order to run the testbenches that determine your project grades as well as the winners for the ",(0,r.kt)("strong",{parentName:"p"},"Design Contest"),", there are a few more instructions that need to be added. A Control Status Register (CSR) holds additional information about the results of machine instructions, and it usually is stored independently of the register file and the memory. In your processor, you will be writing outputs to one of the CSRs that will be monitored by more complex testbenches. ",(0,r.kt)("strong",{parentName:"p"},"Note that Venus does not support CSRs, so you will not be able to generate custom tests for these instructions. We will provide a robust sanity check for your CSR in the Part B autograder that will test all functionality of CSR needed.")),(0,r.kt)("p",null,"Below are the ",(0,r.kt)("strong",{parentName:"p"},"2 CSR instructions")," that you will need to implement. Note that while there are 212 possible CSR addresses, we will only use one of them (",(0,r.kt)("inlineCode",{parentName:"p"},"tohost = 0x51E"),"). Note that the immediate forms use a 5-bit zero-extended immediate (uimm) encoded in the ",(0,r.kt)("inlineCode",{parentName:"p"},"rs1")," field."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"csrw tohost, t2")," (short for ",(0,r.kt)("inlineCode",{parentName:"li"},"csrrw x0,csr,rs1")," where ",(0,r.kt)("inlineCode",{parentName:"li"},"csr=0x51E"),")"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"csrwi tohost, 1")," (short for ",(0,r.kt)("inlineCode",{parentName:"li"},"csrrwi x0,csr,uimm")," where ",(0,r.kt)("inlineCode",{parentName:"li"},"csr=0x51E"),")")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"alt-text",src:n(31546).Z})),(0,r.kt)("p",null,"The Control Status Register unit skeleton (",(0,r.kt)("inlineCode",{parentName:"p"},"csr.circ"),") is provided with the starter code. In this unit, you will need to implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"tohost")," CSR register along with the write logic. ",(0,r.kt)("strong",{parentName:"p"},"Please do not change the given connections as it will interfere with the testbench results!")),(0,r.kt)("p",null,"If you want to learn more about CSR, you can refer to Chapter 9 of the ",(0,r.kt)("a",{parentName:"p",href:"https://web.archive.org/web/20220121165045/https://github.com/riscv/riscv-isa-manual/releases/tag/draft-20201002-db3eeaf"},"RISC-V specification"),"."),(0,r.kt)("p",null,"Here\u2019s a quick summary of its inputs and outputs:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Signal Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Direction"),(0,r.kt)("th",{parentName:"tr",align:null},"Bit Width"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CSR","_","address"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"12"),(0,r.kt)("td",{parentName:"tr",align:null},"Input CSR register address")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CSR","_","din"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Value to write into specified CSR register")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CSR","_","WE"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Write enable")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"clk"),(0,r.kt)("td",{parentName:"tr",align:null},"Input"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Clock input")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tohost"),(0,r.kt)("td",{parentName:"tr",align:null},"Output"),(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"Output of the ",(0,r.kt)("inlineCode",{parentName:"td"},"tohost")," register")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"info-processor-1"},"Info: Processor"),(0,r.kt)("p",null,"The main CPU circuit (located in ",(0,r.kt)("inlineCode",{parentName:"p"},"cpu.circ"),") implements the main datapath and connects all the subcircuits (ALU, Branch Comparator, Control Logic, Immediate Generator, Memory, and RegFile) together. In Part A, you implemented a simple two-stage pipeline in your CPU. Since Part B requires support for branch and jump instructions, you\u2019ll need to handle control hazards that occur when branching."),(0,r.kt)("p",null,"The instruction immediately after a branch or jump is not executed if a branch is taken. This makes your task a bit more complex. By the time you have figured out that a branch or jump is in the execute stage, you have already accessed the instruction memory and pulled out (possibly) the wrong instruction. You will therefore need to \u201ckill\u201d instruction that is being fetched if the instruction under execution is a jump or a taken branch."),(0,r.kt)("p",null,"Instruction kills for this project MUST be accomplished by MUXing a ",(0,r.kt)("inlineCode",{parentName:"p"},"nop")," into the instruction stream and sending the ",(0,r.kt)("inlineCode",{parentName:"p"},"nop")," into the Execute stage instead of using the fetched instruction. Notice that 0x00000013, or ",(0,r.kt)("inlineCode",{parentName:"p"},"addi x0, x0, 0")," is a ",(0,r.kt)("inlineCode",{parentName:"p"},"nop")," instruction; other ",(0,r.kt)("inlineCode",{parentName:"p"},"nop")," instructions will work too. You should kill if a branch is taken (do not kill otherwise). Do kill on every type of jump."),(0,r.kt)("p",null,"Do not solve this issue by calculating branch offsets in the IF stage. If we test your output against the reference every cycle, and the reference returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"nop"),", while it may be a conceptually correct solution, this will cause you to fail our tests."),(0,r.kt)("p",null,"Because all of the control and execution is handled in the Execute stage, ",(0,r.kt)("strong",{parentName:"p"},"your processor should be more or less indistinguishable from a single-cycle implementation, barring the one-cycle startup latency and the branch/jump delays.")," However, we will be enforcing the two-stage pipeline design. Some things to consider:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Will the IF and EX stages have the same or different ",(0,r.kt)("inlineCode",{parentName:"li"},"PC")," values?"),(0,r.kt)("li",{parentName:"ul"},"Do you need to store the ",(0,r.kt)("inlineCode",{parentName:"li"},"PC")," between the pipelining stages?"),(0,r.kt)("li",{parentName:"ul"},"To MUX a ",(0,r.kt)("inlineCode",{parentName:"li"},"nop")," into the instruction stream, do you place it ",(0,r.kt)("em",{parentName:"li"},"before")," or ",(0,r.kt)("em",{parentName:"li"},"after")," the instruction register?"),(0,r.kt)("li",{parentName:"ul"},"What address should be requested next while the EX stage executes a ",(0,r.kt)("inlineCode",{parentName:"li"},"nop"),"? Is this different than normal?")),(0,r.kt)("p",null,"You might also notice a bootstrapping problem here: during the first cycle, the instruction register sitting between the pipeline stages won\u2019t contain an instruction loaded from memory. How do we deal with this? It happens that Logisim automatically sets registers to zero on reset; the instruction register will then contain a ",(0,r.kt)("inlineCode",{parentName:"p"},"nop"),". We will allow you to depend on this behavior of Logisim. Remember to go to Simulate ",(0,r.kt)("inlineCode",{parentName:"p"},"--\x3e")," Reset Simulation (Ctrl+R) to reset your processor."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"cpu-testing-pipelined-sanity-tests"},"CPU Testing: Pipelined Sanity Tests"),(0,r.kt)("p",null,"We\u2019ve provided a group of basic sanity tests for your pipelined CPU in ",(0,r.kt)("inlineCode",{parentName:"p"},"tests/part_b/pipelined"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"$ python3 test_runner.py part_b pipelined\n\n")),(0,r.kt)("p",null,"You can see the ",(0,r.kt)("inlineCode",{parentName:"p"},".s")," (RISC-V) and ",(0,r.kt)("inlineCode",{parentName:"p"},".hex")," (machine code) files for the test in ",(0,r.kt)("inlineCode",{parentName:"p"},"tests/part_b/pipelined/inputs"),"."),(0,r.kt)("p",null,"We\u2019ve also provided ",(0,r.kt)("inlineCode",{parentName:"p"},"binary_to_hex_cpu.py"),", which works like ",(0,r.kt)("inlineCode",{parentName:"p"},"binary_to_hex_cpu.py")," from Task 3."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"task-5-custom-tests"},"Task 5: Custom Tests"),(0,r.kt)("p",null,"The autograder tests fall into 3 main categories: ",(0,r.kt)("strong",{parentName:"p"},"unit tests"),", ",(0,r.kt)("strong",{parentName:"p"},"integration tests"),", and ",(0,r.kt)("strong",{parentName:"p"},"edge case tests"),". For Part B, we won\u2019t be revealing all the autograder tests, but you should be able to re-create a very close approximation of them on your own in order to test your CPU."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Unit tests"),": a unit test exercises your datapath with a single instruction, to make sure that each individual instruction has been implemented and is working as expected. You should write a different unit test for every single instruction that you need to implement, and make sure that you test the spectrum of possibilities for that instruction thoroughly. For example, a unit test ",(0,r.kt)("inlineCode",{parentName:"p"},"slt")," should contain cases where ",(0,r.kt)("inlineCode",{parentName:"p"},"rs1 < rs2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"rs1 > rs2"),", and where ",(0,r.kt)("inlineCode",{parentName:"p"},"rs1 == rs2"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Integration tests"),": After you\u2019ve passed your unit tests, move onto tests that use multiple functions in combination. Try out various simple RISC-V programs that run a single function; your CPU should be able to handle them, if working properly. Feel free to try to use riscv-gcc to compile C programs to RISC-V, but be aware of the limited instruction set we\u2019re working with (you don\u2019t have any ",(0,r.kt)("inlineCode",{parentName:"p"},"ecall")," instructions, for example). We\u2019d recommend that you instead try to write simple functions on your own based on what you\u2019ve seen in labs, discussions, projects, and exams."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Edge case tests"),": edge case tests try inputs that you normally wouldn\u2019t expect, which may trigger bugs in certain situations. What edge cases should you look for? A small hint from us: our 2 main classes of edge cases come from memory operations and branch/jump operations (some of the test names are \u201cmem-full\u201d and \u201cbr-jump-edge\u201d). Think about all the different ways these operations could go wrong."),(0,r.kt)("h3",{id:"creating-custom-tests"},"Creating Custom Tests"),(0,r.kt)("p",null,"We\u2019ve included a script (",(0,r.kt)("inlineCode",{parentName:"p"},"create-test.py"),") that uses Venus to help you generate test circuits from RISC-V assembly! As a reminder you can find a debugging walkthrough at ",(0,r.kt)("a",{parentName:"p",href:"https://web.archive.org/web/20220121165045/https://inst.eecs.berkeley.edu/~cs61c/fa20/lectures/videos?ytvid=qFIPWt9Pu7I"},"this video"),". The process for generating a custom test is as follows:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Come up the RISC-V assembly instructions for the test, and save them in a file ending in ",(0,r.kt)("inlineCode",{parentName:"p"},".s")," in the ",(0,r.kt)("inlineCode",{parentName:"p"},"tests/part_b/custom/inputs")," folder. The name of this file will be the name of your test. Note that your test ",(0,r.kt)("strong",{parentName:"p"},"must")," end in ",(0,r.kt)("inlineCode",{parentName:"p"},".s"),", and it ",(0,r.kt)("strong",{parentName:"p"},"must")," be located in the ",(0,r.kt)("inlineCode",{parentName:"p"},"tests/part_b/custom/inputs")," folder. Repeat if you have more tests."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"tests/part_b/custom/inputs/sll-slli.s"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"tests/part_b/custom/inputs/slt.s")))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Repeat step 1 if you have more tests.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"To generate test circuits for your tests, run the ",(0,r.kt)("inlineCode",{parentName:"p"},"create-test.py")," script:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"$ cd tests/part_b/custom\n$ python3 create-test.py inputs/sll-slli.s inputs/slt.s\n\n")),(0,r.kt)("p",{parentName:"li"},"This should generate a couple new files:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"tests/part_b/custom:\n  - <TEST_NAME>.circ # The new circuit for your test\n  - inputs/<TEST_NAME>.s # The test file you wrote\n  - inputs/<TEST_NAME>.hex # The machine code of the test file you wrote\n  - reference_outputs/<TEST_NAME>-ref.out # The reference output for your test\n\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Now you can run your tests!"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"$ python3 test_runner.py part_b custom\n\n")))),(0,r.kt)("p",null,"If you want to inspect the circuit running your test, you can simulate it by opening up the ",(0,r.kt)("inlineCode",{parentName:"p"},"CPU-<test name here>.circ")," file, right-clicking on the CPU, selecting \u2018view main\u2019, and using Cmd + T (Ctrl + T on Windows) to manually tick the clock through each cycle. If you don\u2019t remember how to simulate your circuit, please refer back to the Logisim lab. We highly encourage you to poke your circuit while simulating the test to observe how your circuit reacts to various inputs (perhaps this can give you ideas for new tests to write)."),(0,r.kt)("p",null,"If you wish to simulate your code only for a certain number of cycles, you can do that by using the ",(0,r.kt)("inlineCode",{parentName:"p"},"-n")," flag:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"$ python3 create_test.py -n <NUMBER_OF_CYCLES> <TEST_NAME>.s\n\n")),(0,r.kt)("p",null,"If you would like to decode your output, use the provided ",(0,r.kt)("inlineCode",{parentName:"p"},"binary_to_hex_cpu.py"),". Note that because you\u2019re implementing a 2-stage pipelined processor and the first instruction writes on the rising edge of the second clock cycle, the effects of your instructions will have a 2 instruction delay. For example, let\u2019s say you wrote a test with one instruction: ",(0,r.kt)("inlineCode",{parentName:"p"},"addi t0, x0, 1"),". If you inspect the reference output, you\u2019ll see that ",(0,r.kt)("inlineCode",{parentName:"p"},"t0")," isn\u2019t changed until the third cycle."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"test-coverage"},"Test Coverage"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Test coverage"),": a metric measuring how much of a given codebase is being tested by tests. For the purposes of this project, you will be graded on how much of the required ISA your tests cover."),(0,r.kt)("p",null,"The autograder for Part B will examine the coverage of tests located in the ",(0,r.kt)("inlineCode",{parentName:"p"},"tests/part_b/custom/inputs")," folder. When you submit Part B to the autograder, the autograder will output a message about the percentage coverage of your tests against our staff suite of tests and notify you if any of your tests raised a syntax error."),(0,r.kt)("p",null,"Hints:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If you make many short test files rather than one large one, it will be easier to figure out which test and which line causes your Syntax Error (and to figure out where your CPU is failing). We\u2019d recommend that for unit testing, where you have one .s file testing each instruction."),(0,r.kt)("li",{parentName:"ul"},"Make sure you test every single instruction in the ISA, including the ones that are covered by the sanity tests; feel free to use the sanity tests as a model or even incorporate them as part of your test suite."),(0,r.kt)("li",{parentName:"ul"},"Make sure you check that all registers are working."),(0,r.kt)("li",{parentName:"ul"},"Make sure you don\u2019t have any \u201cdummy\u201d tests; if a test doesn\u2019t lead to a change in state or register value, it is not a meaningful test."),(0,r.kt)("li",{parentName:"ul"},"Make sure that you accumulate outputs into the special registers we output to the testharness, other registers will not be checked against. These registers are: ",(0,r.kt)("inlineCode",{parentName:"li"},"x0"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"ra"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"sp"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"t0"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"t1"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"t2"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"s0"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"s1"),", and ",(0,r.kt)("inlineCode",{parentName:"li"},"a0"),".")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"part-b-submission"},"Part B: Submission"),(0,r.kt)("p",null,"At this point, if you\u2019ve completed tasks 4-5, you\u2019ve finished Part B of the project. Congratulations on your shiny new CPU!"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Your last bit of work before you submit is to write down how you implemented your CPU inside the readme.md. There is already a template for you to use and don\u2019t worry about going into too much detail, we just want you to reflect on what you did in this project and explain the reasoning behind the design choices you made (especially in your control logic)! You must also document the breakdown of labor between you and your partner! Tell us who did what in both implementation and design.")),(0,r.kt)("p",null,"Double-check that you have not moved your input/output pins, and that your circuits fit in the provided testing harnesses. Make sure that you did not create any additional ",(0,r.kt)("inlineCode",{parentName:"p"},".circ")," files; the autograder will only be testing the circuit files you needed to edit in the starter code (",(0,r.kt)("inlineCode",{parentName:"p"},"branch_comp.circ"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"control_logic.circ"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"cpu.circ"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"imm_gen.circ"),"). Also make sure your custom ",(0,r.kt)("inlineCode",{parentName:"p"},".s")," tests are located in the right folder."),(0,r.kt)("p",null,"The autograder for Part B uses the sanity tests provided in the starter code, as well as hidden unit, integration, and edge case tests as specified in Task 5. Additionally, the autograder will be checking your custom tests for test coverage."),(0,r.kt)("p",null,"Note: If you fail on any of the provided autograder sanity tests, course staff will ",(0,r.kt)("strong",{parentName:"p"},"not")," help you debug your CPU ",(0,r.kt)("strong",{parentName:"p"},"unless")," you have recreated a similar test that also fails."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"frequently-asked-questions"},"Frequently Asked Questions"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Q"),": I have pipelined my CPU, but the autograder said it detected a single-cycle one, what is the problem?",(0,r.kt)("br",{parentName:"li"}),(0,r.kt)("strong",{parentName:"li"},"A"),": If you\u2019re certain that you correctly pipelined, then it means that Logisim crashed when attempting to open your circuit. Generally this is caused by import issues, meaning you used a circuit that isn\u2019t in the correct place. Remember that you shouldn\u2019t be creating any new circ files and your ALU and RegFile files will be replaced with the staff solution, so don\u2019t use any subcircuits you created in those files in your CPU."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Q"),": I want to add more inputs and outputs to one of my circuits. Is this allowed?",(0,r.kt)("br",{parentName:"li"}),(0,r.kt)("strong",{parentName:"li"},"A"),": This is allowed, however beware of messing up your circuit appearance. This can cause pins to move to the wrong place and make you fail all the sanity tests. You can check you circuit appearance by right-clicking on your circuit and selecting \u201cEdit Circuit Appearance\u201d to move the new pins around if necessary, though this is not recommended. ",(0,r.kt)("strong",{parentName:"li"},"WARNING: If you fail autograder tests because of added inputs/outputs we will not allow you to fix and resubmit after the deadline.")," If you want to add extra logic or controls to your CPU we recommend making a control subcircuit in cpu.circ."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Q"),": Are we allowed to use all the Logisim main library blocks? Where can I find information on them?",(0,r.kt)("br",{parentName:"li"}),(0,r.kt)("strong",{parentName:"li"},"A"),": You are only allowed to use the following libraries: Wiring (",(0,r.kt)("strong",{parentName:"li"},"except Transistor, Transmission Gate, POR, Pull Resistor, Power, Ground, POR, Do not connect"),"), Gates, Plexers, Arithmetic (",(0,r.kt)("strong",{parentName:"li"},"except Divider"),"), Memory (",(0,r.kt)("strong",{parentName:"li"},"except RAM, Random Generator"),") Note that the use of ",(0,r.kt)("strong",{parentName:"li"},"ROM")," is allowed. Help can be found in the Logisim menus"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Q"),": I failed a sanity check in the autograder, can I get help figuring out what\u2019s wrong?",(0,r.kt)("br",{parentName:"li"}),(0,r.kt)("strong",{parentName:"li"},"A")," Course staff will be unable to help debug issues directly from the autograder. Instead, we encourage you to use the custom test generator to generate new test that replicates the operation described in the sanity test description and then bringing failed results from that test to OH."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Q"),": My autograder failed to run, how do I fix this?",(0,r.kt)("br",{parentName:"li"}),(0,r.kt)("strong",{parentName:"li"},"A")," Please check that you have followed all the rules with regards to allowed blocks and circuit naming. Also please check that you do not have any splitters where an output of the splitter is mapped to by 0 pins (in this case you should be using a smaller splitter anyway). If you have made all these checks and fixes and are still having problems, please post on Piazza.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"grading"},"Grading"),(0,r.kt)("p",null,"The grading breakdown for Project 3 is as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Part A (20%)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"ALU (8%)"),(0,r.kt)("li",{parentName:"ul"},"RegFile (8%)"),(0,r.kt)("li",{parentName:"ul"},"Pipelined ",(0,r.kt)("inlineCode",{parentName:"li"},"addi")," (4%)"))),(0,r.kt)("li",{parentName:"ul"},"Part B (80%)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Sanity and Visible (Basic) Unit Tests (20%)"),(0,r.kt)("li",{parentName:"ul"},"Test Coverage (10%)"),(0,r.kt)("li",{parentName:"ul"},"Hidden Unit, Integration, and Edge Case Tests (50%)")))),(0,r.kt)("p",null,"For Part B we have provided a visible set of ",(0,r.kt)("strong",{parentName:"p"},"basic")," unit tests in the autograder. These tests are meant to help reduce your stress by providing some guidance in the early stages of testing. You should still rigorously test your designs, ",(0,r.kt)("strong",{parentName:"p"},"passing the visible tests does not guarantee that you will pass any of the hidden tests.")),(0,r.kt)("h2",{id:"design-contest"},"Design Contest"),(0,r.kt)("p",null,"This year, thanks to support from an industry partner, Project 3 will be part of a course wide design contest! The method in which your Project 3 submission will be scored is based on the gate equivalence and longest path of your submitted circuit. In both contests, a lower score is better."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note that while all submitted designs will show a score, only designs that pass 100% of visible and hidden tests will be eligible for the contest.")," This means that it is in your best interest to test throughly!"),(0,r.kt)("h3",{id:"gate-equivalence"},"Gate equivalence"),(0,r.kt)("p",null,"The first contest score you will receive is for gate equivalence. To calculate this, we will take your submitted circuit, and convert it to the number of NAND2 gates, NOT gates, and flip-flops required to implement your design. You will then be assigned a score based on the formula: ",(0,r.kt)("strong",{parentName:"p"},"score = 2 ","*"," (# of NOTs) + 2 ","*"," (# of NAND2s) + 8 ","*"," (# of FFs)"),". This score is a proxy for the power consumption and area utilization of your design. The weights in our formula are derived from the number of transistors needed to replicate each type of gate or flip-flop."),(0,r.kt)("p",null,"A table of some common logic elements and their corresponding gate equivalents are shown below. You can assume that the gate equivalents scale roughly linearly with the total input bitwidth (i.e. a 2-input 32-bit adder has roughly 32 times the number of gates of a 2-input 1-bit adder). An exception to this rule is the multiplier, which scales roughly linearly with the ",(0,r.kt)("strong",{parentName:"p"},"square")," of the total input bitwidth."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Gate Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Number of NAND2 Gates"),(0,r.kt)("th",{parentName:"tr",align:null},"Number of NOT Gates"),(0,r.kt)("th",{parentName:"tr",align:null},"Number of FFs"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2-input AND"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2-input OR"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2-input NOR"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"32-bit ADDER"),(0,r.kt)("td",{parentName:"tr",align:null},"366"),(0,r.kt)("td",{parentName:"tr",align:null},"195"),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"32-bit SUBTRACTOR"),(0,r.kt)("td",{parentName:"tr",align:null},"456"),(0,r.kt)("td",{parentName:"tr",align:null},"255"),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"32-bit COMPARATOR"),(0,r.kt)("td",{parentName:"tr",align:null},"222"),(0,r.kt)("td",{parentName:"tr",align:null},"127"),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"32-bit MULTIPLIER"),(0,r.kt)("td",{parentName:"tr",align:null},"10849"),(0,r.kt)("td",{parentName:"tr",align:null},"4467"),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"32-bit NEGATOR"),(0,r.kt)("td",{parentName:"tr",align:null},"145"),(0,r.kt)("td",{parentName:"tr",align:null},"84"),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"32-bit SHIFTER"),(0,r.kt)("td",{parentName:"tr",align:null},"418"),(0,r.kt)("td",{parentName:"tr",align:null},"36"),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2-input 32-bit MUX"),(0,r.kt)("td",{parentName:"tr",align:null},"128"),(0,r.kt)("td",{parentName:"tr",align:null},"33"),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ROM (per non-zero entry)"),(0,r.kt)("td",{parentName:"tr",align:null},"5.8 (average)"),(0,r.kt)("td",{parentName:"tr",align:null},"4.6 (average)"),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"32-bit Register FF"),(0,r.kt)("td",{parentName:"tr",align:null},"97"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"32")))),(0,r.kt)("h3",{id:"longest-path"},"Longest Path"),(0,r.kt)("p",null,"The second contests score you will receive is for the longest path in your design. We will follow a similar process to gate equivalent but instead calculate the longest path between any two flop-flops in your design. This score is a proxy for the fastest clock frequency at which your design could run."),(0,r.kt)("h3",{id:"tips"},"Tips"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Simplify when possible! For example, a shifter that shifts by a fixed amount can be replicated using a splitter, which costs 0 gates!"),(0,r.kt)("li",{parentName:"ul"},"A majority of your savings will come from optimizing your control logic."),(0,r.kt)("li",{parentName:"ul"},"Reduce, reuse, recycle! Use the output of a computation as many times as possible rather than performing the computation each time the value is needed."),(0,r.kt)("li",{parentName:"ul"},"Break apart independent computations into their own paths. If you place all your logic between two flip-flops in a single path, this is very inefficient in terms of your longest path.")))}m.isMDXComponent=!0},31546:(t,e,n)=>{n.d(e,{Z:()=>a});const a=n.p+"assets/images/csr-9ed7d4308cdacc599fe8b4e890b87557.png"},50473:(t,e,n)=>{n.d(e,{Z:()=>a});const a=n.p+"assets/images/error_wire_2-b88a64387701d712f3add5f29b8c32f8.png"},22511:(t,e,n)=>{n.d(e,{Z:()=>a});const a=n.p+"assets/images/immediates-b3a4600a503bc68d57e999e48d2c8309.png"}}]);