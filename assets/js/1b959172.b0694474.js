"use strict";(self.webpackChunklearncs_set=self.webpackChunklearncs_set||[]).push([[53321],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var i=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=i.createContext({}),p=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(n),d=r,h=c["".concat(l,".").concat(d)]||c[d]||m[d]||a;return n?i.createElement(h,o(o({ref:t},u),{},{components:n})):i.createElement(h,o({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:r,o[1]=s;for(var p=2;p<a;p++)o[p]=n[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},96783:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var i=n(87462),r=(n(67294),n(3905));const a={title:"Discussion 4 Solutions"},o="Discussion 4 | CS 61A Spring 2024",s={unversionedId:"curriculum-resource/cs61a/cs61a_en/dis/sol-disc04",id:"curriculum-resource/cs61a/cs61a_en/dis/sol-disc04",title:"Discussion 4 Solutions",description:"Discussion 4: Tree Recursion",source:"@site/docs/curriculum-resource/cs61a/cs61a_en/dis/sol-disc04.md",sourceDirName:"curriculum-resource/cs61a/cs61a_en/dis",slug:"/curriculum-resource/cs61a/cs61a_en/dis/sol-disc04",permalink:"/docs/curriculum-resource/cs61a/cs61a_en/dis/sol-disc04",draft:!1,tags:[],version:"current",frontMatter:{title:"Discussion 4 Solutions"},sidebar:"tutorialSidebar",previous:{title:"Discussion 3 Solutions",permalink:"/docs/curriculum-resource/cs61a/cs61a_en/dis/sol-disc03"},next:{title:"Discussion 5 Solutions",permalink:"/docs/curriculum-resource/cs61a/cs61a_en/dis/sol-disc05"}},l={},p=[{value:"Discussion 4: Tree Recursion",id:"discussion-4-tree-recursion",level:2},{value:"Getting Started",id:"getting-started",level:2},{value:"Tree Recursion",id:"tree-recursion",level:2},{value:"Q1: Insect Combinatorics",id:"q1-insect-combinatorics",level:3},{value:"Tree Recursion with Lists",id:"tree-recursion-with-lists",level:2},{value:"Q2: Max Product",id:"q2-max-product",level:3},{value:"Q3: Sum Fun",id:"q3-sum-fun",level:3},{value:"Document the Occasion",id:"document-the-occasion",level:2}],u={toc:p},c="wrapper";function m(e){let{components:t,...a}=e;return(0,r.kt)(c,(0,i.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"discussion-4--cs-61a-spring-2024"},"Discussion 4 | CS 61A Spring 2024"),(0,r.kt)("h2",{id:"discussion-4-tree-recursion"},"Discussion 4: Tree Recursion"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{target:"_blank",href:n(87210).Z},"disc04.pdf"))),(0,r.kt)("p",null,"Pick someone in your group to ",(0,r.kt)("a",{parentName:"p",href:"https://cs61a.org/articles/discord"},"join Discord"),". It's fine if multiple people join, but one is enough."),(0,r.kt)("p",null,"Now switch to Pensieve:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Everyone"),": Go to ",(0,r.kt)("a",{parentName:"li",href:"http://discuss.pensieve.co/"},"discuss.pensieve.co")," and log in with your @berkeley.edu email, then enter your group number. (Your group number is the number of your Discord channel.)")),(0,r.kt)("p",null,"Once you're on Pensieve, you don't need to return to this page; Pensieve has all the same content (but more features). If for some reason Penseive doesn't work, return to this page and continue with the discussion."),(0,r.kt)("p",null,"Post in the ",(0,r.kt)("inlineCode",{parentName:"p"},"#help")," channel on ",(0,r.kt)("a",{parentName:"p",href:"https://cs61a.org/articles/discord/"},"Discord")," if you have trouble."),(0,r.kt)("h2",{id:"getting-started"},"Getting Started"),(0,r.kt)("p",null,"Say your name and your favorite tree (a particular tree or a kind of tree) in honor of today's topic: tree recursion. (Tree recursive functions are functions that call themselves more than once.)"),(0,r.kt)("p",null,"In this discussion, don't use a Python interpreter to run code until you are confident your solution is correct. Figure things out and check your work by ",(0,r.kt)("em",{parentName:"p"},"thinking")," about what your code will do. Not sure? Talk to your group!"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"[","New","]")," If you have fewer than 4 people in your group, you can merge with another group in the room with you."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"[","New","]")," Recursion takes practice. Please don't get discouraged if you're struggling to write recursive functions. Instead, every time you do solve one (even with help or in a group), make note of what you had to realize to make progress. Students improve through practice and reflection."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"[","For Fun","]")," This emoticon of a guy in a cowboy hat is valid Python: ",(0,r.kt)("inlineCode",{parentName:"p"},"o[:-D]")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},">>> o = [2, 0, 2, 4]\n>>> [ o[:-D] for D in range(1,4) ]\n[[2, 0, 2], [2, 0], [2]]\n")),(0,r.kt)("p",null,"\ud83e\udd20"),(0,r.kt)("h2",{id:"tree-recursion"},"Tree Recursion"),(0,r.kt)("p",null,"For the following questions, don't start trying to write code right away. Instead, start by describing the recursive case in words. Some examples:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"In ",(0,r.kt)("inlineCode",{parentName:"li"},"fib")," from lecture, the recursive case is to add together the previous two Fibonacci numbers."),(0,r.kt)("li",{parentName:"ul"},"In ",(0,r.kt)("inlineCode",{parentName:"li"},"double_eights")," from lab, the recursive case is to check for double eights in the rest of the number."),(0,r.kt)("li",{parentName:"ul"},"In ",(0,r.kt)("inlineCode",{parentName:"li"},"count_partitions")," from lecture, the recursive case is to partition ",(0,r.kt)("inlineCode",{parentName:"li"},"n-m")," using parts up to size ",(0,r.kt)("inlineCode",{parentName:"li"},"m")," ",(0,r.kt)("strong",{parentName:"li"},"and")," to partition ",(0,r.kt)("inlineCode",{parentName:"li"},"n")," using parts up to size ",(0,r.kt)("inlineCode",{parentName:"li"},"m-1"),".")),(0,r.kt)("h3",{id:"q1-insect-combinatorics"},"Q1: Insect Combinatorics"),(0,r.kt)("p",null,"An insect is inside an ",(0,r.kt)("inlineCode",{parentName:"p"},"m")," by ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," grid. The insect starts at the bottom-left corner ",(0,r.kt)("inlineCode",{parentName:"p"},"(1, 1)")," and wants to end up at the top-right corner ",(0,r.kt)("inlineCode",{parentName:"p"},"(m, n)"),". The insect can only move up or to the right. Write a function ",(0,r.kt)("inlineCode",{parentName:"p"},"paths")," that takes the height and width of a grid and returns the number of paths the insect can take from the start to the end. (There is a ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Closed-form_expression"},"closed-form solution")," to this problem, but try to answer it with recursion.)"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Insect grids.",src:n(37838).Z,width:"473",height:"248"})),(0,r.kt)("p",null,"In the ",(0,r.kt)("inlineCode",{parentName:"p"},"2")," by ",(0,r.kt)("inlineCode",{parentName:"p"},"2")," grid, the insect has two paths from the start to the end. In the ",(0,r.kt)("inlineCode",{parentName:"p"},"3")," by ",(0,r.kt)("inlineCode",{parentName:"p"},"3")," grid, the insect has six paths (only three are shown above)."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Hint:")," What happens if the insect hits the upper or rightmost edge of the grid?")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Your Answer")),(0,r.kt)("p",null,"Run in 61A Code"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Solution")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'def paths(m, n):\n    """Return the number of paths from one corner of an\n    M by N grid to the opposite corner.\n\n    >>> paths(2, 2)\n    2\n    >>> paths(5, 7)\n    210\n    >>> paths(117, 1)\n    1\n    >>> paths(1, 157)\n    1\n    """\n    if m == 1 or n == 1:\n        return 1\n    return paths(m - 1, n) + paths(m, n - 1)\n    # Base case: Look at the two visual examples given. Since the insect\n    # can only move to the right or up, once it hits either the rightmost edge\n    # or the upper edge, it has a single remaining path -- the insect has\n    # no choice but to go straight up or straight right (respectively) at that point.\n    # There is no way for it to backtrack by going left or down.\n\n')),(0,r.kt)("p",null,"The recursive case is that there are paths from the square to the right through an (m, n-1) grid and paths from the square above through an (m-1, n) grid."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Presentation Time:")," Once your group has converged on a solution, it's time to practice your ability to describe why your recursive case is correct. Pick a presenter, then send a message to the discuss-queue channel with the @discuss tag, your discussion group number, and the message \"Here's the path!\" and a member of the course staff will join your voice channel to hear your description and give feedback."),(0,r.kt)("h2",{id:"tree-recursion-with-lists"},"Tree Recursion with Lists"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"[","New","]")," Some of you already know list operations that we haven't covered yet, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"append"),". Don't use those today. All you need are list literals (e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"[1, 2, 3]"),"), item selection (e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"s[0]"),"), list addition (e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"[1] + [2, 3]"),"), ",(0,r.kt)("inlineCode",{parentName:"p"},"len")," (e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"len(s)"),"), and slicing (e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"s[1:]"),"). Use those! There will be plenty of time for other list operations when we introduce them next week."),(0,r.kt)("p",null,"The most important thing to remember about lists is that a non-empty list ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," can be split into its first element ",(0,r.kt)("inlineCode",{parentName:"p"},"s[0]")," and the rest of the list ",(0,r.kt)("inlineCode",{parentName:"p"},"s[1:]"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},">>> s = [2, 3, 6, 4]\n>>> s[0]\n2\n>>> s[1:]\n[3, 6, 4]\n")),(0,r.kt)("h3",{id:"q2-max-product"},"Q2: Max Product"),(0,r.kt)("p",null,"Implement ",(0,r.kt)("inlineCode",{parentName:"p"},"max_product"),", which takes a list of numbers and returns the maximum product that can be formed by multiplying together non-consecutive elements of the list. Assume that all numbers in the input list are greater than or equal to 1."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Your Answer")),(0,r.kt)("p",null,"Run in 61A Code"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Solution")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'def max_product(s):\n    """Return the maximum product of non-consecutive elements of s.\n\n    >>> max_product([10, 3, 1, 9, 2])   # 10 * 9\n    90\n    >>> max_product([5, 10, 5, 10, 5])  # 5 * 5 * 5\n    125\n    >>> max_product([])                 # The product of no numbers is 1\n    1\n    """\n    if s == []:\n        return 1\n    if len(s) == 1:\n        return s[0]\n    else:\n        return max(s[0] * max_product(s[2:]), max_product(s[1:]))\n        # OR\n        return max(s[0] * max_product(s[2:]), s[1] * max_product(s[3:]))\n\n')),(0,r.kt)("p",null,"First try multiplying the first element by the ",(0,r.kt)("inlineCode",{parentName:"p"},"max_product")," of everything after the first two elements (skipping the second element because it is consecutive with the first), then try skipping the first element and finding the ",(0,r.kt)("inlineCode",{parentName:"p"},"max_product")," of the rest. To find which of these options is better, use ",(0,r.kt)("inlineCode",{parentName:"p"},"max"),"."),(0,r.kt)("p",null,"A great way to get help is to talk to the course staff!"),(0,r.kt)("p",null,"This solution begins with the idea that we either include ",(0,r.kt)("inlineCode",{parentName:"p"},"s[0]")," in the product or not:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If we include ",(0,r.kt)("inlineCode",{parentName:"li"},"s[0]"),", we cannot include ",(0,r.kt)("inlineCode",{parentName:"li"},"s[1]"),"."),(0,r.kt)("li",{parentName:"ul"},"If we don't include ",(0,r.kt)("inlineCode",{parentName:"li"},"s[0]"),", we can include ",(0,r.kt)("inlineCode",{parentName:"li"},"s[1]"),".")),(0,r.kt)("p",null,"The recursive case is that we choose the larger of:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"multiplying ",(0,r.kt)("inlineCode",{parentName:"li"},"s[0]")," by the ",(0,r.kt)("inlineCode",{parentName:"li"},"max_product")," of ",(0,r.kt)("inlineCode",{parentName:"li"},"s[2:]")," (skipping ",(0,r.kt)("inlineCode",{parentName:"li"},"s[1]"),") OR"),(0,r.kt)("li",{parentName:"ul"},"just the ",(0,r.kt)("inlineCode",{parentName:"li"},"max_product")," of ",(0,r.kt)("inlineCode",{parentName:"li"},"s[1:]")," (skipping ",(0,r.kt)("inlineCode",{parentName:"li"},"s[0]"),")")),(0,r.kt)("p",null,"Here are some key ideas in translating this into code:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The built-in ",(0,r.kt)("inlineCode",{parentName:"li"},"max")," function can find the larger of two numbers, which in this case come from two recursive calls."),(0,r.kt)("li",{parentName:"ul"},"In every case, ",(0,r.kt)("inlineCode",{parentName:"li"},"max_product")," is called on a list of numbers and its return value is treated as a number.")),(0,r.kt)("p",null,"An expression for this recursive case is:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"max(s[0] * max_product(s[2:]), max_product(s[1:]))")),(0,r.kt)("p",null,"Since this expression never refers to ",(0,r.kt)("inlineCode",{parentName:"p"},"s[1]"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"s[2:]")," evaluates to the empty list even for a one-element list ",(0,r.kt)("inlineCode",{parentName:"p"},"s"),", the second base case (",(0,r.kt)("inlineCode",{parentName:"p"},"len(s) == 1"),") can be omitted if this recursive case is used."),(0,r.kt)("p",null,"The recursive solution above explores some options that we know in advance will not be the maximum, such as skipping both ",(0,r.kt)("inlineCode",{parentName:"p"},"s[0]")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"s[1]"),". Alternatively, the recursive case could be that we choose the larger of:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"multiplying ",(0,r.kt)("inlineCode",{parentName:"li"},"s[0]")," by the ",(0,r.kt)("inlineCode",{parentName:"li"},"max_product")," of ",(0,r.kt)("inlineCode",{parentName:"li"},"s[2:]")," (skipping ",(0,r.kt)("inlineCode",{parentName:"li"},"s[1]"),") OR"),(0,r.kt)("li",{parentName:"ul"},"multiplying ",(0,r.kt)("inlineCode",{parentName:"li"},"s[1]")," by the ",(0,r.kt)("inlineCode",{parentName:"li"},"max_product")," of ",(0,r.kt)("inlineCode",{parentName:"li"},"s[3:]")," (skipping ",(0,r.kt)("inlineCode",{parentName:"li"},"s[0]")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"s[2]"),")")),(0,r.kt)("p",null,"An expression for this recursive case is:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"max(s[0] * max_product(s[2:]), s[1] * max_product(s[3:]))")),(0,r.kt)("p",null,"Complete this sentence together and type your answer into your group's ",(0,r.kt)("a",{parentName:"p",href:"https://support.discord.com/hc/en-us/articles/4412085582359-Text-Channels-Text-Chat-In-Voice-Channels#h_01FMJT412WBX1MR4HDYNR8E95X"},"channel's text chat"),'. "The recursive case is to choose the larger of ... and ..."'),(0,r.kt)("h3",{id:"q3-sum-fun"},"Q3: Sum Fun"),(0,r.kt)("p",null,"Implement ",(0,r.kt)("inlineCode",{parentName:"p"},"sums(n, m)"),", which takes a total ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," and maximum ",(0,r.kt)("inlineCode",{parentName:"p"},"m"),". It returns a list of all lists:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"that sum to ",(0,r.kt)("inlineCode",{parentName:"li"},"n"),","),(0,r.kt)("li",{parentName:"ol"},"that contain only positive numbers up to ",(0,r.kt)("inlineCode",{parentName:"li"},"m"),", and"),(0,r.kt)("li",{parentName:"ol"},"in which no two adjacent numbers are the same.")),(0,r.kt)("p",null,"Two lists with the same numbers in a different order should both be returned."),(0,r.kt)("p",null,"Here's a recursive approach that matches the template below: build up the ",(0,r.kt)("inlineCode",{parentName:"p"},"result")," list by building all lists that sum to ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," and start with ",(0,r.kt)("inlineCode",{parentName:"p"},"k"),", for each ",(0,r.kt)("inlineCode",{parentName:"p"},"k")," from 1 to ",(0,r.kt)("inlineCode",{parentName:"p"},"m"),". For example, the result of ",(0,r.kt)("inlineCode",{parentName:"p"},"sums(5, 3)")," is made up of three lists:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[[1, 3, 1]]")," starts with 1,"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[[2, 1, 2], [2, 3]]")," start with 2, and"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[[3, 2]]")," starts with 3.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Hint:")," Use ",(0,r.kt)("inlineCode",{parentName:"p"},"[k] + s")," for a number ",(0,r.kt)("inlineCode",{parentName:"p"},"k")," and list ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," to build a list that starts with ",(0,r.kt)("inlineCode",{parentName:"p"},"k")," and then has all the elements of ",(0,r.kt)("inlineCode",{parentName:"p"},"s"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},">>> k = 2\n>>> s = [4, 3, 1]\n>>> [k] + s\n[2, 4, 3, 1]\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Your Answer")),(0,r.kt)("p",null,"Run in 61A Code"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Solution")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'def sums(n, m):\n    """Return lists that sum to n containing positive numbers up to m that\n    have no adjacent repeats.\n\n    >>> sums(5, 1)\n    []\n    >>> sums(5, 2)\n    [[2, 1, 2]]\n    >>> sums(5, 3)\n    [[1, 3, 1], [2, 1, 2], [2, 3], [3, 2]]\n    >>> sums(5, 5)\n    [[1, 3, 1], [1, 4], [2, 1, 2], [2, 3], [3, 2], [4, 1], [5]]\n    >>> sums(6, 3)\n    [[1, 2, 1, 2], [1, 2, 3], [1, 3, 2], [2, 1, 2, 1], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n    """\n    if n < 0:\n        return []\n    if n == 0:\n        sums_to_zero = []     # The only way to sum to zero using positives\n        return [sums_to_zero] # Return a list of all the ways to sum to zero\n    result = []\n    for k in range(1, m + 1):\n        result = result + [[k] + rest for rest in sums(n-k, m) if rest == [] or rest[0] != k]\n    return result\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"k")," is the first number in a list that sums to ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"rest")," is the rest of that list, so build a list that sums to ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),"."),(0,r.kt)("p",null,"Call ",(0,r.kt)("inlineCode",{parentName:"p"},"sums")," to build all of the lists that sum to ",(0,r.kt)("inlineCode",{parentName:"p"},"n-k")," so that they can be used to construct lists that sum to ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," by putting a ",(0,r.kt)("inlineCode",{parentName:"p"},"k")," on the front."),(0,r.kt)("p",null,'Here is where you ensure that "no two adjacent numbers are the same." Since ',(0,r.kt)("inlineCode",{parentName:"p"},"k")," will be the first number in the list you're building, it must not be equal to the first element of ",(0,r.kt)("inlineCode",{parentName:"p"},"rest")," (which will be the second number in the list you're building)."),(0,r.kt)("p",null,"The recursive case is that each list that sums to ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," is an integer ",(0,r.kt)("inlineCode",{parentName:"p"},"k")," (up to ",(0,r.kt)("inlineCode",{parentName:"p"},"m"),") followed by the elements of a list that sums to ",(0,r.kt)("inlineCode",{parentName:"p"},"n-k")," and does not start with ",(0,r.kt)("inlineCode",{parentName:"p"},"k"),"."),(0,r.kt)("p",null,"Here are some key ideas in translating this into code:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"rest")," is ",(0,r.kt)("inlineCode",{parentName:"li"},"[2, 3]"),", then ",(0,r.kt)("inlineCode",{parentName:"li"},"[1] + rest")," is ",(0,r.kt)("inlineCode",{parentName:"li"},"[1, 2, 3]"),"."),(0,r.kt)("li",{parentName:"ul"},"In the expression ",(0,r.kt)("inlineCode",{parentName:"li"},"[... for rest in sums(...) if ...]"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"rest")," will be bound to each of the lists within the list returned by the recursive call. For example, if ",(0,r.kt)("inlineCode",{parentName:"li"},"sums(3, 2)")," was called, then ",(0,r.kt)("inlineCode",{parentName:"li"},"rest")," would be bound to ",(0,r.kt)("inlineCode",{parentName:"li"},"[1, 2]")," (and then later ",(0,r.kt)("inlineCode",{parentName:"li"},"[2, 1]"),").")),(0,r.kt)("p",null,"In the solution, the expresson below creates a list of lists that start with ",(0,r.kt)("inlineCode",{parentName:"p"},"k")," and are followed by the elements of ",(0,r.kt)("inlineCode",{parentName:"p"},"rest"),", first checking that ",(0,r.kt)("inlineCode",{parentName:"p"},"rest")," does not also start with ",(0,r.kt)("inlineCode",{parentName:"p"},"k")," (which would construct a list starting with two k's)."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"[[k] + rest for rest in sums(n-k, m) if rest == [] or rest[0] != k]")),(0,r.kt)("p",null,"For example, in ",(0,r.kt)("inlineCode",{parentName:"p"},"sums(5, 2)")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"k")," equal to 2, the recursive call ",(0,r.kt)("inlineCode",{parentName:"p"},"sums(3, 2)")," would first assign ",(0,r.kt)("inlineCode",{parentName:"p"},"rest")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"[1, 2]"),", and so ",(0,r.kt)("inlineCode",{parentName:"p"},"[k] + rest")," would be ",(0,r.kt)("inlineCode",{parentName:"p"},"[2, 1, 2]"),". Then, it would assign rest to ",(0,r.kt)("inlineCode",{parentName:"p"},"[2, 1]")," which would be skipped by the ",(0,r.kt)("inlineCode",{parentName:"p"},"if"),", avoiding ",(0,r.kt)("inlineCode",{parentName:"p"},"[2, 2, 1]"),", which has two adjacent 2's."),(0,r.kt)("p",null,"You can use recursion visualizer to step through the call structure of ",(0,r.kt)("inlineCode",{parentName:"p"},"sums(5, 3)"),"."),(0,r.kt)("p",null,"If you get stuck and want to talk with the staff, post on Discord!"),(0,r.kt)("h2",{id:"document-the-occasion"},"Document the Occasion"),(0,r.kt)("p",null,"Please all fill out the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.google.com/forms/d/e/1FAIpQLSeqlK8l6WkScGr-RHR-kM4p5bnR9cllYrG95fDqPJspSlll7A/viewform"},"attendance form")," (one submission per person per week)."))}m.isMDXComponent=!0},87210:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/files/disc04-8fcabd16db80d61c0d210604b6028dea.pdf"},37838:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/grid-b3ad3b8384cd4cef168b8070828e50d3.jpg"}}]);