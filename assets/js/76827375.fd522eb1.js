"use strict";(self.webpackChunklearncs_set=self.webpackChunklearncs_set||[]).push([[4879],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var i=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=i.createContext({}),h=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=h(e.components);return i.createElement(s.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=h(n),d=o,m=p["".concat(s,".").concat(d)]||p[d]||c[d]||a;return n?i.createElement(m,r(r({ref:t},u),{},{components:n})):i.createElement(m,r({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,r=new Array(a);r[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:o,r[1]=l;for(var h=2;h<a;h++)r[h]=n[h];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},18307:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>l,toc:()=>h});var i=n(87462),o=(n(67294),n(3905));const a={title:"Lab 05 Disjoint Sets"},r=void 0,l={unversionedId:"curriculum-resource/cs61b/labs/lab05/index",id:"curriculum-resource/cs61b/labs/lab05/index",title:"Lab 05 Disjoint Sets",description:"FAQ Page",source:"@site/docs/curriculum-resource/cs61b/labs/lab05/index.md",sourceDirName:"curriculum-resource/cs61b/labs/lab05",slug:"/curriculum-resource/cs61b/labs/lab05/",permalink:"/docs/curriculum-resource/cs61b/labs/lab05/",draft:!1,tags:[],version:"current",frontMatter:{title:"Lab 05 Disjoint Sets"},sidebar:"tutorialSidebar",previous:{title:"How to Use the Terminal",permalink:"/docs/curriculum-resource/cs61b/labs/lab04/terminal"},next:{title:"FAQ",permalink:"/docs/curriculum-resource/cs61b/labs/lab05/faq"}},s={},h=[{value:"FAQ Page",id:"faq-page",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Disjoint Sets",id:"disjoint-sets",level:2},{value:"Quick Union",id:"quick-union",level:3},{value:"Weighted Quick Union",id:"weighted-quick-union",level:3},{value:"Example",id:"example",level:3},{value:"Path Compression",id:"path-compression",level:3},{value:"Exercise: <code>UnionFind</code>",id:"exercise-unionfind",level:2},{value:"Lab Notes",id:"lab-notes",level:2},{value:"Testing",id:"testing",level:2},{value:"Submission",id:"submission",level:2}],u={toc:h},p="wrapper";function c(e){let{components:t,...a}=e;return(0,o.kt)(p,(0,i.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"faq-page"},"FAQ Page"),(0,o.kt)("p",null,"Please use our ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"/docs/curriculum-resource/cs61b/labs/lab05/faq"},"common issues and frequently asked questions page")),"\nas a resource. We'll be updating this FAQ page on the website throughout the\nweek!"),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"Today, we will delve a little deeper into disjoint sets. We ",(0,o.kt)("strong",{parentName:"p"},"strongly recommend")," that you watch the\nlecture on disjoint sets before starting on this lab, as it will cover material that you will\nneed to know to get started. "),(0,o.kt)("p",null,"For this week's lab, we will be implementing our own disjoint sets, ",(0,o.kt)("inlineCode",{parentName:"p"},"UnionFind"),". More specifically, we\nwill be implementing Weighted Quick Union + Path Compression. "),(0,o.kt)("p",null,"While we will briefly cover the concepts needed, please reference lecture for more information. "),(0,o.kt)("p",null,"As usual, pull the files from the skeleton: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"git pull skeleton main\n")),(0,o.kt)("h2",{id:"disjoint-sets"},"Disjoint Sets"),(0,o.kt)("p",null,"As a recap, let's cover what disjoint sets are. The ",(0,o.kt)("strong",{parentName:"p"},"disjoint sets data structure")," represents a collection\nof sets that are disjoint, meaning that any item in this data structure is found in no more than one set. "),(0,o.kt)("p",null,"For disjoint sets, we generally limit ourselves to two main operations: ",(0,o.kt)("inlineCode",{parentName:"p"},"union")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"find"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"union")," operation\nwill combine two sets into one set. The ",(0,o.kt)("inlineCode",{parentName:"p"},"find")," operation will take in an item, and tell us which set that\nitem belongs to. With these operations, we're able to easily check if two items are connected to each other."),(0,o.kt)("h3",{id:"quick-union"},"Quick Union"),(0,o.kt)("p",null,"As introduced in lecture, we talked about quick union. With this representation, we can think of our disjoint sets\ndata structure as a tree. Specifically, the tree would have the following qualities:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the nodes will be the items in our set,"),(0,o.kt)("li",{parentName:"ul"},"each node only needs a reference to its parent rather than a direct reference\nto the face of the set, and"),(0,o.kt)("li",{parentName:"ul"},'the top of each tree (we refer to this top as the "root" of the tree) will be\nthe face of the set it represents.')),(0,o.kt)("p",null,"However, one of the problems with this approach is that the worst case runtime of ",(0,o.kt)("inlineCode",{parentName:"p"},"union")," would be\nlinear, depending on how items are connected. In other words, the trees can get really tall, leading\nto poor performance for ",(0,o.kt)("inlineCode",{parentName:"p"},"union"),". For example, take a look at the example below - why would this lead\nto the worst case runtime?"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"worst",src:n(38613).Z,width:"300",height:"409"})),(0,o.kt)("p",null,"Now, let's combat the shortcomings of this data structure with the following\noptimizations."),(0,o.kt)("h3",{id:"weighted-quick-union"},"Weighted Quick Union"),(0,o.kt)("p",null,'The first optimization that we will do for our quick union data structure is\ncalled "union by size". This will be done in order to keep the trees as shallow\nas possible and avoid the spindly trees that result in the worst-case runtimes.\nWhen we ',(0,o.kt)("inlineCode",{parentName:"p"},"union")," two trees, we will make the smaller tree (the tree with less\nnodes) a subtree of the larger\none, breaking ties arbitrarily. We call this ",(0,o.kt)("strong",{parentName:"p"},"weighted quick union"),"."),(0,o.kt)("p",null,'Because we are now using "union by size", the maximum depth of any item will be\nin $$O(\\log N)$$, where $$N$$ is the number of items stored in the data\nstructure. This is a great improvement over the linear time runtime of the\nunoptimized quick union. Some brief intuition for this depth is because the\ndepth of any element $$x$$ only increases when the tree $$T_1$$ that contains\n$$x$$ is placed below another tree $$T_2$$. When that happens, the size of the\nresulting tree will be at least double the size of $$T_1$$ because $$size(T_2)\n\\ge size(T_1)$$. The tree that contains only $$x$$ can double its size at most\n$$\\log N$$ times until we have reached a total of $$N$$ items.'),(0,o.kt)("p",null,"See the following visual for some intuition on how this works:\n",(0,o.kt)("img",{alt:"Weighted Quick Union",src:n(63899).Z,width:"1562",height:"796"})),(0,o.kt)("h3",{id:"example"},"Example"),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("strong",{parentName:"p"},"The tie-breaking scheme in this example is that the smallest element becomes the root - note that this isn't\nalways the case depending on the implementation."))),(0,o.kt)("p",null,"Let's go over a example of what this all looks like for weighted quick union. When we initially\ncreate our disjoint set, each item is in its own set, so we will initialize all of the\nelements in the array to ",(0,o.kt)("inlineCode",{parentName:"p"},"-1"),". For this representation, we want to track our size\nin the array, so we ",(0,o.kt)("strong",{parentName:"p"},"store the weight of a set at its root as the negated weight (-weight)"),"\n(to also distinguish between a parent and the weight of the set)."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"initial",src:n(88545).Z,width:"978",height:"434"})),(0,o.kt)("p",null,"After we call ",(0,o.kt)("inlineCode",{parentName:"p"},"union(0,1)")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"union(2,3)"),", our array and our abstract representation will end up as below"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"union1",src:n(30897).Z,width:"1090",height:"576"})),(0,o.kt)("p",null,"Notice that for above, the values stored at 0 and 2 are -2, as the roots of the respective\nset are storing their (negated) size. Now let's call ",(0,o.kt)("inlineCode",{parentName:"p"},"union(0,2)"),". It'll look like this: "),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"union2",src:n(94864).Z,width:"450",height:"474"})),(0,o.kt)("p",null,"For the sake of an example, let's say we have another disjoint set, in the current\nstate shown below (we are using the same tie-breaking scheme above):"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"wqu1",src:n(9354).Z,width:"2074",height:"1153"})),(0,o.kt)("p",null,"If we were to connect the two larger sets, through ",(0,o.kt)("inlineCode",{parentName:"p"},"union(7, 2)"),", we would get the following:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"wqu2",src:n(44379).Z,width:"2033",height:"1167"})),(0,o.kt)("p",null,"In this case, we connect the roots of the sets that 7 and 2 belong to respectively, with the smaller\nset's root becoming the child of the larger set's root. With weighted quick union, we update two values\nin the array: "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the smaller root's parent becomes the root of the larger set "),(0,o.kt)("li",{parentName:"ul"},"the larger root's value is updated accordingly with a new size")),(0,o.kt)("h3",{id:"path-compression"},"Path Compression"),(0,o.kt)("p",null,"Even though we have made a speedup by using a weighted quick union data\nstructure, there is still yet another optimization that we can do! What would\nhappen if we had a tall tree and called ",(0,o.kt)("inlineCode",{parentName:"p"},"find")," repeatedly on the deepest leaf?\nEach time, we would have to traverse the tree from the leaf to the root."),(0,o.kt)("p",null,"A clever optimization is to move the leaf up the tree so it becomes a direct\nchild of the root. That way, the next time you call ",(0,o.kt)("inlineCode",{parentName:"p"},"find")," on that leaf, it\nwill run much more quickly. An even more clever idea is that we could do the\nsame thing to ",(0,o.kt)("em",{parentName:"p"},"every")," node that is on the path from the leaf to the root.\nSpecifically, when we call ",(0,o.kt)("inlineCode",{parentName:"p"},"find")," on an item, all of the nodes that were\ntraversed upon going up the tree (to the root) are updated so that they are\nnow connected directly to the root. This optimization is called ",(0,o.kt)("strong",{parentName:"p"},"path compression"),".\nOnce you find an item, path compression will make finding it (and all the nodes\non the path to the root) in the future faster."),(0,o.kt)("p",null,"The runtime for any combination of $$f$$ ",(0,o.kt)("inlineCode",{parentName:"p"},"find")," and $$u$$ ",(0,o.kt)("inlineCode",{parentName:"p"},"union")," operations\ntakes $$\\Theta(u + f \\alpha(f+u,u))$$ time, where $$\\alpha$$ is an ",(0,o.kt)("em",{parentName:"p"},"extremely"),"\nslowly-growing function called the ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Ackermann_function#Inverse"},(0,o.kt)("em",{parentName:"a"},"inverse Ackermann function")),'. And by\n"extremely slowly-growing", we mean it grows so slowly that for any practical\ninput that you will ever use, the inverse Ackermann function will never be\nlarger than 4. That means for any practical purpose, a weighted quick union data\nstructure with path compression has ',(0,o.kt)("inlineCode",{parentName:"p"},"find")," operations that take constant time on\naverage!"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"It is important to note that even though this operation can be considered\nconstant time for all practically sized inputs, we should not describe\nthis whole data structure as constant time. We could say something like,\nit will be constant for all inputs smaller than some incredibly large size.\nWithout that qualification we should still describe it by using the inverse\nAckermann function.")),(0,o.kt)("p",null,"An example of this is shown below, where we start out with the following"),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"This is only an example to demonstrate what path compression does.\n",(0,o.kt)("strong",{parentName:"p"},"Note that you can't get this structure (the first image,\ndirectly below) with a weighted quick union."))),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"path_compression_before",src:n(8827).Z,width:"577",height:"767"})),(0,o.kt)("p",null,"After we call on ",(0,o.kt)("inlineCode",{parentName:"p"},"find(5)"),", all of the nodes we traversed to get to the root\nare updated so that they now connect directly to the root: "),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"path_compression_after",src:n(10919).Z,width:"571",height:"765"})),(0,o.kt)("p",null,"You can visit this link\n",(0,o.kt)("a",{parentName:"p",href:"http://www.cs.usfca.edu/~galles/visualization/DisjointSets.html"},"here")," to play\naround with disjoint sets."),(0,o.kt)("h2",{id:"exercise-unionfind"},"Exercise: ",(0,o.kt)("inlineCode",{parentName:"h2"},"UnionFind")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"For ",(0,o.kt)("inlineCode",{parentName:"p"},"UnionFind"),", you will be implementing a ",(0,o.kt)("strong",{parentName:"p"},"weighted quick union with path compression."))),(0,o.kt)("p",null,"We will now implement our own disjoint sets data structure, ",(0,o.kt)("inlineCode",{parentName:"p"},"UnionFind"),". At this point, if you haven't already,\ntake a look at ",(0,o.kt)("inlineCode",{parentName:"p"},"UnionFind.java")," file. In this file, you'll see that some skeleton code has been provided for\nyou - you'll have to fill in the implementation for the following methods:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"UnionFind(int N)"),": This is the constructor. It creates a ",(0,o.kt)("inlineCode",{parentName:"li"},"UnionFind")," data structure that holds N items."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"int sizeOf(int v)"),": Returns the size of the set that ",(0,o.kt)("inlineCode",{parentName:"li"},"v")," belongs to."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"int parent(int v)"),": Returns the parent of v."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"boolean connected(int v1, int v2)"),": Returns ",(0,o.kt)("inlineCode",{parentName:"li"},"true")," if the two vertices are connected."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"int find(int v)"),": Returns the root of the set that ",(0,o.kt)("inlineCode",{parentName:"li"},"v")," belongs to."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"void union(int v1, int v2)"),": Connects ",(0,o.kt)("inlineCode",{parentName:"li"},"v1")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"v2")," together.")),(0,o.kt)("p",null,"We recommend that you start with implementing the constructor and taking a look at ",(0,o.kt)("inlineCode",{parentName:"p"},"find"),"\nbefore the rest of the other methods.  "),(0,o.kt)("p",null,":::task\nComplete the methods in ",(0,o.kt)("inlineCode",{parentName:"p"},"UnionFind"),". ",(0,o.kt)("strong",{parentName:"p"},"You'll want to use ",(0,o.kt)("inlineCode",{parentName:"strong"},"find")," in ",(0,o.kt)("inlineCode",{parentName:"strong"},"union"),"."),"\n:::"),(0,o.kt)("h2",{id:"lab-notes"},"Lab Notes"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Please note, for this lab, we will work with non-negative integers as the items\nin our disjoint sets.")),(0,o.kt)("p",null,"Comments have been provided for each method and will go into a little more detail\nthan the summary above, so make sure to read those carefully to understand what\nyou'll want to implement. Remember to implement both optimizations discussed\nabove, and take note of the ",(0,o.kt)("strong",{parentName:"p"},"tie-breaking scheme")," that is described in the comments\nof some of the methods."),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"For this lab, you'll want to implement the following tie-breaking scheme: if the sizes\nof the sets are equal, ",(0,o.kt)("strong",{parentName:"p"},"tie break by connecting ",(0,o.kt)("inlineCode",{parentName:"strong"},"v1'"),"'s root to ",(0,o.kt)("inlineCode",{parentName:"strong"},"v2"),"'s root."))),(0,o.kt)("p",null,"You should also correctly handle faulty inputs, e.g if invalid vertices are passed\ninto the functions, throw an ",(0,o.kt)("inlineCode",{parentName:"p"},"IllegalArgumentException"),". You can throw an\n",(0,o.kt)("inlineCode",{parentName:"p"},"IllegalArgumentException")," with the following line: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'throw new IllegalArgumentException("Some comment to describe the reason for throwing.");\n')),(0,o.kt)("h2",{id:"testing"},"Testing"),(0,o.kt)("admonition",{type:"danger"},(0,o.kt)("p",{parentName:"admonition"},"For this lab, we've provided some tests for you to check your implementation,\nbut they are ",(0,o.kt)("strong",{parentName:"p"},"not comprehensive.")," Only 4 out of 6 tests on the autograder are\nprovided locally. Passing the tests locally do not mean you will pass the tests on\nGradescope and you will need to write your own tests to verify correctness. ")),(0,o.kt)("p",null,"If you find yourself failing the last two tests, ensure that you've\nimplemented path compression correctly and that you've tested the\ncorrectness for ",(0,o.kt)("em",{parentName:"p"},"all the methods")," you've implemented. "),(0,o.kt)("h2",{id:"submission"},"Submission"),(0,o.kt)("p",null,"Just as you did for the previous assignments, add, commit, then push your Lab 05 code to GitHub. Then,\nsubmit to Gradescope."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Complete the implementation of ",(0,o.kt)("inlineCode",{parentName:"li"},"UnionFind.java"),". This lab is worth 5 points in total.")))}c.isMDXComponent=!0},88545:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/initial-43839503aa8e4ade61283ebccaad2293.png"},10919:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/path_compression_after-5afae2b7a302815fb07f4ee78fe9bdff.png"},8827:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/path_compression_before-41f4c11d385ec535a500d70daa65dfc8.png"},30897:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/union1-4dc445f8ed4a683bcd70dccb0345ba36.png"},94864:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/union2-3a07b34cbe1f6abc4eb1b2300ade8266.png"},63899:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/weighted-5161fa7859093dfbb98b03a5fa3025bc.png"},38613:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/worst-51c234885f06f9b3a46d903683e53b7e.png"},44379:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/wqu_after-3404865155a498523e39dc61c25a58b5.png"},9354:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/wqu_before-eb50616ab3e57ec8be584e737ccbeeef.png"}}]);