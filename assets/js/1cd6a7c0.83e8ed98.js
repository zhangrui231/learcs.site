"use strict";(self.webpackChunklearncs_set=self.webpackChunklearncs_set||[]).push([[14124],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),p=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return o.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),c=p(n),m=a,h=c["".concat(s,".").concat(m)]||c[m]||d[m]||i;return n?o.createElement(h,l(l({ref:t},u),{},{components:n})):o.createElement(h,l({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=m;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r[c]="string"==typeof e?e:a,l[1]=r;for(var p=2;p<i;p++)l[p]=n[p];return o.createElement.apply(null,l)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9724:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>p});var o=n(87462),a=(n(67294),n(3905));const i={title:"Project 03"},l=void 0,r={unversionedId:"curriculum-resource/15-445/project/project04",id:"curriculum-resource/15-445/project/project04",title:"Project 03",description:"Remember to pull the latest code from the bustub repository. Do not post your code on a public GitHub repository.",source:"@site/docs/curriculum-resource/15-445/project/project04.md",sourceDirName:"curriculum-resource/15-445/project",slug:"/curriculum-resource/15-445/project/project04",permalink:"/docs/curriculum-resource/15-445/project/project04",draft:!1,tags:[],version:"current",frontMatter:{title:"Project 03"},sidebar:"tutorialSidebar",previous:{title:"Project 02",permalink:"/docs/curriculum-resource/15-445/project/project03"},next:{title:"Project 04",permalink:"/docs/curriculum-resource/15-445/project/project05"}},s={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Inspecting SQL Query Plans",id:"inspecting-sql-query-plans",level:2},{value:"Sample Executors",id:"sample-executors",level:2},{value:"Projection",id:"projection",level:3},{value:"Filter",id:"filter",level:3},{value:"Values",id:"values",level:3},{value:"Query Plan Syntax",id:"query-plan-syntax",level:2},{value:"Task #1 - Access Method Executors",id:"task-1---access-method-executors",level:2},{value:"SeqScan",id:"seqscan",level:3},{value:"Insert",id:"insert",level:3},{value:"Update",id:"update",level:3},{value:"Delete",id:"delete",level:3},{value:"IndexScan",id:"indexscan",level:3},{value:"Optimizing SeqScan to IndexScan",id:"optimizing-seqscan-to-indexscan",level:3},{value:"Task #2 - Aggregation &amp; Join Executors",id:"task-2---aggregation--join-executors",level:2},{value:"Aggregation",id:"aggregation",level:3},{value:"NestedLoopJoin",id:"nestedloopjoin",level:3},{value:"NestedIndexJoin",id:"nestedindexjoin",level:3},{value:"Task #3 - HashJoin Executor and Optimization",id:"task-3---hashjoin-executor-and-optimization",level:2},{value:"HashJoin",id:"hashjoin",level:3},{value:"Optimizing NestedLoopJoin to HashJoin",id:"optimizing-nestedloopjoin-to-hashjoin",level:3},{value:"Task #4: External Merge Sort + Limit Executors",id:"task-4-external-merge-sort--limit-executors",level:2},{value:"External Merge Sort",id:"external-merge-sort",level:3},{value:"Limit",id:"limit",level:3},{value:"Optional Leaderboard Tasks",id:"optional-leaderboard-tasks",level:2},{value:"Query 1: Too Many Joins!",id:"query-1-too-many-joins",level:3},{value:"Query 2: The Mad Data Scientist",id:"query-2-the-mad-data-scientist",level:3},{value:"Query 3: All that work, for nothing?",id:"query-3-all-that-work-for-nothing",level:3},{value:"Leaderboard Policy",id:"leaderboard-policy",level:3},{value:"System Catalog",id:"system-catalog",level:2},{value:"Index Updates",id:"index-updates",level:2},{value:"Optimizer Rule Implementation Guide",id:"optimizer-rule-implementation-guide",level:2},{value:"Testing",id:"testing",level:2},{value:"Formatting",id:"formatting",level:2},{value:"Memory Leaks",id:"memory-leaks",level:2},{value:"Development Hints",id:"development-hints",level:2}],u={toc:p},c="wrapper";function d(e){let{components:t,...i}=e;return(0,a.kt)(c,(0,o.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Remember to pull the latest code from the bustub repository. Do not post your code on a public GitHub repository."),(0,a.kt)("h1",{id:"overview"},"Overview"),(0,a.kt)("p",null,"At this point in the semester, you have implemented many internal components of a database management system.\nIn ",(0,a.kt)("a",{parentName:"p",href:"https://15445.courses.cs.cmu.edu/fall2024/project1"},"Project #1"),", you implemented a buffer pool manager. In ",(0,a.kt)("a",{parentName:"p",href:"https://15445.courses.cs.cmu.edu/fall2024/project2"},"Project #2"),", you implemented a b-plus tree index. In this project, you will implement the components that allow BusTub to execute queries. You will create the operator executors that execute SQL queries and implement optimizer rules to transform query plans."),(0,a.kt)("p",null,"This project is composed of several tasks:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://15445.courses.cs.cmu.edu/fall2024/project3/#task1"},(0,a.kt)("strong",{parentName:"a"},"Task #1: Access Method Executors"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://15445.courses.cs.cmu.edu/fall2024/project3/#task2"},(0,a.kt)("strong",{parentName:"a"},"Task #2: Aggregation and Join Executors"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://15445.courses.cs.cmu.edu/fall2024/project3/#task3"},(0,a.kt)("strong",{parentName:"a"},"Task #3: HashJoin Executor and Optimization"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://15445.courses.cs.cmu.edu/fall2024/project3/#task4"},(0,a.kt)("strong",{parentName:"a"},"Task #4: External Merge Sort + Limit Executors"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://15445.courses.cs.cmu.edu/fall2024/project3/#leaderboard"},(0,a.kt)("strong",{parentName:"a"},"Optional Leaderboard Task")))),(0,a.kt)("p",null,"This project must be completed individually (i.e., no groups).\nBefore starting, run ",(0,a.kt)("inlineCode",{parentName:"p"},"git pull public master")," to pull the latest code from the public ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cmu-db/bustub"},"BusTub repo"),"."),(0,a.kt)("h1",{id:"background"},"Background"),(0,a.kt)("p",null,"Please read this section carefully because you will need to construct your own SQL queries to test your executor implementation. You can also use the ",(0,a.kt)("inlineCode",{parentName:"p"},"bustub shell")," to understand:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use ",(0,a.kt)("inlineCode",{parentName:"li"},"EXPLAIN")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"EXPLAIN (o)")," to show raw and optimized plans"),(0,a.kt)("li",{parentName:"ul"},"Understand parameters in plan nodes (i.e., what the first and second 0 means in ",(0,a.kt)("inlineCode",{parentName:"li"},"#0.0"),")"),(0,a.kt)("li",{parentName:"ul"},"Read a few simple plan node implementations in ",(0,a.kt)("inlineCode",{parentName:"li"},"include/execution/plans/")),(0,a.kt)("li",{parentName:"ul"},"Pay attention to various expression types in ",(0,a.kt)("inlineCode",{parentName:"li"},"include/execution/expressions/"))),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"BusTub's architecture is as follows:"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://15445.courses.cs.cmu.edu/fall2024/project3/img/project-structure.svg"},(0,a.kt)("img",{src:n(57542).Z,width:"960",height:"720"}))),(0,a.kt)("p",null,"In the public BusTub repository, we provide a full query processing layer. You can use the BusTub shell to execute SQL queries, much like in other database systems. Use the following command to compile and run the BusTub shell:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"cd build && make -j$(nproc) shell\n./bin/bustub-shell\n\n")),(0,a.kt)("p",null,"You can also use ",(0,a.kt)("a",{parentName:"p",href:"https://15445.courses.cs.cmu.edu/fall2024/bustub/"},"BusTub Web Shell")," to run the examples below. It is a complete reference solution of the system running in your browser!"),(0,a.kt)("p",null,"Within the shell, you can use ",(0,a.kt)("inlineCode",{parentName:"p"},"\\dt")," to view all tables. By default, the BusTub shell will automatically create three tables that are pre-populated with data. This is provided as a convenience so that you do not need to load data every time you rebuild your solution. Changes to these tables will not be persisted when you restart the DBMS."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"bustub> \\dt\n+-----+----------------+------------------------------+\n| oid | name           | cols                         |\n+-----+----------------+------------------------------+\n| 0   | __mock_table_1 | (colA:INTEGER, colB:INTEGER) |\n| 1   | __mock_table_2 | (colC:VARCHAR, colD:VARCHAR) |\n| 2   | __mock_table_3 | (colE:INTEGER, colF:VARCHAR) |\n| ... | ...            | ...                          |\n+-----+----------------+------------------------------+\n\n")),(0,a.kt)("p",null,"You can view all data from a table by using the ",(0,a.kt)("inlineCode",{parentName:"p"},"SELECT")," statement:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"bustub> SELECT * FROM __mock_table_1;\n+---------------------+---------------------+\n| __mock_table_1.colA | __mock_table_1.colB |\n+---------------------+---------------------+\n| 0                   | 0                   |\n| 1                   | 100                 |\n| 2                   | 200                 |\n| 3                   | 300                 |\n| 4                   | 400                 |\n| 5                   | 500                 |\n| ...                 | ...                 |\n+---------------------+---------------------+\n\n")),(0,a.kt)("p",null,"Please note:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"BusTub only supports a small subset of SQL. Don't be surprised if it does not work with some SQL queries. For all SQL queries supported in BusTub, refer to the SQLLogicTest files in ",(0,a.kt)("inlineCode",{parentName:"li"},"tests/sql"),"."),(0,a.kt)("li",{parentName:"ul"},"If you are using CLion to run the BusTub shell, please add a ",(0,a.kt)("inlineCode",{parentName:"li"},"--disable-tty")," parameter to the shell, so that it works correctly in the CLion terminal."),(0,a.kt)("li",{parentName:"ul"},"Always end your statement with ",(0,a.kt)("inlineCode",{parentName:"li"},";")," (except internal commands)."),(0,a.kt)("li",{parentName:"ul"},"BusTub only supports ",(0,a.kt)("inlineCode",{parentName:"li"},"INT")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"VARCHAR(n)")," type. Also you should use single quotes for strings, e.g., ",(0,a.kt)("inlineCode",{parentName:"li"},"INSERT INTO table VALUES ('a')"),".")),(0,a.kt)("h2",{id:"inspecting-sql-query-plans"},"Inspecting SQL Query Plans"),(0,a.kt)("p",null,"BusTub supports the ",(0,a.kt)("inlineCode",{parentName:"p"},"EXPLAIN")," command to print a query's execution plan. You can add ",(0,a.kt)("inlineCode",{parentName:"p"},"EXPLAIN")," in front of any query. For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"bustub> EXPLAIN SELECT * FROM __mock_table_1;\n=== BINDER ===\nBoundSelect {\n  table=BoundBaseTableRef { table=__mock_table_1, oid=0 },\n  columns=[__mock_table_1.colA, __mock_table_1.colB],\n  groupBy=[],\n  having=,\n  where=,\n  limit=,\n  offset=,\n  order_by=[],\n  is_distinct=false,\n}\n=== PLANNER ===\nProjection { exprs=[#0.0, #0.1] } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)\nMockScan { table=__mock_table_1 } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)\n=== OPTIMIZER ===\nMockScan { table=__mock_table_1 } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)\n\n")),(0,a.kt)("p",null,"The result of ",(0,a.kt)("inlineCode",{parentName:"p"},"EXPLAIN")," provides an overview of the transformation process within the query processing layer. The statement is first processed by the parser and the binder, which produces an abstract syntax tree (AST) representing the query. In this example, the query is represented by a ",(0,a.kt)("inlineCode",{parentName:"p"},"BoundSelect")," on ",(0,a.kt)("inlineCode",{parentName:"p"},"__mock_table_1")," that will retrieve two columns ( ",(0,a.kt)("inlineCode",{parentName:"p"},"colA")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"colB"),"). Note that the binder automatically expands the ",(0,a.kt)("inlineCode",{parentName:"p"},"*")," character from the original SQL query into the actual columns in the table."),(0,a.kt)("p",null,"Next, the binder AST is processed by the planner, which will produce an appropriate query plan. In this case, the query plan is a tree of two nodes, with data flowing from the leaves to the root:"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://15445.courses.cs.cmu.edu/fall2024/project3/img/mock_scan.svg"},(0,a.kt)("img",{src:n(94283).Z,width:"960",height:"469"}))),(0,a.kt)("p",null,"After that, the optimizer will optimize the query plan. In this case, it removes the projection because it is redundant."),(0,a.kt)("p",null,"Let's consider a more complex example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"bustub> EXPLAIN (o) SELECT colA, MAX(colB) FROM\n  (SELECT * FROM __mock_table_1, __mock_table_3 WHERE colA = colE) GROUP BY colA;\n=== OPTIMIZER ===\nAgg { types=[max], aggregates=[#0.1], group_by=[#0.0] }\n  NestedLoopJoin { type=Inner, predicate=(#0.0=#1.0) }\n    MockScan { table=__mock_table_1 }\n    MockScan { table=__mock_table_3 }\n\n")),(0,a.kt)("p",null,"For this example, the optimized query plan is:"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://15445.courses.cs.cmu.edu/fall2024/project3/img/more_complex_example.svg"},(0,a.kt)("img",{src:n(73099).Z,width:"960",height:"720"}))),(0,a.kt)("p",null,"In this project, you will need to construct SQL queries to test each of your executor's implementations. ",(0,a.kt)("inlineCode",{parentName:"p"},"EXPLAIN")," is extremely helpful for you to know if a SQL query is using a specific executor."),(0,a.kt)("h2",{id:"sample-executors"},"Sample Executors"),(0,a.kt)("p",null,"In the BusTub public repository, we provide several sample executor implementations."),(0,a.kt)("h3",{id:"projection"},"Projection"),(0,a.kt)("p",null,"A ",(0,a.kt)("strong",{parentName:"p"},"projection")," node can represent various computations on its input. It will always have exactly one child node. In the BusTub shell, inspect the query plans for the following queries:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"EXPLAIN SELECT 1 + 2;\nEXPLAIN SELECT colA FROM __mock_table_1;\nEXPLAIN SELECT colA + colB AS a, 1 + 2 AS b FROM __mock_table_1;\n\n")),(0,a.kt)("p",null,"A projection plan node consists of one or more expressions representing a computation:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ColumnValueExpression"),": directly places a column of the child executor to the output. The syntax ",(0,a.kt)("inlineCode",{parentName:"li"},"#0.0")," means the first column in the first child. You will see something like ",(0,a.kt)("inlineCode",{parentName:"li"},"#0.0 = #1.0")," in a plan for joins."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ConstantExpression"),": represents a constant value (e.g., ",(0,a.kt)("inlineCode",{parentName:"li"},"1"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ArithmeticExpression"),": a tree representing an arithmetic computation. For example, ",(0,a.kt)("inlineCode",{parentName:"li"},"1 + 2")," would be represented by an ",(0,a.kt)("inlineCode",{parentName:"li"},"ArithmeticExpression")," with two ",(0,a.kt)("inlineCode",{parentName:"li"},"ConstantExpression")," ( ",(0,a.kt)("inlineCode",{parentName:"li"},"1")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"2"),") as children.")),(0,a.kt)("h3",{id:"filter"},"Filter"),(0,a.kt)("p",null,"A ",(0,a.kt)("strong",{parentName:"p"},"filter")," plan node is used to filter the output of a child given a predicate. For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"EXPLAIN SELECT * FROM __mock_table_1 WHERE colA > 1;\n\n")),(0,a.kt)("p",null,"A filter node has exactly one child and contains a predicate."),(0,a.kt)("h3",{id:"values"},"Values"),(0,a.kt)("p",null,"A ",(0,a.kt)("strong",{parentName:"p"},"values")," plan node is used to directly produce values:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"EXPLAIN values (1, 2, 'a'), (3, 4, 'b');\nCREATE TABLE table1(v1 INT, v2 INT, v3 VARCHAR(128));\nEXPLAIN INSERT INTO table1 VALUES (1, 2, 'a'), (3, 4, 'b');\n\n")),(0,a.kt)("p",null,"Values plan nodes are useful when inserting user-supplied values into a table."),(0,a.kt)("h2",{id:"query-plan-syntax"},"Query Plan Syntax"),(0,a.kt)("p",null,"As you might have noticed, ",(0,a.kt)("inlineCode",{parentName:"p"},"EXPLAIN")," produces a string of column descriptions after each plan node. That's the output schema of the node. Consider this example output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Projection { exprs=[#0.0, #0.1] } | (__mock_table_1.colA:INTEGER, __mock_table_1.colB:INTEGER)\n\n")),(0,a.kt)("p",null,"This indicates that the executor representing this plan node will produce two columns, both of integer types. The output schema is inferred within the planner. For this project, your executor implementations must produce tuples with schema exactly as specified in the plan node, or they will fail our unit tests."),(0,a.kt)("h1",{id:"project-specification"},"Project Specification"),(0,a.kt)("p",null,"In this project, you will add new operator executors and query optimizations to BusTub. BusTub uses the iterator (i.e., Volcano) query processing model, in which every executor implements a ",(0,a.kt)("inlineCode",{parentName:"p"},"Next")," function to get the next tuple result. When the DBMS invokes an executor's ",(0,a.kt)("inlineCode",{parentName:"p"},"Next")," function, the executor returns either (1) a single tuple or (2) an indicator that there are no more tuples. With this approach, each executor implements a loop that continues calling ",(0,a.kt)("inlineCode",{parentName:"p"},"Next")," on its children to retrieve tuples and process them one by one."),(0,a.kt)("p",null,"In BusTub's implementation of the iterator model, the ",(0,a.kt)("inlineCode",{parentName:"p"},"Next")," function for each executor returns a record identifier ( ",(0,a.kt)("inlineCode",{parentName:"p"},"RID"),") in addition to a tuple. A record identifier serves as a unique identifier for the tuple."),(0,a.kt)("p",null,"The executors are created from an execution plan in ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cmu-db/bustub/blob/master/src/execution/executor_factory.cpp",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/execution/executor_factory.cpp")),"."),(0,a.kt)("p",null,"All test cases in this project are written in a special file format called SQLLogicTest (derived from SQLite). You can find how to use it at the end of this page."),(0,a.kt)("h2",{id:"task-1---access-method-executors"},"Task ","#","1 - Access Method Executors"),(0,a.kt)("p",null,"In the background section above, we saw that the BusTub can already retrieve data from mock tables in ",(0,a.kt)("inlineCode",{parentName:"p"},"SELECT")," queries. This is implemented without real tables by using a ",(0,a.kt)("inlineCode",{parentName:"p"},"MockScan")," executor to always generate the same tuples using a predefined algorithm. This is why you cannot update these tables."),(0,a.kt)("p",null,"In this task, you will implement executors that read from and write to tables in the storage system. You will complete your implementation in the following files:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/include/execution/seq_scan_executor.h",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/include/execution/seq_scan_executor.h"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/execution/seq_scan_executor.cpp",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/execution/seq_scan_executor.cpp"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/include/execution/insert_executor.h",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/include/execution/insert_executor.h"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/execution/insert_executor.cpp",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/execution/insert_executor.cpp"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/include/execution/update_executor.h",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/include/execution/update_executor.h"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/execution/update_executor.cpp",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/execution/update_executor.cpp"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/include/execution/delete_executor.h",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/include/execution/delete_executor.h"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/execution/delete_executor.cpp",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/execution/delete_executor.cpp"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/include/execution/index_scan_executor.h",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/include/execution/index_scan_executor.h"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/execution/index_scan_executor.cpp",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/execution/index_scan_executor.cpp"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/optimizer/seqscan_as_indexscan.cpp",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/optimizer/seqscan_as_indexscan.cpp")))),(0,a.kt)("p",null,"Each of these executors is described below."),(0,a.kt)("h3",{id:"seqscan"},"SeqScan"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cmu-db/bustub/blob/master/src/include/execution/plans/seq_scan_plan.h"},(0,a.kt)("inlineCode",{parentName:"a"},"SeqScanPlanNode"))," can be planned with a ",(0,a.kt)("inlineCode",{parentName:"p"},"SELECT * FROM table")," statement."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"bustub> CREATE TABLE t1(v1 INT, v2 VARCHAR(100));\nTable created with id = 15\nbustub> EXPLAIN (o,s) SELECT * FROM t1;\n=== OPTIMIZER ===\nSeqScan { table=t1 } | (t1.v1:INTEGER, t1.v2:VARCHAR)\n\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"SeqScanExecutor")," iterates over a table and returns its tuples one at a time."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," Make sure that you understand the difference between the pre-increment and post-increment operators when using the ",(0,a.kt)("inlineCode",{parentName:"p"},"TableIterator")," object. (Check ",(0,a.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/operator_incdec"},"here")," for a quick refresher.)"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," Do not emit tuples that are deleted in the ",(0,a.kt)("inlineCode",{parentName:"p"},"TableHeap"),".\nCheck the ",(0,a.kt)("inlineCode",{parentName:"p"},"is_deleted_")," field of the corresponding ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cmu-db/bustub/blob/master/src/include/storage/table/tuple.h"},(0,a.kt)("inlineCode",{parentName:"a"},"TupleMeta"))," for each tuple."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," The output of sequential scan is a copy of each matched tuple and its original record identifier ( ",(0,a.kt)("inlineCode",{parentName:"p"},"RID"),")."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Note:")," BusTub does not support ",(0,a.kt)("inlineCode",{parentName:"p"},"DROP TABLE")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"DROP INDEX"),". You can reset your database by restarting the shell."),(0,a.kt)("h3",{id:"insert"},"Insert"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cmu-db/bustub/blob/master/src/include/execution/plans/insert_plan.h"},(0,a.kt)("inlineCode",{parentName:"a"},"InsertPlanNode"))," can be planned with an ",(0,a.kt)("inlineCode",{parentName:"p"},"INSERT")," statement. Note that you will need to use a single quote to specify a ",(0,a.kt)("inlineCode",{parentName:"p"},"VARCHAR")," value."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"bustub> EXPLAIN (o,s) INSERT INTO t1 VALUES (1, 'a'), (2, 'b');\n=== OPTIMIZER ===\nInsert { table_oid=15 } | (__bustub_internal.insert_rows:INTEGER)\n  Values { rows=2 } | (__values#0.0:INTEGER, __values#0.1:VARCHAR)\n\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"InsertExecutor")," inserts tuples into a table and updates any affected indexes. It has exactly one child producing values to be inserted into the table. The planner will ensure that the values have the same schema as the table. The executor will produce a single tuple of integer type as the output, indicating how many rows have been inserted into the table. Remember to update indexes when inserting into the table, if there are indexes associated with it."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," See the ",(0,a.kt)("a",{parentName:"p",href:"https://15445.courses.cs.cmu.edu/fall2024/project3/#system-catalog"},"System Catalog")," section below for information about the system catalog. To initialize this executor, you will need to look up information about the table being inserted into."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," See the ",(0,a.kt)("a",{parentName:"p",href:"https://15445.courses.cs.cmu.edu/fall2024/project3/#index-updates"},"Index Updates")," section below for further details about updating a table's indexes."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," You will need to use the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cmu-db/bustub/blob/master/src/include/storage/table/table_heap.h"},(0,a.kt)("inlineCode",{parentName:"a"},"TableHeap"))," class to perform table modifications."),(0,a.kt)("h3",{id:"update"},"Update"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cmu-db/bustub/blob/master/src/include/execution/plans/update_plan.h"},(0,a.kt)("inlineCode",{parentName:"a"},"UpdatePlanNode"))," can be planned with an ",(0,a.kt)("inlineCode",{parentName:"p"},"UPDATE")," statement. It has exactly one child with the records to be updated in the table."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"bustub> explain (o,s) update test_1 set colB = 15445;\n=== OPTIMIZER ===\nUpdate { table_oid=20, target_exprs=[#0.0, 15445, #0.2, #0.3] } | (__bustub_internal.update_rows:INTEGER)\n  SeqScan { table=test_1 } | (test_1.colA:INTEGER, test_1.colB:INTEGER, test_1.colC:INTEGER, test_1.colD:INTEGER)\n\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"UpdateExecutor")," modifies existing tuples in a specified table. The executor will produce a single tuple of integer type as the output, indicating how many rows have been updated. Remember to update any indexes affected by the updates."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," To implement an update, first delete the affected tuple and then insert a new tuple."),(0,a.kt)("h3",{id:"delete"},"Delete"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cmu-db/bustub/blob/master/src/include/execution/plans/delete_plan.h"},(0,a.kt)("inlineCode",{parentName:"a"},"DeletePlanNode"))," can be planned with a ",(0,a.kt)("inlineCode",{parentName:"p"},"DELETE")," statement. It has exactly one child with the records to be deleted from the table. Your delete executor should produce an integer output that represents the number of rows that it deleted from the table. It will also need to update any affected indexes."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"bustub> EXPLAIN (o,s) DELETE FROM t1;\n=== OPTIMIZER ===\nDelete { table_oid=15 } | (__bustub_internal.delete_rows:INTEGER)\n  Filter { predicate=true } | (t1.v1:INTEGER, t1.v2:VARCHAR)\n    SeqScan { table=t1 } | (t1.v1:INTEGER, t1.v2:VARCHAR)\n\nbustub> EXPLAIN (o,s) DELETE FROM t1 where v1 = 1;\n=== OPTIMIZER ===\nDelete { table_oid=15 } | (__bustub_internal.delete_rows:INTEGER)\n  Filter { predicate=#0.0=1 } | (t1.v1:INTEGER, t1.v2:VARCHAR)\n    SeqScan { table=t1 } | (t1.v1:INTEGER, t1.v2:VARCHAR)\n\n")),(0,a.kt)("p",null,"You may assume that the ",(0,a.kt)("inlineCode",{parentName:"p"},"DeleteExecutor")," is always at the root of the query plan in which it appears. The ",(0,a.kt)("inlineCode",{parentName:"p"},"DeleteExecutor")," should not modify its result set."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," To delete a tuple, you need to get a ",(0,a.kt)("inlineCode",{parentName:"p"},"RID")," from the child executor and update the ",(0,a.kt)("inlineCode",{parentName:"p"},"is_deleted_")," field of the corresponding ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cmu-db/bustub/blob/master/src/include/storage/table/tuple.h"},(0,a.kt)("inlineCode",{parentName:"a"},"TupleMeta"))," for that tuple."),(0,a.kt)("h3",{id:"indexscan"},"IndexScan"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"IndexScanExecutor")," does point lookup and ordered scan using the b-plus tree index to retrieve tuples in the table. The executor should be able to support several point lookups on the same index."),(0,a.kt)("p",null,"You will need to implement the index scan by supporting the following two types of queries:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Point Lookup: ",(0,a.kt)("inlineCode",{parentName:"li"},"SELECT FROM <table> WHERE <index column> = <val>"),". You will implement the optimizer rule to transform a ",(0,a.kt)("inlineCode",{parentName:"li"},"SeqScan")," into an ",(0,a.kt)("inlineCode",{parentName:"li"},"IndexScan")," in the next section."),(0,a.kt)("li",{parentName:"ol"},"Ordered Scan: ",(0,a.kt)("inlineCode",{parentName:"li"},"SELECT FROM <table> ORDER BY <index column>"),". The optimizer rule to generate an ",(0,a.kt)("inlineCode",{parentName:"li"},"IndexScan")," for queries with ",(0,a.kt)("inlineCode",{parentName:"li"},"ORDER BY")," on an index column has been implemented for you. Your task is to handle ",(0,a.kt)("inlineCode",{parentName:"li"},"ASC")," (or default) ordering only in ",(0,a.kt)("inlineCode",{parentName:"li"},"IndexScan"),".")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"bustub> CREATE TABLE t1(v1 int, v2 int);\nTable created with id = 22\n\nbustub> CREATE INDEX t1v1 ON t1(v1);\nIndex created with id = 0\n\nbustub> EXPLAIN (o,s) SELECT * FROM t1 WHERE v1 = 1;\n=== OPTIMIZER ===\nIndexScan { index_oid=0, filter=(#0.0=1) } | (t1.v1:INTEGER, t1.v2:INTEGER)\n\nbustub> EXPLAIN (o,s) SELECT * FROM t1 ORDER BY v1;\n=== OPTIMIZER ===\nIndexScan { index_oid=0 } | (t1.v1:INTEGER, t1.v2:INTEGER)\n\n")),(0,a.kt)("p",null,"The type of the index object in the plan will always be ",(0,a.kt)("inlineCode",{parentName:"p"},"BPlusTreeIndexForTwoIntegerColumn")," in this project. You can safely cast the object to this type and store it in the executor wherever needed:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"tree_ = dynamic_cast<BPlusTreeIndexForTwoIntegerColumn *>(index_info_->index_.get())\n\n")),(0,a.kt)("p",null,"You can then do point lookup or ordered scan with the b-plus tree index and emit the satisfying tuple. In this semester, you only need to support the index on a single, unique integer column. Our test cases will not contain duplicate keys. Hence, this executor returns one tuple per point lookup if it exists."),(0,a.kt)("p",null,"You will need to finish the optimizer rule in the next section to transform a ",(0,a.kt)("inlineCode",{parentName:"p"},"SeqScan")," into an ",(0,a.kt)("inlineCode",{parentName:"p"},"IndexScan"),". It may make more sense to ",(0,a.kt)("strong",{parentName:"p"},"implement the optimizer rule before implementing ",(0,a.kt)("inlineCode",{parentName:"strong"},"IndexScan"))," to understand the kind of queries ",(0,a.kt)("inlineCode",{parentName:"p"},"IndexScanExecutor")," will need to support."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," We will never insert duplicate rows into tables with indexes."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," As above, do not emit tuples that are deleted."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," Please use ",(0,a.kt)("inlineCode",{parentName:"p"},"ScanKey")," for the point lookup, and use ",(0,a.kt)("inlineCode",{parentName:"p"},"Index Iterator")," for the ordered scan."),(0,a.kt)("h3",{id:"optimizing-seqscan-to-indexscan"},"Optimizing SeqScan to IndexScan"),(0,a.kt)("p",null,"As we learned in lecture, when we are querying on the indexed column, using an IndexScan will significantly boost the lookup performance. To this end, we need to push down the filter into the scanner so that we know the key to lookup in the index. Then we can directly retrieve the value over the index, instead of doing a full table scan."),(0,a.kt)("p",null,"You would need to modify the optimizer to transform a ",(0,a.kt)("inlineCode",{parentName:"p"},"SeqScanPlanNode")," into a ",(0,a.kt)("inlineCode",{parentName:"p"},"IndexScanPlanNode")," when it is possible."),(0,a.kt)("p",null,"Consider the following example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"bustub> EXPLAIN (o) SELECT * FROM t1 WHERE v1 = 1;\n\n")),(0,a.kt)("p",null,"Without applying the MergeFilterScan and the SeqScan as IndexScan optimizer rule, the plan may look like the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"}," Filter { predicate=(#0.0=1) } | (t1.v1:INTEGER, t1.v2:INTEGER, t1.v3:INTEGER)\n   SeqScan { table=t1 } | (t1.v1:INTEGER, t1.v2:INTEGER, t1.v3:INTEGER)\n\n")),(0,a.kt)("p",null,"After applying the MergeFilterScan and SeqScan as IndexScan optimizer rule, we can just do a quick index lookup instead of iterating the entire table. The resulting plan will look like the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"}," IndexScan { index_oid=0, filter=(#0.0=1) } | (t1.v1:INTEGER, t1.v2:INTEGER, t1.v3:INTEGER)\n\n")),(0,a.kt)("p",null,"Here's the brief steps to implement this optimizer rule:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Enable Predicate pushdown to SeqScan:")," We can implement a predicate filter in SeqScanExecutor so that later the index scan node will have the predicate. We've already enabled MergeFilterScan optimizer rule ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cmu-db/bustub/blob/master/src/optimizer/merge_filter_scan.cpp",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/optimizer/merge_filter_scan.cpp"))," in the starter optimizer rules for you.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Use Index:")," You can check the filtering columns from the predicate. If there happens to exist an index on this column, create an IndexScanPlanNode. Note that to get full score, you will need to support this optimizer rule in a few different situations: (1) when there's one equality test on the indexed column in predicate (i.e., ",(0,a.kt)("inlineCode",{parentName:"p"},"WHERE v1 = 1"),") (2) when the indexed column ordering is flipped (i.e., ",(0,a.kt)("inlineCode",{parentName:"p"},"WHERE 1 = v1"),") (3) when there are several point lookups on the same index (i.e., ",(0,a.kt)("inlineCode",{parentName:"p"},"WHERE v1 = 1 or v1 = 4"),"). Note that queries of the form ",(0,a.kt)("inlineCode",{parentName:"p"},"SELECT * FROM t1 WHERE v1 = 1 AND v2 = 2")," should still use a seq scan, thus you do not need to split the predicates."))),(0,a.kt)("p",null,"Please check ",(0,a.kt)("a",{parentName:"p",href:"https://15445.courses.cs.cmu.edu/fall2024/project3/#optimizer-guide"},"Optimizer Rule Implementation Guide")," section for details on implementing an optimizer rule."),(0,a.kt)("p",null,"Now that you have implemented all storage related executors. In the following tasks, you can create tables and insert some values by yourself to test your own executor implementation! At this point, you should also have passed ",(0,a.kt)("a",{parentName:"p",href:"https://15445.courses.cs.cmu.edu/fall2024/project3/#testing"},"SQLLogicTests #1 to #6"),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," You may find the utility ",(0,a.kt)("inlineCode",{parentName:"p"},"BPlusTreeIndex::ScanKey")," function helpful."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," Think about how to handle queries of the form ",(0,a.kt)("inlineCode",{parentName:"p"},"WHERE v1 = 1 OR v1 = 1"),". It may help to view ",(0,a.kt)("inlineCode",{parentName:"p"},"AggregateKey")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"/src/include/execution/plans/aggregation_plan.h"),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," Please only optimize ",(0,a.kt)("inlineCode",{parentName:"p"},"SeqScan")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"IndexScan")," in the 2 scenarios mentioned above (i.e. point lookup and ordered scan)."),(0,a.kt)("h2",{id:"task-2---aggregation--join-executors"},"Task ","#","2 - Aggregation & Join Executors"),(0,a.kt)("p",null,"You will complete your implementation in the following files:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/include/execution/aggregation_executor.h",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/include/execution/aggregation_executor.h"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/execution/aggregation_executor.cpp",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/execution/aggregation_executor.cpp"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/include/execution/nested_loop_join_executor.h",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/include/execution/nested_loop_join_executor.h"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/execution/nested_loop_join_executor.cpp",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/execution/nested_loop_join_executor.cpp"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/include/execution/nested_index_join_executor.h",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/include/execution/nested_index_join_executor.h"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/execution/nested_index_join_executor.cpp",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/execution/nested_index_join_executor.cpp")))),(0,a.kt)("h3",{id:"aggregation"},"Aggregation"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cmu-db/bustub/blob/master/src/include/execution/plans/aggregation_plan.h"},(0,a.kt)("inlineCode",{parentName:"a"},"AggregationPlanNode"))," is used to support queries like the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"EXPLAIN SELECT colA, MIN(colB) FROM __mock_table_1 GROUP BY colA;\nEXPLAIN SELECT COUNT(colA), min(colB) FROM __mock_table_1;\nEXPLAIN SELECT colA, MIN(colB) FROM __mock_table_1 GROUP BY colA HAVING MAX(colB) > 10;\nEXPLAIN SELECT DISTINCT colA, colB FROM __mock_table_1;\n\n")),(0,a.kt)("p",null,"The aggregation executor computes an aggregation function for each group of input. It has exactly one child.\nThe output schema consists of the group-by columns followed by the aggregation columns."),(0,a.kt)("p",null,"As discussed in class, a common strategy for implementing aggregation is to use a hash table, with the group-by columns as the key. In this project, you may assume that the aggregation hash table fits in memory. This means that you do not need to implement a multi-stage, partition-based strategy, and the hash table does not need to be backed by buffer pool pages."),(0,a.kt)("p",null,"We provide a ",(0,a.kt)("inlineCode",{parentName:"p"},"SimpleAggregationHashTable")," data structure that exposes an in-memory hash table ( ",(0,a.kt)("inlineCode",{parentName:"p"},"std::unordered_map"),") but with an interface designed for computing aggregations. This class also exposes an ",(0,a.kt)("inlineCode",{parentName:"p"},"SimpleAggregationHashTable::Iterator")," type that can be used to iterate through the hash table. You will need to complete the ",(0,a.kt)("inlineCode",{parentName:"p"},"CombineAggregateValues")," function for this class."),(0,a.kt)("p",null,"The aggregation executor itself will not need to handle the ",(0,a.kt)("inlineCode",{parentName:"p"},"HAVING")," predicate. The planner will plan aggregations with a ",(0,a.kt)("inlineCode",{parentName:"p"},"HAVING")," clause as an ",(0,a.kt)("inlineCode",{parentName:"p"},"AggregationPlanNode")," followed by a ",(0,a.kt)("inlineCode",{parentName:"p"},"FilterPlanNode"),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," In the context of a query plan, aggregations are ",(0,a.kt)("em",{parentName:"p"},"pipeline breakers"),". This may influence the way that you use the ",(0,a.kt)("inlineCode",{parentName:"p"},"AggregationExecutor::Init()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"AggregationExecutor::Next()")," functions in your implementation. Carefully decide whether the build phase of the aggregation should be performed in ",(0,a.kt)("inlineCode",{parentName:"p"},"AggregationExecutor::Init()")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"AggregationExecutor::Next()"),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," You must handle NULL values in the input of the aggregation functions (i.e., a tuple may have a NULL value for the attribute used in the aggregation function). See test cases for expected behavior. Group-by columns will never be NULL."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," When performing aggregation on an empty table, ",(0,a.kt)("inlineCode",{parentName:"p"},"CountStarAggregate")," should return zero and all other aggregate types should return ",(0,a.kt)("inlineCode",{parentName:"p"},"integer_null"),". This is why ",(0,a.kt)("inlineCode",{parentName:"p"},"GenerateInitialAggregateValue")," initializes most aggregate values as NULL."),(0,a.kt)("h3",{id:"nestedloopjoin"},"NestedLoopJoin"),(0,a.kt)("p",null,"The DBMS will use ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cmu-db/bustub/blob/master/src/include/execution/plans/nested_loop_join_plan.h"},(0,a.kt)("inlineCode",{parentName:"a"},"NestedLoopJoinPlanNode"))," for all join operations, by default. Consider the following example queries:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"EXPLAIN SELECT * FROM __mock_table_1, __mock_table_3 WHERE colA = colE;\nEXPLAIN SELECT * FROM __mock_table_1 INNER JOIN __mock_table_3 ON colA = colE;\nEXPLAIN SELECT * FROM __mock_table_1 LEFT OUTER JOIN __mock_table_3 ON colA = colE;\n\n")),(0,a.kt)("p",null,"You will need to implement an inner join and ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Join_(SQL)#Left_outer_join"},"left join")," for the ",(0,a.kt)("inlineCode",{parentName:"p"},"NestedLoopJoinExecutor")," using the simple nested loop join algorithm from class. The output schema of this operator is all columns from the left table followed by all columns from the right table.\nFor each tuple in the outer table, consider each tuple in the inner table and emit an output tuple if the join predicate is satisfied."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," You should use the predicate in the ",(0,a.kt)("inlineCode",{parentName:"p"},"NestedLoopJoinPlanNode"),". See ",(0,a.kt)("inlineCode",{parentName:"p"},"AbstractExpression::EvaluateJoin"),", which handles the left tuple and right tuple and their respective schemas. Note that this returns a ",(0,a.kt)("inlineCode",{parentName:"p"},"Value"),", which could be false, true, or NULL. See ",(0,a.kt)("inlineCode",{parentName:"p"},"FilterExecutor")," for how to apply predicates on tuples."),(0,a.kt)("h3",{id:"nestedindexjoin"},"NestedIndexJoin"),(0,a.kt)("p",null,"The DBMS will use ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cmu-db/bustub/blob/master/src/include/execution/plans/nested_index_join_plan.h"},(0,a.kt)("inlineCode",{parentName:"a"},"NestedIndexJoinPlanNode"))," if the query contains a join with an equi-condition and the right side of the join has an index over the condition."),(0,a.kt)("p",null,"Consider the following example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"CREATE TABLE t1(v1 int, v2 int);\nCREATE TABLE t2(v3 int, v4 int);\nCREATE INDEX t2v3 on t2(v3);\nEXPLAIN SELECT * FROM t1 INNER JOIN t2 ON v1 = v3;\n=== PLANNER ===\nProjection { exprs=[#0.0, #0.1, #0.2, #0.3] } | (t1.v1:INTEGER, t1.v2:INTEGER, t2.v3:INTEGER, t2.v4:INTEGER)\n  NestedLoopJoin { predicate=#0.0=#1.0 } | (t1.v1:INTEGER, t1.v2:INTEGER, t2.v3:INTEGER, t2.v4:INTEGER)\n    SeqScan { table=t1 } | (t1.v1:INTEGER, t1.v2:INTEGER)\n    SeqScan { table=t2 } | (t2.v3:INTEGER, t2.v4:INTEGER)\n=== OPTIMIZER ===\nNestedIndexJoin { type=Inner, key_predicate=#0.0, index=t2v3, index_table=t2 } | (t1.v1:INTEGER, t1.v2:INTEGER, t2.v3:INTEGER, t2.v4:INTEGER)\n  SeqScan { table=t1 } | (t1.v1:INTEGER, t1.v2:INTEGER)\n\n")),(0,a.kt)("p",null,"In the plan phase, the query is planned as a ",(0,a.kt)("inlineCode",{parentName:"p"},"NestedLoopJoin")," of two tables. The optimizer identifies that the right side of the join ( ",(0,a.kt)("inlineCode",{parentName:"p"},"SeqScan t2"),") has an index on column ",(0,a.kt)("inlineCode",{parentName:"p"},"v3"),", and the join condition is an equi-condition ",(0,a.kt)("inlineCode",{parentName:"p"},"v1 = v3"),". This means that for all tuples from the left side, the system can use the key ",(0,a.kt)("inlineCode",{parentName:"p"},"v1")," to query the index ",(0,a.kt)("inlineCode",{parentName:"p"},"t2v3")," to produce the join result."),(0,a.kt)("p",null,"The schema of ",(0,a.kt)("inlineCode",{parentName:"p"},"NestedIndexJoin")," is all columns from the left table (child, outer) and then from the right table (index, inner). This executor will have only one child that propagates tuples corresponding to the outer table of the join. For each of these tuples, you will need to find the corresponding tuple in the inner table that matches the index key given by utilizing the index in the catalog."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," You will want to fetch the tuple from the outer table, construct the index probe key by using ",(0,a.kt)("inlineCode",{parentName:"p"},"key_predicate"),", and then look up the RID in the index to retrieve the corresponding tuple for the inner table."),(0,a.kt)("p",null,"We will provide all test cases on Gradescope AS-IS. We will not test with strange edge cases involving NULLs (such as NULLs in the group-by clause or in indexes). At this point, you should pass ",(0,a.kt)("a",{parentName:"p",href:"https://15445.courses.cs.cmu.edu/fall2024/project3/#testing"},"SQLLogicTests - #7 to #13"),"."),(0,a.kt)("h2",{id:"task-3---hashjoin-executor-and-optimization"},"Task ","#","3 - HashJoin Executor and Optimization"),(0,a.kt)("p",null,"You will complete your implementation in the following files:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/include/execution/hash_join_executor.h",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/include/execution/hash_join_executor.h"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/execution/hash_join_executor.cpp",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/execution/hash_join_executor.cpp"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/optimizer/nlj_as_hash_join.cpp",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/optimizer/nlj_as_hash_join.cpp")))),(0,a.kt)("p",null,"You need to implement ",(0,a.kt)("inlineCode",{parentName:"p"},"NestedLoopJoinExecutor")," in ",(0,a.kt)("a",{parentName:"p",href:"https://15445.courses.cs.cmu.edu/fall2024/project3/#task2"},"Task #2")," before starting this task."),(0,a.kt)("h3",{id:"hashjoin"},"HashJoin"),(0,a.kt)("p",null,"The DBMS can use ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cmu-db/bustub/blob/master/src/include/execution/plans/hash_join_plan.h"},(0,a.kt)("inlineCode",{parentName:"a"},"HashJoinPlanNode"))," if a query contains a join with a conjunction of several equi-conditions between two columns (equi-conditions are seperated by ",(0,a.kt)("inlineCode",{parentName:"p"},"AND"),"). Consider the following example queries:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"EXPLAIN SELECT * FROM __mock_table_1, __mock_table_3 WHERE colA = colE;\nEXPLAIN SELECT * FROM __mock_table_1 INNER JOIN __mock_table_3 ON colA = colE;\nEXPLAIN SELECT * FROM __mock_table_1 LEFT OUTER JOIN __mock_table_3 ON colA = colE;\nEXPLAIN SELECT * FROM test_1 t1, test_2 t2 WHERE t1.colA = t2.colA AND t1.colB = t2.colC;\nEXPLAIN SELECT * FROM test_1 t1 INNER JOIN test_2 t2 on t1.colA = t2.colA AND t2.colC = t1.colB;\nEXPLAIN SELECT * FROM test_1 t1 LEFT OUTER JOIN test_2 t2 on t2.colA = t1.colA AND t2.colC = t1.colB;\n\n")),(0,a.kt)("p",null,"You will need to implement the inner join and ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Join_(SQL)#Left_outer_join"},"left join")," for ",(0,a.kt)("inlineCode",{parentName:"p"},"HashJoinExecutor")," using the hash join algorithm from class. The output schema of this operator is all columns from the left table followed by all columns from the right table. As with aggregation, you may assume that the hash table used by the join fits entirely in memory."),(0,a.kt)("p",null,"Your implementation should correctly handle the case where multiple tuples have hash collisions (on either side of the join). You will want to make use of the join key accessors functions ",(0,a.kt)("inlineCode",{parentName:"p"},"GetLeftJoinKey()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"GetRightJoinKey()")," in the ",(0,a.kt)("inlineCode",{parentName:"p"},"HashJoinPlanNode")," to construct the join keys for the left and right sides of the join, respectively."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," You will need a way to hash a tuple with multiple attributes in order to construct a unique key. As a starting point, take a look at how the ",(0,a.kt)("inlineCode",{parentName:"p"},"SimpleAggregationHashTable")," in the ",(0,a.kt)("inlineCode",{parentName:"p"},"AggregationExecutor")," implements this functionality."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," As with aggregation, the build side of a hash join is a ",(0,a.kt)("em",{parentName:"p"},"pipeline breaker"),". You should again consider whether the ",(0,a.kt)("em",{parentName:"p"},"build")," phase of the hash join should be performed in ",(0,a.kt)("inlineCode",{parentName:"p"},"HashJoinExecutor::Init()")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"HashJoinExecutor::Next()"),"."),(0,a.kt)("h3",{id:"optimizing-nestedloopjoin-to-hashjoin"},"Optimizing NestedLoopJoin to HashJoin"),(0,a.kt)("p",null,"Hash joins usually yield better performance than nested loop joins.\nYou should modify the optimizer to transform a ",(0,a.kt)("inlineCode",{parentName:"p"},"NestedLoopJoinPlanNode")," into a ",(0,a.kt)("inlineCode",{parentName:"p"},"HashJoinPlanNode")," when it is possible to use a hash join. Specifically, the hash join algorithm can be used when a join predicate is a conjunction of several equi-conditions between two columns. For this project, you should be able to handle a varying number of equi-conditions connected by ",(0,a.kt)("inlineCode",{parentName:"p"},"AND"),"."),(0,a.kt)("p",null,"Consider the following example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"bustub> EXPLAIN (o) SELECT * FROM test_1 t1, test_2 t2 WHERE t1.colA = t2.colA AND t1.colB = t2.colC;\n\n")),(0,a.kt)("p",null,"Without applying the ",(0,a.kt)("inlineCode",{parentName:"p"},"NLJAsHashJoin")," optimizer rule, the plan may look like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"}," NestedLoopJoin { type=Inner, predicate=((#0.0=#1.0)and(#0.1=#1.2)) }\n   SeqScan { table=test_1 }\n   SeqScan { table=test_2 }\n\n")),(0,a.kt)("p",null,"After applying the ",(0,a.kt)("inlineCode",{parentName:"p"},"NLJAsHashJoin")," optimizer rule, the left and right join key expressions will be extracted from the single\njoin predicate in the ",(0,a.kt)("inlineCode",{parentName:"p"},"NestedLoopJoinPlanNode"),". The resulting plan will look like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"}," HashJoin { type=Inner, left_key=[#0.0, #0.1], right_key=[#0.0, #0.2] }\n   SeqScan { table=test_1 }\n   SeqScan { table=test_2 }\n\n")),(0,a.kt)("p",null,"Please check the ",(0,a.kt)("a",{parentName:"p",href:"https://15445.courses.cs.cmu.edu/fall2024/project3/#optimizer-guide"},"Optimizer Rule Implementation Guide")," section for details on implementing an optimizer rule. At this point, you should pass ",(0,a.kt)("a",{parentName:"p",href:"https://15445.courses.cs.cmu.edu/fall2024/project3/#testing"},"SQLLogicTests - #14 to #15"),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," Make sure to check which table the column belongs to for each side of the equi-condition. It is possible that the column from outer table is on the right side of the equi-condition. You may find ",(0,a.kt)("inlineCode",{parentName:"p"},"ColumnValueExpression::GetTupleIdx")," helpful."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," The order to apply optimizer rules matters. For example, you want to optimize NestedLoopJoin into HashJoin after filters and NestedLoopJoin have merged."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint")," When dealing with multiple equi-conditions, try to extract out the keys recursively, instead of matching the joining condition with multiple layers of if clauses."),(0,a.kt)("h2",{id:"task-4-external-merge-sort--limit-executors"},"Task ","#","4: External Merge Sort + Limit Executors"),(0,a.kt)("p",null,"You will complete your implementation in the following files:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/include/execution/external_merge_sort_executor.h",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/include/execution/external_merge_sort_executor.h"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/execution/external_merge_sort_executor.cpp",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/execution/external_merge_sort_executor.cpp"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/include/execution/limit_executor.h",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/include/execution/limit_executor.h"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/cmu-db/bustub/blob/master/src/execution/limit_executor.cpp",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/execution/limit_executor.cpp")))),(0,a.kt)("p",null,"You need to implement ",(0,a.kt)("inlineCode",{parentName:"p"},"IndexScanExecutor")," in ",(0,a.kt)("a",{parentName:"p",href:"https://15445.courses.cs.cmu.edu/fall2024/project3/#task1"},"Task #1")," before starting this task. If there is an index over a table, the query processing layer will automatically pick it for sorting. In other cases, you will need a special sort executor to do this, which, in our case, is the external merge sort executor."),(0,a.kt)("p",null,"The limit executor will be much easier to implement than the external merge sort executor. Therefore, feel free to implement the limit executor first if you are stuck on the external merge sort executor. You should however be aware that we won't test the limit executor without the external merge sort executor."),(0,a.kt)("p",null,"For all ",(0,a.kt)("inlineCode",{parentName:"p"},"ORDER BY")," clauses, we assume every sort key will only appear once. You do not need to worry about ties in sorting."),(0,a.kt)("h3",{id:"external-merge-sort"},"External Merge Sort"),(0,a.kt)("p",null,"Except in the case that the ",(0,a.kt)("inlineCode",{parentName:"p"},"ORDER BY")," attributes matches the keys of an index, BusTub will use a ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cmu-db/bustub/blob/master/src/include/execution/plans/sort_plan.h"},(0,a.kt)("inlineCode",{parentName:"a"},"SortPlanNode"))," for all ",(0,a.kt)("inlineCode",{parentName:"p"},"ORDER BY")," operators."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"EXPLAIN SELECT * FROM __mock_table_1 ORDER BY colA ASC, colB DESC;\n\n")),(0,a.kt)("p",null,"This plan node does not change schema (i.e., the output schema is the same as the input schema). You can extract sort keys from ",(0,a.kt)("inlineCode",{parentName:"p"},"order_bys"),". If the query does not include a sort direction in the ",(0,a.kt)("inlineCode",{parentName:"p"},"ORDER BY")," clause (i.e., ",(0,a.kt)("inlineCode",{parentName:"p"},"ASC"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"DESC"),"), then the sort mode will be ",(0,a.kt)("inlineCode",{parentName:"p"},"default")," (which is ",(0,a.kt)("inlineCode",{parentName:"p"},"ASC"),")."),(0,a.kt)("p",null,"One important assumption about the external merge sort is that the entries in a table will NOT be able to fit in memory. Therefore, you need to follow what you learned in the lecture: store the intermediate sorting results in temporary pages and do merge sort recursively based on the sorted results of the previous round."),(0,a.kt)("p",null,"As you may be aware of, a specific page format will be needed for the intermediate sorting results. In this project, you will be the one who designs the page format. Take a look at ",(0,a.kt)("inlineCode",{parentName:"p"},"external_merge_sort_executor.h")," and you will find ",(0,a.kt)("inlineCode",{parentName:"p"},"SortPage"),", which is dedicated for storing the intermediate sorting results but contains minimal pre-defined members/methods. You should design the page layout and implement the read/write methods for the page."),(0,a.kt)("p",null,'You will then implement the merge sort algorithm. It is not hard to do an in-memory merge sort. But when it involves the disk, you should carefully think of how you manipulate the sorted tuples via the page interfaces and the buffer pool. It is worth noting that the page that\'s no longer in use (i.e. from the previous round of merge sort) should be deleted, or you will have a bunch of "zombie" pages that will never be referred to but still exist in the buffer pool.'),(0,a.kt)("p",null,"To simplify your implementation of ",(0,a.kt)("inlineCode",{parentName:"p"},"SortPage"),", ",(0,a.kt)("strong",{parentName:"p"},"we will only test on sorting fixed-length tuples in this semester.")," That is to say, we will not sort tuples containing ",(0,a.kt)("inlineCode",{parentName:"p"},"VARCHAR")," attributes. Also, ",(0,a.kt)("strong",{parentName:"p"},"we will only test on two-way external merge sort this semester")," even though ",(0,a.kt)("inlineCode",{parentName:"p"},"ExternalMergeSortExecutor")," is templated. Therefore, feel free to implement a two-way merge sort algorithm instead of a k-way one."),(0,a.kt)("p",null,"However, it's important that your are doing the merge sort ",(0,a.kt)("em",{parentName:"p"},"externally")," (not storing all data purely in memory). You are allowed to use ",(0,a.kt)("inlineCode",{parentName:"p"},"std::sort")," to sort tuples fitting within one sort page, but NOT on all tuples. Also, your ",(0,a.kt)("inlineCode",{parentName:"p"},"SortPage")," layout should be compact, i.e. as little fragmentation as possible. You should also make sure that the pages are actually deleted after the merge sort is done."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," For comparison of tuples based on the sort key, we provide a helper class ",(0,a.kt)("inlineCode",{parentName:"p"},"TupleComparator")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"execution_common.h"),". We also provide a helper function ",(0,a.kt)("inlineCode",{parentName:"p"},"GenerateSortKey"),", which you may find helpful when sorting the tuples."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," To better understand what to do and where to start for ",(0,a.kt)("inlineCode",{parentName:"p"},"SortPage"),", you can take a look at the layout of the index pages you worked on in project 2 (e.g. a ",(0,a.kt)("inlineCode",{parentName:"p"},"char")," array can be used as the start of page data). You may find ",(0,a.kt)("inlineCode",{parentName:"p"},"Schema::GetInlinedStorageSize")," helpful given the assumption that we only test on fixed-length data. Also, it would be helpful to think of how your executor will call the read/write methods."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:"),' You don\'t really need to manually manipulate the "write-to-disk" part when doing the external merge sort. The buffer pool manager will handle this for you. Remember what you implemented in P1: the page guard will automatically pin and unpin a page, as well as setting the evictability. Just make proper use of the page guard and you will not be worrying too much for page manipulation in this project.'),(0,a.kt)("h3",{id:"limit"},"Limit"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cmu-db/bustub/blob/master/src/include/execution/plans/limit_plan.h"},(0,a.kt)("inlineCode",{parentName:"a"},"LimitPlanNode"))," specifies the number of tuples that query will generate. Consider the following example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"EXPLAIN SELECT * FROM __mock_table_1 LIMIT 10;\n\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"LimitExecutor")," constrains the number of output tuples from its child executor. If the number of tuples produced by its child executor is less than the limit specified in the plan node, this executor has no effect and yields all of the tuples that it receives."),(0,a.kt)("p",null,"This plan node does not change schema (i.e., the output schema is the same as the input schema). You do not need to support offsets."),(0,a.kt)("h2",{id:"optional-leaderboard-tasks"},"Optional Leaderboard Tasks"),(0,a.kt)("p",null,"For this project's leaderboard challenge, you should implement new executors and optimizer rules to make the system execute the following queries as fast as possible."),(0,a.kt)("p",null,"These tasks are optional. You do not need to complete them to get a perfect score on the project. Unlike previous projects, segfaults and timeouts in project 3 leaderboard tests will not affect your score."),(0,a.kt)("p",null,"It is possible that your implementation will produce different results for existing queries after implementing the leaderboard optimizations. We require you to pass all tests after implementing new optimization rules. We will also force using starter rules for some test cases. For example, in order to ensure your index scan executor works, we force the starter rule in this sqllogictest file with ",(0,a.kt)("inlineCode",{parentName:"p"},"set force_optimizer_starter_rule=yes"),"."),(0,a.kt)("h3",{id:"query-1-too-many-joins"},"Query 1: Too Many Joins!"),(0,a.kt)("p",null,"Consider the following sample database:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"CREATE TABLE t4(x int, y int);\nCREATE TABLE t5(x int, y int);\nCREATE TABLE t6(x int, y int);\n\n")),(0,a.kt)("p",null,"The user is not from CMU and they are writing terrible SQL. They forgot how write queries with joins so they puts all predicates in the ",(0,a.kt)("inlineCode",{parentName:"p"},"WHERE")," clause."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"SELECT * FROM t4, t5, t6\n  WHERE (t4.x = t5.x) AND (t5.y = t6.y) AND (t4.y >= 1000000)\n    AND (t4.y < 1500000) AND (t6.x >= 100000) AND (t6.x < 150000);\n\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Recommended Optimizations:")," Decompose the filter condition to extract hash join keys, and push down the remaining filter conditions to be below the hash join."),(0,a.kt)("h3",{id:"query-2-the-mad-data-scientist"},"Query 2: The Mad Data Scientist"),(0,a.kt)("p",null,"There is a data scientist invested all their money in NFTs. After realizing their terrible mistake, they go crazy and starts writing some weird SQL queries. Consider the following example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"SELECT v, d1, d2 FROM (\n  SELECT v,\n         MAX(v1) AS d1, MIN(v1), MAX(v2), MIN(v2),\n         MAX(v1) + MIN(v1), MAX(v2) + MIN(v2),\n         MAX(v1) + MAX(v1) + MAX(v2) AS d2\n    FROM t7 LEFT JOIN (SELECT v4 FROM t8 WHERE 1 == 2) ON v < v4\n    GROUP BY v\n)\n\n")),(0,a.kt)("p",null,"(This is not the same as the actual leaderboard query; refer to the test file.)"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Recommended Optimizations:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Column pruning \u2013 you only need to compute v, d1, d2 from the left table in aggregation. We've provided a skeleton file ",(0,a.kt)("inlineCode",{parentName:"li"},"column_pruning.cpp"),"."),(0,a.kt)("li",{parentName:"ul"},"Common expression elimination, transform always false filter to dummy scan (values plan node of zero rows)"),(0,a.kt)("li",{parentName:"ul"},"Some more if you could think of :)")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hint:")," You do not need to implement a complete rule for optimizing these queries. (1) a complete predicate pushdown requires you to handle all plan nodes \u2013 limit, order by, etc. But to optimize for Q2, you only need to implement push down predicates over hash join / nested loop joins. (2) a complete join reordering requires you to handle predicates correctly (and maybe absorb filters in-between back to the join predicate), and you do not need to do that. Just make your optimizer work with those queries is enough."),(0,a.kt)("h3",{id:"query-3-all-that-work-for-nothing"},"Query 3: All that work, for nothing?"),(0,a.kt)("p",null,"After all the hard work with Q1 and Q2, here's something short and sweet. Imagine you have the following 2 tables representing everyone alive in the 1950s, and everyone born in the 1600s. Someone with no concept of human lifespan (or a firm belief in vampires) tries to construct a query that outputs the intersection of the 2 tables. You know the result will be empty, but your join executors won't, what can you do to help speed up the process?"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"SELECT * FROM alive_in_1950s a INNER JOIN born_in_1600s b ON a.birthday = b.birthday\n\n")),(0,a.kt)("p",null,"(This is not the same as the actual leaderboard query; refer to the test file.)"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Recommended Optimizations:")," Bloom filter for the hash table used during the build phase of the hash join."),(0,a.kt)("h3",{id:"leaderboard-policy"},"Leaderboard Policy"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Submissions ",(0,a.kt)("em",{parentName:"li"},"with leaderboard bonus")," are subject to manual review by TAs.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},'By saying "review", it means that TAs will manually look into your code, or if they are unsure whether an optimization is correct or not by looking, they will make simple modification to existing test cases to see if your leaderboard optimization ',(0,a.kt)("em",{parentName:"li"},"correctly")," handled the specific cases that you want to optimize."),(0,a.kt)("li",{parentName:"ul"},"One example of simple modification: change the buffer pool manager size for the benchmark."))),(0,a.kt)("li",{parentName:"ul"},"Your optimization should not affect correctness. You can optimize for specific cases, but it should work for all inputs in your optimized cases.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Allowed: only handling 3-table join reordering in Fall 2022 project 3."),(0,a.kt)("li",{parentName:"ul"},"Allowed: optimize for leaf node size > 100 in project 2."),(0,a.kt)("li",{parentName:"ul"},"Disallowed: compare the plan with the leaderboard test and convert it to ValueExecutor with the output table in project 3. That\u2019s because your optimization should work for all table contents. Hardcoding the answer will yield wrong result in some cases."))),(0,a.kt)("li",{parentName:"ul"},"You should not try detecting whether your submission is running leaderboard test by using side information.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Unless we allow you to do so."),(0,a.kt)("li",{parentName:"ul"},"Disallowed: use\xa0",(0,a.kt)("inlineCode",{parentName:"li"},"#ifdef NDEBUG"),", etc."))),(0,a.kt)("li",{parentName:"ul"},"Submissions with obvious correctness issues will not be assigned leaderboard bonus."),(0,a.kt)("li",{parentName:"ul"},"You cannot use late days for leaderboard tests."),(0,a.kt)("li",{parentName:"ul"},"If you are unsure about whether an optimization is reasonable, you should post on Piazza or visit any TA's office hour.")),(0,a.kt)("h1",{id:"additional-information"},"Additional Information"),(0,a.kt)("p",null,"This section provides some additional information on other system components in BusTub that you will need to interact in order to complete this project."),(0,a.kt)("h2",{id:"system-catalog"},"System Catalog"),(0,a.kt)("p",null,"A database maintains an internal catalog to keep track of meta-data about the database. In this project, you will interact with the system catalog to query information regarding tables, indexes, and their schemas."),(0,a.kt)("p",null,"The entirety of the catalog implementation is in ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cmu-db/bustub/blob/master/src/include/catalog/catalog.h",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"src/include/catalog/catalog.h")),". You should pay particular attention to the member functions ",(0,a.kt)("inlineCode",{parentName:"p"},"Catalog::GetTable()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Catalog::GetIndex()"),". You will use these functions in the implementation of your executors to query the catalog for tables and indexes."),(0,a.kt)("h2",{id:"index-updates"},"Index Updates"),(0,a.kt)("p",null,"For the table modification executors ( ",(0,a.kt)("inlineCode",{parentName:"p"},"InsertExecutor"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"UpdateExecutor"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"DeleteExecutor"),") you must modify all indexes for the table targeted by the operation. You may find the ",(0,a.kt)("inlineCode",{parentName:"p"},"Catalog::GetTableIndexes()")," function useful for querying all of the indexes defined for a particular table. Once you have the ",(0,a.kt)("inlineCode",{parentName:"p"},"IndexInfo")," instance for each of the table's indexes, you can invoke index modification operations on the underlying index structure."),(0,a.kt)("p",null,"In this project, we use your implementation of b-plus tree index from ",(0,a.kt)("a",{parentName:"p",href:"https://15445.courses.cs.cmu.edu/fall2024/project2"},"Project #2")," as the underlying data structure for all index operations. Therefore, successful completion of this project relies on a working implementation of the b-plus tree."),(0,a.kt)("h2",{id:"optimizer-rule-implementation-guide"},"Optimizer Rule Implementation Guide"),(0,a.kt)("p",null,"The BusTub optimizer is a rule-based optimizer. Most optimizer rules construct optimized plans in a bottom-up way. Because the query plan has this tree structure, before applying the optimizer rules to the current plan node, you want to first recursively apply the rules to its children."),(0,a.kt)("p",null,"At each plan node, you should determine if the source plan structure matches the one you are trying to optimize, and then check the attributes in that plan to see if it can be optimized into the target optimized plan structure."),(0,a.kt)("p",null,"In the public BusTub repository, we already provide the implementation of several optimizer rules. Please take a look at them as reference."),(0,a.kt)("h1",{id:"instructions"},"Instructions"),(0,a.kt)("p",null,"See the ",(0,a.kt)("a",{parentName:"p",href:"https://15445.courses.cs.cmu.edu/fall2024/project0/#instructions"},"Project #0 instructions")," for how to create your private repository and set up your development environment."),(0,a.kt)("p",null,"You must pull the latest changes from the upstream BusTub repository for test files and other supplementary files we provide in this project."),(0,a.kt)("h2",{id:"testing"},"Testing"),(0,a.kt)("p",null,"We will use ",(0,a.kt)("inlineCode",{parentName:"p"},"SQLLogicTest")," to perform testing and benchmarking. To use it,"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"make -j$(nproc) sqllogictest\n./bin/bustub-sqllogictest ../test/sql/p3.00-primer.slt --verbose\n\n")),(0,a.kt)("p",null,"You can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"bustub-sqllogictest")," program to run ",(0,a.kt)("inlineCode",{parentName:"p"},"slt")," files. Remember to recompile ",(0,a.kt)("inlineCode",{parentName:"p"},"sqllogictest")," before doing any testing. In this project, we provide ALL test cases to you. There are no hidden tests. The test cases are located at ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/cmu-db/bustub/blob/master/test/sql/",title:"View Source Code"},(0,a.kt)("inlineCode",{parentName:"a"},"test/sql/")),"."),(0,a.kt)("h2",{id:"formatting"},"Formatting"),(0,a.kt)("p",null,"Your code must follow the ",(0,a.kt)("a",{parentName:"p",href:"https://google.github.io/styleguide/cppguide.html"},"Google C++ Style Guide"),".\nWe use ",(0,a.kt)("a",{parentName:"p",href:"https://clang.llvm.org/"},"Clang")," to automatically check the quality of your source code.\nYour project grade will be ",(0,a.kt)("strong",{parentName:"p"},"zero")," if your submission fails any of these checks."),(0,a.kt)("p",null,"Execute the following commands to check your syntax.\nThe ",(0,a.kt)("inlineCode",{parentName:"p"},"format")," target will automatically correct your code.\nThe ",(0,a.kt)("inlineCode",{parentName:"p"},"check-lint")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"check-clang-tidy-p3")," targets will print errors and instruct you how to fix it to conform to our style guide."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"$ make format\n$ make check-lint\n$ make check-clang-tidy-p3\n\n")),(0,a.kt)("h2",{id:"memory-leaks"},"Memory Leaks"),(0,a.kt)("p",null,"For this project, we use ",(0,a.kt)("a",{parentName:"p",href:"https://clang.llvm.org/docs/AddressSanitizer.html"},"LLVM Address Sanitizer (ASAN) and Leak Sanitizer (LSAN)")," to check for memory errors. To enable ASAN and LSAN, configure CMake in debug mode and run tests as you normally would. If there is memory error, you will see a memory error report. Note that macOS ",(0,a.kt)("strong",{parentName:"p"},"only supports address sanitizer without leak sanitizer"),"."),(0,a.kt)("p",null,"In some cases, address sanitizer might affect the usability of the debugger. In this case, you might need to disable all sanitizers by configuring the CMake project with:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"$ cmake -DCMAKE_BUILD_TYPE=Debug -DBUSTUB_SANITIZER= ..\n\n")),(0,a.kt)("h2",{id:"development-hints"},"Development Hints"),(0,a.kt)("p",null,"You can use ",(0,a.kt)("inlineCode",{parentName:"p"},"BUSTUB_ASSERT")," for assertions in debug mode. Note that the statements within ",(0,a.kt)("inlineCode",{parentName:"p"},"BUSTUB_ASSERT")," will NOT be executed in release mode.\nIf you have something to assert in all cases, use ",(0,a.kt)("inlineCode",{parentName:"p"},"BUSTUB_ENSURE")," instead."),(0,a.kt)("p",null,"We encourage you to use a graphical debugger to debug your project if you are having problems."),(0,a.kt)("p",null,"If you are having compilation problems, running ",(0,a.kt)("inlineCode",{parentName:"p"},"make clean")," does not completely reset the compilation process. You will need to delete your build directory and run ",(0,a.kt)("inlineCode",{parentName:"p"},"cmake ..")," again before you rerun ",(0,a.kt)("inlineCode",{parentName:"p"},"make"),"."),(0,a.kt)("p",null,"Post all of your questions about this project on Piazza. Do not email the TAs directly with questions."),(0,a.kt)("h1",{id:"grading-rubric"},"Grading Rubric"),(0,a.kt)("p",null,"Each project submission will be graded based on the following criteria:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Does the submission successfully execute all of the test cases and produce the correct answer?"),(0,a.kt)("li",{parentName:"ol"},"Does the submission execute without any memory leaks?"),(0,a.kt)("li",{parentName:"ol"},"Does the submission follow the code formatting and style policies?")),(0,a.kt)("h1",{id:"late-policy"},"Late Policy"),(0,a.kt)("p",null,"See the ",(0,a.kt)("a",{parentName:"p",href:"https://15445.courses.cs.cmu.edu/fall2024/syllabus.html#late-policy"},"late policy")," in the syllabus."),(0,a.kt)("h1",{id:"submission"},"Submission"),(0,a.kt)("p",null,"After completing the assignment, you can submit your implementation to Gradescope:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("a",{parentName:"strong",href:"https://www.gradescope.com/courses/817456"},"https://www.gradescope.com/courses/817456")))),(0,a.kt)("p",null,"Running ",(0,a.kt)("inlineCode",{parentName:"p"},"make submit-p3")," in your ",(0,a.kt)("inlineCode",{parentName:"p"},"build/")," directory will generate a ",(0,a.kt)("inlineCode",{parentName:"p"},"zip")," archive called ",(0,a.kt)("inlineCode",{parentName:"p"},"project3-submission.zip")," under your project root directory that you can submit to Gradescope."),(0,a.kt)("p",null,"Remember to resolve all style issues before submitting:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"make format\nmake check-clang-tidy-p3\n\n")),(0,a.kt)("h1",{id:"collaboration-policy"},"Collaboration Policy"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Every student has to work individually on this assignment."),(0,a.kt)("li",{parentName:"ul"},"Students are allowed to discuss high-level details about the project with others."),(0,a.kt)("li",{parentName:"ul"},"Students are ",(0,a.kt)("strong",{parentName:"li"},"not")," allowed to copy the contents of a white-board after a group meeting with other students."),(0,a.kt)("li",{parentName:"ul"},"Students are ",(0,a.kt)("strong",{parentName:"li"},"not")," allowed to copy the solutions from another colleague.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"WARNING:")," All of the code for this project must be your own. You may not copy source code from other students or other sources that you find on the web. Plagiarism ",(0,a.kt)("strong",{parentName:"p"},"will not")," be tolerated. See CMU's ",(0,a.kt)("a",{parentName:"p",href:"https://www.cmu.edu/policies/student-and-student-life/academic-integrity.html"},"Policy on Academic Integrity")," for additional information."))}d.isMDXComponent=!0},94283:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/mock_scan-8166f0b03b5d30b5cba6f8d182888bc9.svg"},73099:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/more_complex_example-a7ebbeead255ddd642358743b9798d17.svg"},57542:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/project-structure-815d681d303c6c1953a34032587bb495.svg"}}]);